ZAS Relocating Macro Assembler (v3.05                             page    1
                                                            
                                                            

  0000           
  0000           ; Program:      Z33RCP
  0000           ; Version:      1.0
  0000           ; Description:  Resident Command Package (RCP) for ZCPR33
  0000           ; Author:       Jay Sage
  0000           ; Date:         March 1, 1987
  0000           ; Derivation:   SYSRCP (Richard Conn) and many other contributions
  0000           
  0002 =         version equ     2
  0001 =         subver  equ     1               ; Version 2.1
  0000           
  0000           ; Version 2.1 - 20080212 - P. Betti <pbetti@lpconsul.net>
  0000           ; little changes to include datestamper code in RCP space (if space is available)
  0000           
  0000           ;=============================================================================
  0000           ;
  0000           ;               D E F I N I T I O N S    S E C T I O N
  0000           ;
  0000           ;=============================================================================
  0000           
  0000+                  maclib  common.asm
  0000+          ;
  0000+          ; Here just some common symbol...
  0000+          ;
  0000+          
  0016+=         VERS    EQU     22              ; VERSION 2.2 (CP/M related)
  0000+          ;
  003C+=         MSIZE   EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0000+          ;MSIZE  EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0400+=         RESROOM EQU     1024            ; RESERVED ROOM SPACE BELOW MONITOR (F000)
  0600+=         BIOSTDS EQU     1536            ; BIOS STANDARD SIZE
  0A00+=         BIOREAS EQU     BIOSTDS+RESROOM ; BIOS REAL SIZE
  0400+=         ZSTDOVR EQU     1024            ; ZCPR STANDARD OVERHEAD SIZE
  0000+=         ZIOPKG  EQU     0               ; ZCPR IO PACKAGE SIZE
  0800+=         ZRESPKG EQU     2048            ; ZCPR RESIDENT CMD PKG SIZE
  0200+=         ZFLOPKG EQU     512             ; ZCPR FLOW CMD PACKAGE SIZE
  01C8+=         ZDSSTSZ EQU     01C8H           ; ZDS Stamper reserved space
  0000+          
  1200+=         EXTRABIAS       EQU     RESROOM+ZSTDOVR+ZIOPKG+ZRESPKG+ZFLOPKG  ; ...
  0000+                  ;
  0000+                  ;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  0000+                  ;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  0000+                  ;
  8E00+=         BIAS    EQU     ((MSIZE-20)*1024)-EXTRABIAS
  C200+=         CCP     EQU     3400H+BIAS      ; BASE OF CCP
  CA06+=         BDOS    EQU     CCP+0806H       ; BASE OF BDOS
  CA00+=         BDOSB   EQU     CCP+0800H       ; BDOS base offset
  D800+=         BIOS    EQU     CCP+1600H       ; BASE OF BIOS
  E200+=         ZBUFBAS EQU     BIOS+BIOREAS    ; BASE OF ZCPR3 BUFFERS
  0000+                  ;
  0000+                  ;       some other equs...
  0000+                  ;
  000D+=         CR      EQU     0DH             ; CARRIAGE RETURN
  000A+=         LF      EQU     0AH             ; LINE FEED;
  000C+=         FF      EQU     0CH             ; FORM FEED (clear screen)
  FFFF+=         TRUE    EQU     -1              ; ....
ZAS Relocating Macro Assembler (v3.05                             page    2
                                                            
                                                            

  0000+=         FALSE   EQU     0
  0000+=         INTRON  EQU     FALSE           ; Interrupts disabled
  0000+                  ;
  0000+                  ; define which kind of date stamper must be embedded in
  0000+                  ; RCP
  0000+                  ;
  0000+=         STMPP2  EQU     FALSE           ; P2DOS date stamper
  FFFF+=         STMPZS  EQU     TRUE            ; ZSDOS date stamper    
  FFFF+=         HASEDS  EQU     (STMPP2+STMPZS) ; set a flag for embedded date stamper
  0000+                  ;
  0000+                  ; path for ZCPR3 used on cold boot
  0000+                  ;
  0024+=         IDISK1  EQU     '$'             ; 1st: current disk, current user
  0024+=         IUSER1  EQU     '$'
  0024+=         IDISK2  EQU     '$'             ; 2nd: current disk, user 15
  000F+=         IUSER2  EQU     15
  0001+=         IDISK3  EQU     'A'-'@'         ; 3rd: disk A, current user
  0024+=         IUSER3  EQU     '$'
  0001+=         IDISK4  EQU     'A'-'@'         ; 4th: disk A, user 15
  000F+=         IUSER4  EQU     15
  0000+          
  0000+          ; COMMON.ASM [EOF]
  0000+                  maclib  sysdef.lib      ; Common logic, sys, ascii defines
  0000+          ;LIBRARY OF COMMONLY USED DEFINITIONS
  0000+          ;Use of this library will make assembly language
  0000+          ;programs easier to read and maintain.
  0000+          ;
  0000+          ;The following definitions were collected by
  0000+          ;simply extracting them from ZCPR3 utilities.
  0000+          ;Please feel free to add to this list and to
  0000+          ;comment on the preferred definition where
  0000+          ;there are several equivalent ones. Bump the
  0000+          ;revision # and send it back for coordination.
  0000+          ;
  0000+          ;Version 1.0 - 31 Jan 1986
  0000+          ;Al Hawley, Z-Node #2, (213) 670-9465
  0000+          
  0000+          ;----------------------------------------------
  0000+          ;Logic Definitions
  0000+          
  0000+          ; FALSE EQU     0               ;these all seem to be
  0000+          ; TRUE  EQU     NOT FALSE       ;..appropriate in
  FFFF+=         YES     EQU     TRUE            ;..different contexts.
  0000+=         NO      EQU     FALSE
  0000+          
  0000+          ;----------------------------------------------
  0000+          ; System Functions
  0000+          ;
  0001+=         RDCONF          EQU     1
  0002+=         WRCONF          EQU     2
  0003+=         RDRF            EQU     3
  0004+=         PUNCHF          EQU     4
  0005+=         LISTF           EQU     5
  0006+=         DIRCONF         EQU     6
  0009+=         PRBUFF          EQU     9
  000A+=         RDBUFF          EQU     10
ZAS Relocating Macro Assembler (v3.05                             page    3
                                                            
                                                            

  000B+=         CONSTF          EQU     11
  000C+=         VERNOF          EQU     12
  000D+=         RESETDKF        EQU     13
  000E+=         LOGINF          EQU     14
  000F+=         OPENF           EQU     15
  0010+=         CLOSEF          EQU     16
  0011+=         SRCHFF          EQU     17
  0012+=         SRCHNF          EQU     18
  0013+=         ERASEF          EQU     19
  0014+=         READF           EQU     20
  0015+=         WRITEF          EQU     21
  0016+=         MAKEF           EQU     22
  0017+=         RENF            EQU     23
  0019+=         INQDISKF        EQU     25
  001A+=         SETDMAF         EQU     26
  001B+=         INQALCF         EQU     27
  001E+=         ATTRF           EQU     30
  001F+=         GETPARMF        EQU     31
  0020+=         SGUSERF         EQU     32
  00FF+=         GETF            EQU     0FFH            ;get user area e-reg value
  0023+=         COMPSZF         EQU     35
  0024+=         SETRRF          EQU     36
  0000+          
  0000+          
  0000+          ;----------------------------------------------
  0000+          ; System Addresses
  0000+          ;
  0000+=         OS$BASE EQU     000H            ;system base..
  0800+=         CCPLEN  EQU     800H            ;..and 'CCP' length in bytes.
  0000+=         WBOOT   EQU     OS$BASE+0
  0003+=         IOBYTE  EQU     OS$BASE+03H
  0004+=         UDFLAG  EQU     OS$BASE+04H
  0000+          ;BDOS   EQU     OS$BASE+05H
  0000+          
  005C+=         FCB     EQU     OS$BASE+5CH
  005C+=         TFCB    EQU     OS$BASE+5CH
  005C+=         FCB1    EQU     OS$BASE+5CH     ;preferred (AEH)
  0000+          
  006C+=         FCB2    EQU     OS$BASE+6CH
  0000+          
  0068+=         FCBEXT  EQU     FCB+12
  007C+=         FCBRNO  EQU     FCB+32
  0000+          
  0080+=         TBUF    EQU     OS$BASE+80H
  0080+=         TBUFF   EQU     OS$BASE+80H
  0000+          
  0100+=         TPA     EQU     OS$BASE+100H
  0000+          
  0000+          ;----------------------------------------------
  0000+          ; ASCII Definitions
  0000+          ;
  0001+=         CTRLA   EQU     'A'-'@'
  0003+=         CTRLC   EQU     'C'-'@'         ;..control-C..
  0004+=         CTRLD   EQU     'D'-'@'
  0005+=         CTRLE   EQU     'E'-'@'
  0006+=         CTRLF   EQU     'F'-'@'
ZAS Relocating Macro Assembler (v3.05                             page    4
                                                            
                                                            

  000B+=         CTRLK   EQU     'K'-'@'
  0012+=         CTRLR   EQU     'R'-'@'
  0013+=         CTRLS   EQU     'S'-'@'         ;..XOFF..
  0018+=         CTRLX   EQU     'X'-'@'
  001A+=         CTRLZ   EQU     'Z'-'@'
  0008+=         BS      EQU     08H             ;..backspace..
  0009+=         TAB     EQU     09H             ;..tab..
  0000+          ;LF     EQU     0AH             ;..linefeed..
  0000+          ;FF     EQU     0CH             ;..formfeed..
  0000+          ;CR     EQU     0DH             ;..carriage return..
  0018+=         CAN     EQU     18H             ;..cancel..
  001A+=         EOF     EQU     1Ah             ;..End-of-file
  001A+=         EOFCHAR EQU     1AH             ;..end-of-file..
  001B+=         ESC     EQU     1BH             ;..escape character.
  0020+=         SPC     EQU     20H             ;..space
  0000+          
  0000+          ;----------------------------------------------
  0000+          ;for TCAP screen functions
  0000+          ;
  0001+=         DIM     EQU     1               ;for highlighting use
  0002+=         BRIGHT  EQU     2               ;opposite of dim
  001A+=         CL      EQU     CTRLZ           ;clear screen, home cursor
  0005+=         CRUP    EQU     CTRLE           ;cursor up
  0018+=         CRDN    EQU     CTRLX           ;cursor down
  0013+=         CURSL   EQU     CTRLS           ;cursor left
  0004+=         CURSR   EQU     CTRLD           ;cursor right
  0000+          
  0000+                  maclib  z3base.lib      ; Defines ZCPR system addresses
  0000+          ; Z3BASE - Dynamic Configuration
  0000+          ;
  0000+          ; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
  0000+          ; distribution and duplication permitted for non-commercial purposes only.
  0000+          ; Any commercial use of ZCPR33, defined as any situation where the duplicator
  0000+          ; recieves revenue by duplicating or distributing ZCPR33 by itself or in
  0000+          ; conjunction with any hardware or software product, is expressly prohibited
  0000+          ; unless authorized in writing by Echelon.
  0000+          ;
  0000+          ; This is a special version of Z3BASE, inspired by Joe Wright's Z3BASE
  0000+          ; for Z-Com.  All segment addresses are automatically derived when the
  0000+          ; CCP equate is set.  The benefit of this is that reconfiguration of the
  0000+          ; system after initial installation is greatly eased.
  0000+          ;
  0000+          ; Although this version of Z3BASE is being distributed with ZCPR 3.3, any
  0000+          ; previous version of Z3BASE can be used to assemble the Z33 Command
  0000+          ; Processor.  No new symbols are needed.  So, if you have an existing
  0000+          ; Z3BASE, go ahead and use it.
  0000+          ;
  0000+          ; Instructions:
  0000+          ;
  0000+          ; The user should first design the ZCPR3 memory usage using the chart
  0000+          ; below.  (Echelon recommends the chart be filled out, even though it is
  0000+          ; not read by the assembler, so that your system will be self-documenting.)
  0000+          ; Then set the CCP equate for the beginning address of ZCPR3.  Next, examine
  0000+          ; and change the SEGn equates which follow in the file to ensure that the
  0000+          ; system segments and buffers are placed at the proper addresses.
  0000+          ;
ZAS Relocating Macro Assembler (v3.05                             page    5
                                                            
                                                            

  0000+          ; This file has been customized for use with AMPRO hard disk systems.  The
  0000+          ; target configuration has support for hard disks up to 49 Meg, extended
  0000+          ; IOP support, and 28-entry NDR.
  0000+          ;
  0000+          ;****************************************************************
  0000+          ;*                                                              *
  0000+          ;*  Z3BASE.LIB -- Base Addresses for ZCPR 3.3/Z-System          *
  0000+          ;*                                                              *
  0000+          ;*      Segments:                                               *
  0000+          ;*                                                              *
  0000+          ;*      Segment         Function                                *
  0000+          ;*      -------         --------                                *
  0000+          ;*      ZSDOS           ZSDOS 1.1                               *
  0000+          ;*      CBIOSZ          ZDS BIOS with additional                *
  0000+          ;*                      ZCPR3 initialization routines           *
  0000+          ;*      ZCPR3           Echelon Z80 Command Processor           *
  0000+          ;*                      Replacement, Version 3.3 (ZCPR3)        *
  0000+          ;*      *.ENV           All Environment Descriptors             *
  0000+          ;*      *.FCP           All Flow Command Packages               *
  0000+          ;*      *.NDR           All Named Directory Definition Files    *
  0000+          ;*      *.RCP           All Resident Command Packages           *
  0000+          ;*      *.IOP           All Input/Output Packages               *
  0000+          ;*                                                              *
  0000+          ;*                                                              *
  0000+          ;* Memory Map of System (for CCP EQU 0BC00H):                   *
  0000+          ;*                                                              *
  0000+          ;*      Address Range     Size  Function                        *
  0000+          ;*      -------------   ------- --------                        *
  0000+          ;*          0 -   FF    256 b   Standard CP/M Buffers except    *
  0000+          ;*        100 - C2FF    ~48 K   Transient Program Area          *
  0000+          ;*       C200 - C9FF      2 K   ZCPR 3.3 Command Processor      *
  0000+          ;*       CA00 - D7FF    3.5 K   ZSDOS                           *
  0000+          ;*       D800 - E1FF    2.5 K   BIOS with disk buffers          *
  0000+          ;*       E200 - E9FF      2 K   Resident Command Package        *
  0000+          ;*       0000 - 0000    1.5 K   Input/Output Package            *
  0000+          ;*       EA00 - EBFF     .5 K   Flow Command Package            *
  0000+          ;*       EC00 - ECFF    256 b   Environment Descriptor          *
  0000+          ;*                              Bytes 00H-7FH:  Z3 Parameters   *
  0000+          ;*                              Bytes 80H-FFH:  Z3 TCAP         *
  0000+          ;*       ED00 - ED7F    128 b   ZCPR3 Shell Stack               *
  0000+          ;*       ED80 - EDCF     80 b   ZCPR3 Message Buffers           *
  0000+          ;*       EDD0 - EDF3     36 b   ZCPR3 External FCB              *
  0000+          ;*       EDF4 - EDFE     11 b   ZCPR3 External Path             *
  0000+          ;*       EDFF             1 b   Wheel Byte                      *
  0000+          ;*       EE00 - EEFF    256 B   Memory-Based Named Directory    *
  0000+          ;*       EF00 - EFCF    208 B   Multiple Command Line Buffer    *
  0000+          ;*       EFD0 - EFFF     48 b   ZCPR3 External Stack            *
  0000+          ;****************************************************************
  0000+          
  0000+          ; include       macro   filename
  0000+          ;
  0000+          ;        if     zas
  0000+          ;       .in             filename
  0000+          ;        else   ;slr assembler
  0000+          ;       include filename
  0000+          ;        endif  ;zas
ZAS Relocating Macro Assembler (v3.05                             page    6
                                                            
                                                            

  0000+          ;
  0000+          ;        endm
  0000+          
  0000+          ; FALSE equ     0
  0000+          ; TRUE  equ     NOT FALSE
  0000+          
  0021+=         Z3REV   EQU     33      ; ZCPR3 REV NUMBER
  0000+          ; MSIZE EQU     54      ; SIZE OF CPM SYSTEM
  0000+          
  0000+=         BASE    EQU     0
  0000+          
  0000+          ; CCP   EQU     0BC00H  ; ZCPR3 COMMAND PROCESSOR
  0000+          
  E200+=         SEG1    EQU     ZBUFBAS ; where the things starts
  0000+          
  0000+          ;
  0000+          ; RCP definition.  Set RCPS to 0 to eliminate RCP
  0000+          ;
  0000+          
  0010+=         RCPS    EQU     16              ; 16 128-byte Blocks (2K bytes)
  0000+          
  0000+                   IF     RCPS NE 0
  E200+=         RCP     EQU     SEG1            ; RESIDENT COMMAND PACKAGE
  0000+                   ELSE
  0000+          RCP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG2    EQU     SEG1+(RCPS*128)
  0000+          
  0000+          ;
  0000+          ; IOP definition.  Set IOPS to 0 to eliminate IOP
  0000+          ;
  0000+          ; IOPS  EQU     12              ; 12 128-byte Blocks (1.5K bytes)
  0000+=         IOPS    EQU     0               ; 12 128-byte Blocks (1.5K bytes)
  0000+          
  0000+                   IF     IOPS NE 0
  0000+          IOP     EQU     SEG2            ; REDIRECTABLE I/O PACKAGE
  0000+                   ELSE
  0000+=         IOP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG3    EQU     SEG2+(IOPS*128)
  0000+          
  0000+          ;
  0000+          ; FCP definition.  Set FCPS to 0 to eliminate FCP
  0000+          ;
  0000+          
  0004+=         FCPS    EQU     4       ; 4 128-byte Blocks (0.5K bytes)
  0000+          
  0000+                   IF     FCPS NE 0
  EA00+=         FCP     EQU     SEG3
  0000+                   ELSE
  0000+          FCP     EQU     0
  0000+                   ENDIF
  0000+          
  E838+=         ZDSSTPR EQU     (FCP-ZDSSTSZ)   ; Z80 Darkstar P2DOS Stamper
ZAS Relocating Macro Assembler (v3.05                             page    7
                                                            
                                                            

  011F+=         NWF12O  EQU     011FH
  0133+=         SETCHO  EQU     0133H
  013C+=         CKTDFO  EQU     013CH
  0000+          
  EC00+=         SEG10   EQU     SEG3+(FCPS*128)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Environment Descriptor is mandatory for ZCPR 3.3.
  0000+          ; Echelon recommends you work this out so that your ENV begins at address
  0000+          ; FE00h, but this is only a recommendation and not mandatory.
  0000+          ;
  0000+          
  EC00+=         Z3ENV   EQU     SEG10   ; ENVIRONMENT DESCRIPTORS
  0002+=         Z3ENVS  EQU     2       ; SIZE OF ENVIRONMENT DESCRIPTOR IN 128-BYTE BLOCKS
  0000+          
  ED00+=         SEG4    EQU     SEG10+(Z3ENVS*128)
  0000+          
  0000+          ;
  0000+          ; Shell Stack definition.  Set SHSTKS to 0 to eliminate Shell Stack
  0000+          ;
  0000+          
  0004+=         SHSTKS  EQU     4       ; NUMBER OF SHSIZE-BYTE SHELL STACK ENTRIES
  0020+=         SHSIZE  EQU     32      ; SIZE OF A SHELL STACK ENTRY
  0000+                                  ;   (STACK SIZE = SHSTKS * SHSIZE)
  0000+                   IF SHSTKS NE 0
  ED00+=         SHSTK   EQU     SEG4
  0000+                   ELSE
  0000+          SHSTK   EQU     0
  0000+                   ENDIF
  0000+          
  ED80+=         SEG5    EQU     SEG4+(SHSTKS*SHSIZE)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Message Buffers are mandatory for ZCPR 3.3.
  0000+          ;
  ED80+=         Z3MSG   EQU     SEG5            ; ZCPR3 MESSAGE BUFFER
  0000+          
  EDD0+=         SEG6    EQU     SEG5+80
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External FCB is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDD0+=         EXTFCB  EQU     SEG6            ; ZCPR3 EXTERNAL FCB
  0000+          
  EDF4+=         SEG7    EQU     SEG6+36
  0000+          
  0000+          ;
  0000+          ; The Path is mandatory for ZCPR 3.3.  No more than 5 path elements can be
  0000+          ; used with this Z3BASE.LIB file.
  0000+          ;
  0000+          
  EDF4+=         EXPATH  EQU     SEG7            ; EXTERNAL PATH
  0005+=         EXPATHS EQU     5               ; 5 2-byte Path Elements
  0000+                                          ;  (PATH SIZE = EXPATHS*2 + 1)
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page    8
                                                            
                                                            

  EDFF+=         SEG8    EQU     SEG7+(EXPATHS*2)+1
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Wheel Byte is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDFF+=         Z3WHL   EQU     SEG8            ; WHEEL BYTE ADDRESS
  0000+          
  EE00+=         SEG9    EQU     SEG8+1
  0000+          
  0000+          ;
  0000+          ; ZCPR3 Named Directory Buffer definition.  Set Z3NDIRS to 0 to eliminate
  0000+          ; the named directory buffer.  If Z3NDIRS is changed, also change the seg11
  0000+          ; equate below.
  0000+          ;
  001C+=         Z3NDIRS EQU     28              ; 28 18-byte Named Directory Elements permitted
  0000+                                          ;   (NDIR SIZE = Z3NDIRS*18 + 1 for trailing 0)
  0000+                   IF     Z3NDIRS NE 0
  EE00+=         Z3NDIR  EQU     SEG9            ; ZCPR3 NAMED DIRECTORY AREA
  0000+                   ELSE
  0000+          Z3NDIR  EQU     0
  0000+                   ENDIF
  0000+          
  EF00+=         SEG11   EQU     SEG9+256        ; add 512 for 28-entry NDR
  0000+                                          ; add 256 for 14-entry NDR ("standard")
  0000+                                          ; add 0 if Z3NDIRS is set to 0
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Command Line Buffer is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EF00+=         Z3CL    EQU     SEG11   ; ZCPR3 COMMAND LINE BUFFER
  00D0+=         Z3CLS   EQU     208     ; SIZE OF COMMAND LINE BUFFER
  0000+          
  EFD0+=         SEG12   EQU     SEG11+Z3CLS
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Stack is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EFD0+=         EXTSTK  EQU     SEG12   ; ZCPR3 EXTERNAL STACK
  0000+          
  0000+          ; end of Z3BASE.LIB
  0000+                  maclib  z33defn.lib     ; Defines offsets in Z33 command processor
  0000+          
  0000+          ; Definitions for offsets in ZCPR33 code
  0000+          
  0005+=         OFFVERS         EQU     5       ; Offset to version byte
  0006+=         OFFOPT          EQU     6       ; Offset to first option byte
  0010+=         OFFPARSE        EQU     16      ; Offset to entry point to REPARSE
  0016+=         OFFSCAN         EQU     22      ; Offset to entry point for SCAN
  0019+=         OFFCMD          EQU     25      ; Offset to command table
  0000+          
  0000+          ; Offset in message buffer for new data
  0000+          
  002F+=         OFFCDRV         EQU     2FH     ; Current drive
ZAS Relocating Macro Assembler (v3.05                             page    9
                                                            
                                                            

  002E+=         OFFCUSR         EQU     2EH
  002D+=         OFFSRUN         EQU     2DH     ; SUBMIT running flag
  002C+=         OFFXSUB         EQU     2CH     ; XSUB input redirection flag
  0000+          
  0000+          ; Bit positions and offsets within option bytes of various options
  0000+          
  0000+=         OBADDUECP       EQU     0
  0007+=         BBADDUECP       EQU     7
  0000+          
  0000+=         OROOTONLY       EQU     0
  0006+=         BROOTONLY       EQU     6
  0000+          
  0000+=         ONDRENV         EQU     0
  0005+=         BNDRENV         EQU     5
  0000+          
  0000+=         OFCPENV         EQU     0
  0004+=         BFCPENV         EQU     4
  0000+          
  0000+=         ORCPENV         EQU     0
  0003+=         BRCPENV         EQU     3
  0000+          
  0000+=         OINCLENV        EQU     0
  0002+=         BINCLENV        EQU     2
  0000+          
  0000+=         OADUENV         EQU     0
  0001+=         BADUENV         EQU     1
  0000+          
  0000+=         ODUENV          EQU     0
  0000+=         BDUENV          EQU     0
  0000+          
  0001+=         OHIGHUSER       EQU     1
  0007+=         BHIGHUSER       EQU     7
  0000+          
  0001+=         ODRVPREFIX      EQU     1
  0006+=         BDRVPREFIX      EQU     6
  0000+          
  0001+=         OSCANCUR        EQU     1
  0005+=         BSCANCUR        EQU     5
  0000+          
  0001+=         OINCLDIR        EQU     1
  0004+=         BINCLDIR        EQU     4
  0000+          
  0001+=         OINCLDU         EQU     1
  0003+=         BINCLDU         EQU     3
  0000+          
  0001+=         ODUFIRST        EQU     1
  0002+=         BDUFIRST        EQU     2
  0000+          
  0001+=         OACCPTDIR       EQU     1
  0001+=         BACCPTDIR       EQU     1
  0000+          
  0001+=         OACCPTDU        EQU     1
  0000+=         BACCPTDU        EQU     0
  0000+          
  0002+=         OPWCHECK                EQU     2
  0006+=         BPWCHECK                EQU     6
ZAS Relocating Macro Assembler (v3.05                             page   10
                                                            
                                                            

  0000+          
  0002+=         OPWNOECHO       EQU     2
  0005+=         BPWNOECHO       EQU     5
  0000+          
  0002+=         OWDU            EQU     2
  0004+=         BWDU            EQU     4
  0000+          
  0002+=         OWPASS          EQU     2
  0003+=         BWPASS          EQU     3
  0000+          
  0002+=         OWPREFIX        EQU     2
  0002+=         BWPREFIX        EQU     2
  0000+          
  0002+=         OFASTECP        EQU     2
  0001+=         BFASTECP        EQU     1
  0000+          
  0002+=         OSKIPPATH       EQU     2
  0000+=         BSKIPPATH       EQU     0
  0000+          
  0003+=         OSHELLIF        EQU     3
  0007+=         BSHELLIF        EQU     7
  0000+          
  0003+=         OATTSYS         EQU     3
  0006+=         BATTSYS         EQU     6
  0000+          
  0003+=         OATTDIR         EQU     3
  0005+=         BATTDIR         EQU     5
  0000+          
  0003+=         OATTCHK         EQU     3
  0004+=         BATTCHK         EQU     4
  0000+          
  0003+=         OSUBECHO        EQU     3
  0003+=         BSUBECHO        EQU     3
  0000+          
  0003+=         OSUBQUIET       EQU     3
  0002+=         BSUBQUIET       EQU     2
  0000+          
  0003+=         OSUBCLUE        EQU     3
  0001+=         BSUBCLUE        EQU     1
  0000+          
  0003+=         OSUBON          EQU     3
  0000+=         BSUBON          EQU     0
  0000+          
  0000+          
  0000+                  maclib  z33rcp.lib      ; Defines command options
  0000+          
  0000+          ; Z33RCP.LIB
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       M I S C E L A N E O U S    D E F I N I T I O N S
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0000+          ;zas    equ     true            ; Set TRUE for ZAS assembler, FALSE for
ZAS Relocating Macro Assembler (v3.05                             page   11
                                                            
                                                            

  0000+                                          ; SLR assemblers.  For other assemblers the
  0000+                                          ; code in Z33RCP.Z80 will have to be changed
  0000+                                          ; to eliminate include directives.
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       R C P    I D E N T I F I C A T I O N
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0041+=         rcpid   equ     'A'             ; Identifies option set selected
  0000+          
  0000+          idstring macro
  0000+                  db      'RCP'           ; Name of Z33RCP module
  0000+          ;       db      ' '
  0000+          ;       db      version + '0'   ; Main version number
  0000+          ;       db      '.'
  0000+          ;       db      subver + '0'    ; Subversion number
  0000+          ;       db      rcpid           ; User's ID character from Z33RCP.LIB
  0000+                  db      0               ; End of name string
  0000+                   endm
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       C O M M A N D S    I N C L U D E D
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  FFFF+=         CLSON   EQU     yes             ; CLS   clear screen
  0000+=         CPON    EQU     no              ; CP    copy file
  FFFF+=         DIRON   EQU     yes             ; DIR   disk directory
  0000+=         ECHOON  EQU     no              ; ECHO  send text to screen or printer
  FFFF+=         ERAON   EQU     yes             ; ERA   erase files
  FFFF+=         LTON    EQU     yes             ; TYPE  display file on console
  0000+=         LISTON  DEFL    no              ; LIST  send file to printer (if LTON also)
  0000+=         NOTEON  EQU     no              ; NOTE  command-line comment
  0000+=         PEEKON  EQU     no              ; PEEK  view memory
  0000+=         POKEON  EQU     no              ; POKE  set memory
  0000+=         PORTON  EQU     no              ; PORT  view and set I/O ports
  FFFF+=         PROTON  EQU     yes             ; PROT  set file attributes
  0000+=         REGON   EQU     no              ; REG   set and display user registers
  0000+=         RENON   EQU     no              ; REN   rename files
  FFFF+=         RESON   EQU     yes             ; R     reset disk system
  FFFF+=         SPACEON EQU     yes             ; SP    show space remaining on disk
  0000+=         TSTON   EQU     no              ; TST   test for program error
  FFFF+=         WHLON   EQU     yes             ; WHL   set of clear wheel status
  0000+=         WHLQON  EQU     no              ; WHLQ  wheel query (if WHLON)
  FFFF+=         ZDSSON  EQU     yes             ; ZDS Date Stamper (included if we have space...)
  0000+          
  0000+=         liston  defl    liston and lton ; LIST allowed only if TYPE is enabled
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       W H E E L    R E S T R I C T I O N S
ZAS Relocating Macro Assembler (v3.05                             page   12
                                                            
                                                            

  0000+          ;
  0000+          ;=============================================================================
  0000+          
  FFFF+=         wcp     equ     yes             ; CP
  0000+=         wdir    equ     no              ; DIR
  FFFF+=         wera    equ     yes             ; ERA
  FFFF+=         wlist   equ     yes             ; LIST
  FFFF+=         wpeek   equ     yes             ; PEEK
  FFFF+=         wpoke   equ     yes             ; POKE
  FFFF+=         wport   equ     yes             ; PORT
  FFFF+=         wprot   equ     yes             ; PROT
  FFFF+=         wreg    equ     yes             ; REG
  FFFF+=         wren    equ     yes             ; REN
  FFFF+=         wtype   equ     yes             ; TYPE
  0000+=         whrc    equ     no              ; H
  0000+=         wwhlq   equ     no              ; WHLQ
  0000+          
  FFFF+=         wheel   defl    wcp or wdir or wera or wlist or wpeek or wpoke or wport
  FFFF+=         wheel   defl    wheel or wprot or wreg or wren or wtype or whrc or wwhlq
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       C O M M A N D     O P T I O N S
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0000+          
  0000+          ; 'H' command
  0000+          
  0000+          ; This command displays a list of the resident commands implemented in the
  0000+          ; system.  FCP, CPR, and RCP commands can be displayed.  The basic command is
  0000+          ; not optional; it is always included.
  0000+          
  FFFF+=         listcpr         equ     yes     ; Include list of CPR-resident commands in
  0000+                                          ; display (highly recommended)
  0000+          
  FFFF+=         listfcp         equ     yes     ; Include list of FCP-resident commands in
  0000+                                          ; display (recommended if there is room)
  0000+          
  FFFF+=         noshow          equ     yes     ; Suppress listing commands that are wheel-
  0000+                                          ; restricted unless wheel byte is set (i.e.,
  0000+                                          ; don't show commands that won't run)
  0000+          
  0005+=         cmdsline        equ     5       ; Number of commands on each line of display
  0000+          
  0008+=         cmdspace        equ     8       ; Space in display for each command name
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'CLR' command
  0000+          
  0000+          ; This command clears the console screen.  It can either use a fixed string
  0000+          ; (for shorter code if the same terminal is always used) or use the TCAP
  0000+          ; entry for automatic adaptation to any terminal.
ZAS Relocating Macro Assembler (v3.05                             page   13
                                                            
                                                            

  0000+          
  FFFF+=         CLSTCAP         EQU     TRUE    ; Use TCAP for clear-screen string
  0000+          
  0000+          ; If CLSTCAP is not enabled, then the string below must be provided and
  0000+          ; it must end with a character with the high bit set
  0000+          
  0000+                   if     not clstcap
  0000+          clsstr   macro
  0000+                  db      'Z'-'@'+80h      ; Control-Z to clear screen
  0000+                   endm
  0000+                   endif  ;not clstcap
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'CP' command
  0000+          
  0000+          ; This command copies a single file.  The destination file can have a different
  0000+          ; name from the source file.  Set the size of the memory buffer in K below (do
  0000+          ; not change the second definition).  The copy buffer is placed at the top of
  0000+          ; the TPA, where it will generally not interfere with subsequent use of the GO
  0000+          ; command to rerun a program loaded in the TPA.
  0000+          
  0010+=         cpblocks        defl    16              ; Size of copy buffer in K
  0000+          
  0080+=         cpblocks        defl    cpblocks * 8    ; Convert to number of records
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'DIR' command
  0000+          
  0000+          ; This command displays a sorted listing of the files in a directory.  The
  0000+          ; file name buffer is allocated at the top of the TPA so as not to modify
  0000+          ; any program loaded in low memory.  Consequently, the size of the buffer
  0000+          ; must be set in advance.
  0000+          
  0100+=         maxdirs         equ     256     ; Maximum number of names in directory buffer
  0000+          
  FFFF+=         nosys           equ     yes     ; suppress 'A' and 'S' options if wheel off
  0000+          
  FFFF+=         slashchk        equ     yes     ; allow "DIR /S" or "DIR /A" formats (costs
  0000+                                          ; about 12 bytes)
  0000+          
  0041+=         allflag         equ     'A'     ; Option character for showing
  0000+                                          ; all file (both SYS and DIR)
  0053+=         sysflag         equ     'S'     ; Option character for showing
  0000+                                          ; SYS files only
  FFFF+=         sortnt          equ     yes     ; Sort file by name then type
  FFFF+=         wide            equ     yes     ; Make display for 80-column screen
  007C+=         fence           equ     '|'     ; Character to use as fence between columns
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'ECHO' command
ZAS Relocating Macro Assembler (v3.05                             page   14
                                                            
                                                            

  0000+          
  0000+          ; This command sends characters to the console or list device.  If ECHOLST is
  0000+          ; enabled, then code is included for sending characters to the LST device.
  0000+          ; Characters normally go the the console device and are normally upper or lower
  0000+          ; case depending on the setting of UPCASE.  The command line can have special
  0000+          ; command sequences to toggle the case of the output and to change the
  0000+          ; destination between the console and printer.  Any other character following
  0000+          ; the command character will be sent as is.  For the normal setting of the
  0000+          ; equates below (upcase/yes, cmdchar/%, prtchar/P, crtchar/C, lcasech/>,
  0000+          ; and ucasech/<) an example command line would be:
  0000+          ;       A0:ROOT>ECHO T%>HIS IS A TEST^M^J^IDONE%PONE, TWO, %<THREE
  0000+          ; The following text would be echoed to the console (inlcuding carriage return,
  0000+          ; linefeed, and tab characters, '|' indicates the left margin):
  0000+          ;       |This is a test
  0000+          ;       |       done
  0000+          ; The string "one, two, THREE" would be sent to the printer.
  0000+          
  0000+=         echolst         equ     no      ; Allow sending characters to LST device
  0000+          
  FFFF+=         upcase          equ     yes     ; Initial case of output
  0000+          
  0025+=         cmdchar         equ     '%'     ; Character to flag case change
  0000+          
  0050+=         prtchar         equ     'P'     ; Character to start sending output to
  0000+                                          ; the printer (must be upper case)
  0043+=         crtchar         equ     'C'     ; Character to start sending output to
  0000+                                          ; the CRT (must be upper case)
  003C+=         ucasechar       equ     '<'     ; Character after CASECHAR that toggles
  0000+                                          ; subsequent output to upper case
  003E+=         lcasechar       equ     '>'     ; Character after CASECHAR that toggles
  0000+                                          ; subsequent output to lower case
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'LIST' and 'TYPE' commands
  0000+          
  FFFF+=         pgdflt          equ     yes     ; Default to paging of console output
  0000+          
  0050+=         pgdflg          equ     'P'     ; Character to toggle paging status
  0000+          
  0000+          ;++++++++++ following value should be obtained from ENV
  0000+          
  0018+=         nlines          equ     24      ; Number of lines on console screen
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; PEEK COMMAND
  0000+          
  FFFF+=         peekhdr equ     yes             ; If yes, label the columns in the display with
  0000+                                          ; the low hex digit of the address
  0000+          
  FFFF+=         peekbdr equ     yes             ; If yes, include a line of hyphens under the
  0000+                                          ; column headers
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   15
                                                            
                                                            

  FFFF+=         peekchk equ     yes             ; If yes, the ending address will be tested to
  0000+                                          ; prevent overflow past FFFF (costs 5 bytes)
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; POKE COMMAND
  0000+          
  FFFF+=         POKEQ   EQU     TRUE            ;SET TRUE TO SUPPRESS CONSOLE MESSAGE TO SAVE
  0000+                                          ;CODE AND/OR IMPROVE SECURITY
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Register command
  0000+          
  FFFF+=         SETERR          EQU     TRUE    ;copy new reg value to pgm error flag
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; DISK RESET COMMAND
  0000+          
  FFFF+=         RESMSG          EQU     TRUE    ;print disk reset message
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; DISK SPACE COMMAND
  0000+          
  FFFF+=         DIRSP           EQU     TRUE    ;show space after dir
  FFFF+=         erasp           equ     true    ;show space after era
  FFFF+=         CPSP            EQU     TRUE    ;show space after cp
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; ERROR TESTING COMMAND
  0000+          
  FFFF+=         TESTM80         EQU     TRUE
  0000+=         TESTF80         EQU     FALSE
  0000+          
  0000+          ; Equates for addresses where error counts are kept by the programs to be
  0000+          ; tested for M80/F80, version 3.44
  0000+          
  0000+                   if     testm80
  3CED+=         m80f    equ     03cedh          ; Addr of word with fatal error count (m80)
  3CEF+=         m80w    equ     03cefh          ; Addr of word with warning error count (m80)
  0000+                   endif  ;testm80
  0000+          
  0000+                   if     testf80
  0000+          f80f    equ     001c1h          ; Addr of word with fatal error count (f80)
  0000+          f80w    equ     002adh          ; Addr of word with warning error count (f80)
  0000+                   endif  ;testf80
  0000+          
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   16
                                                            
                                                            

  0000+          ;----------------------------------------
  0000+          
  0000+          ; Wheel commands
  0000+          
  0000+=         whlquiet        equ     no      ; If yes, don't report wheel state with WHL cmd
  0000+          
  0000+          WPASS           MACRO
  0000+                          DB      'SYSTEM  '
  0000+                          ENDM
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command dispatch table
  0000+          
  0004+=         cmdsize equ     4               ; Length of each command name
  0000+          
  0000+          ;++++++++++ delete next line after changing Z33 and Z33MAC.LIB
  0000+          
  0004+=         nchars  equ     cmdsize
  0000+          
  0000+          cmdtbl  macro
  0000+                  command CLS,    clson,  false,  cls
  0000+                  command CP,     cpon,   wcp,    copy
  0000+                  command DIR,    diron,  wdir,   dir
  0000+                  command ECHO,   echoon, false,  echo
  0000+                  command ERA,    eraon,  wera,   era
  0000+                  command H,      true,   whrc,   clist
  0000+                  command LIST,   liston, wlist,  list
  0000+                  command NOTE,   noteon, false,  note
  0000+                  command P,      peekon, wpeek,  peek
  0000+                  command POKE,   pokeon, wpoke,  poke
  0000+                  command PORT,   porton, wport,  port
  0000+                  command PROT,   proton, wprot,  att
  0000+                  command R,      reson,  false,  reset
  0000+                  command REG,    regon,  wreg,   register
  0000+                  command REN,    renon,  wren,   ren
  0000+                  command SP,     spaceon,false,  space
  0000+                  command TST,    tston,  false,  testerr
  0000+                  command TYPE,   lton,   wtype,  type
  0000+                  command WHL,    whlon,  false,  whl
  0000+                  command WHLQ,   whlqon, wwhlq,  whlmsg
  0000+          
  0000+                   endm
  0000+          
  0000+                  maclib  z33mac.lib      ; Macros
  0000+          
  0000+          ; Z33MAC.LIB : Macros for use with ZCPR33
  0000+          
  0000+          ; General purpose macros
  0000+          
  0000+          PUTREG   MACRO
  0000+                  PUSH    HL              ; Save registers in order
  0000+                  PUSH    DE
  0000+                  PUSH    BC
  0000+                   ENDM
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   17
                                                            
                                                            

  0000+          GETREG   MACRO
  0000+                  POP     BC              ; Restore registers in order
  0000+                  POP     DE
  0000+                  POP     HL
  0000+                   ENDM
  0000+          
  0000+          SWAP     MACRO
  0000+                  RRCA                    ; Exchange nibbles
  0000+                  RRCA
  0000+                  RRCA
  0000+                  RRCA
  0000+                   ENDM
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for forming option bytes
  0000+          
  0000+          ; This macro generates a byte with bits corresponding to up to 8 option
  0000+          ; flags.  The bits are filled in the order of the parameters and are right
  0000+          ; justified in the byte.
  0000+          
  0000+          OPTFLAG MACRO   F1,F2,F3,F4,F5,F6,F7,F8
  0000+          
  0000+          FLAG    DEFL    0               ;; initial value
  0000+          
  0000+                  IRP     TEMP,<F1,F2,F3,F4,F5,F6,F7,F8>
  0000+          
  0000+                   IF     NOT NUL TEMP
  0000+          FLAG    DEFL    FLAG SHL 1
  0000+                   IF     TEMP
  0000+          FLAG    DEFL    FLAG OR 1
  0000+                   ENDIF  ;;temp
  0000+                   ENDIF  ;;not nul temp
  0000+          
  0000+                   ENDM                   ;; irp
  0000+          
  0000+                  DEFB    LOW FLAG
  0000+          
  0000+                   ENDM                   ;; optflag
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for directory scanning
  0000+          
  0000+          ; This macro resolves the command token for possible directory references.
  0000+          ; FORM1 and FORM2 can each be either "DU" or "DIR".  FORM2 can also be null.
  0000+          ; The two forms are scanned for in the indicated order.
  0000+          
  0000+          ; This macro preserves the pointer to the FCB in DE and to the next
  0000+          ; character in the line in HL.  On return, the FCB pointer has been restored,
  0000+          ; and the command string pointer is still on the stack.  The routines DUSCAN
  0000+          ; and DIRSCAN are called as needed.
  0000+          
  0000+          RESOLVE MACRO   FORM1,FORM2
  0000+          
  0000+                  LOCAL   RESOLVED
ZAS Relocating Macro Assembler (v3.05                             page   18
                                                            
                                                            

  0000+          
  0000+                  PUSH    HL              ; Save pointer to command string
  0000+                  PUSH    DE              ; Save pointer to FCB
  0000+                  CALL    FORM1&SCAN      ; Scan for the first directory form
  0000+          
  0000+                   IF     NOT NUL FORM2
  0000+          
  0000+                  JR      Z,GOTIT         ; Resolved successfully, so jump ahead
  0000+          
  0000+                  POP     DE              ; Restore pointers for use by second call
  0000+                  POP     HL
  0000+                  PUSH    HL              ; Save them again
  0000+                  PUSH    DE
  0000+                  CALL    FORM2&SCAN      ; Scan for the second directory form
  0000+          
  0000+                   ENDIF  ;not nul form2
  0000+          
  0000+          GOTIT:
  0000+                  POP     DE              ; Restore pointer to FCB
  0000+          
  0000+                   ENDM   ;resolve
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command table entry definition macro
  0000+          
  0000+          ; Macro to form an entry for one command in the table.  The first parameter is
  0000+          ; the name to be used for the command (no quotes); the second parameter is the
  0000+          ; flag that indicates whether or not the command is to be enabled; the third
  0000+          ; parameter is the wheel control flag; and the last parameter is the jump
  0000+          ; address to the code that carries out the command.  The command names are
  0000+          ; automatically padded out to the correct length (they will be truncated and
  0000+          ; an error message will result if a command name is too long).  The characters
  0000+          ; in the command name are automatically converted to upper case.
  0000+          
  0000+          COMMAND MACRO CMDNAME,ENABLEFLAG,WHEELFLAG,ADDRESS
  0000+          
  0000+                   IF     ENABLEFLAG      ;; Generate command only if enabled
  0000+          
  0000+          WHLMASK DEFL    WHEELFLAG       ;; Initialize variables
  0000+          COUNT   DEFL    CMDSIZE         ;; Initialize to size of each command name
  0000+          
  0000+                  IRPC    CHAR,CMDNAME    ;; Repeat over letters in command name
  0000+          
  0000+          COUNT   DEFL    COUNT - 1       ;; Count down characters in name
  0000+          
  0000+                   IF     [ COUNT LT CMDSIZE ]
  0000+          
  0000+                          ;; If character is lower case, convert to upper case
  0000+          
  0000+                   IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ] + 80H
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ]
ZAS Relocating Macro Assembler (v3.05                             page   19
                                                            
                                                            

  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ELSE   ;;NOT LOWER CASE
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    '&CHAR' + 80H   ;; IF CONTROLLED BY WHEEL, SET HIGH BIT
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    '&CHAR'         ;; IF NOT RESTRICTED, LEAVE HIGH BIT CLEAR
  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ENDIF  ;;LOWER CASE
  0000+          
  0000+                   ENDIF  ;;[ COUNT LT CMDSIZE ]
  0000+          
  0000+          WHLMASK DEFL    FALSE           ;; TURN OFF HIGH-BIT SETTING AFTER FIRST CHAR
  0000+          
  0000+                  ENDM    ;IRPC
  0000+          
  0000+                          ;; PAD COMMAND NAME WITH BLANKS
  0000+          
  0000+                   IF     [ COUNT GT CMDSIZE ]    ;; IF WE UNDERFLOWED
  0000+                  *** COMMAND NAME "&CMDNAME" IS TOO LONG / TRUNCATED ***
  0000+                   ELSE
  0000+                  REPT    COUNT
  0000+                  DEFB    ' '
  0000+                  ENDM
  0000+                   ENDIF  ;[ COUNT GT CMDSIZE ]
  0000+          
  0000+                  DW      ADDRESS         ;; DISPATCH ADDRESS FOR COMMAND
  0000+          
  0000+                   ENDIF  ;ENABLE
  0000+          
  0000+                  ENDM    ;COMMAND
  0000+          
  0000+          ; End Z33MAC.LIB
  0000+          
  0000+          
  0000           
  0000           ; Macro to define include directives for either ZAS or SLR assemblers.  For
  0000           ; other assemblers that do support file inclusion, modify the macro to specify
  0000           ; the correct directive.  For assemblers that do not support file inclusion,
  0000           ; a text editor will have to be used to read in the actual contents of each
  0000           ; file in place of the include statement.
  0000           
  0000           include macro   filename
  0000           
  0000                    if     zas
  0000                   .in             filename
  0000                    else   ;slr assembler
  0000                   $include        filename&.lib
  0000                    endif  ;zas
  0000           
  0000                    endm
  0000           
  0000           ;=============================================================================
  0000           ;
ZAS Relocating Macro Assembler (v3.05                             page   20
                                                            
                                                            

  0000           ;       E N T R Y    C O D E    S E C T I O N
  0000           ;
  0000           ;=============================================================================
  0000           
  E200                   org     rcp             ; From Z3BASE.LIB
  E200           
  E200 5A33524350        db      'Z3RCP'         ; Package ID
  E205           
  E205           
  E205           ;----------------------------------------
  E205           
  E205           ; Command table
  E205           
  E205 04                db      cmdsize         ; Length of each command name
  E206                   cmdtbl                  ; Dispatch table from Z33RCP.LIB
  E206                   command CLS,    clson,  false,  cls
  E206           
  E206                    IF     clson
  E206           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E206           
  E206                   IRPC    CHAR,CLS
  E206           
  E206           COUNT   DEFL    COUNT - 1
  E206           
  E206                    IF     [ COUNT LT CMDSIZE ]
  E206           
  E206           
  E206                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E206                    ELSE
  E206                   DEFB    [ '&CHAR' AND 5FH ]
  E206                    ENDIF
  E206           
  E206                    ELSE
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    '&CHAR' + 80H
  E206                    ELSE
  E206                   DEFB    '&CHAR'
  E206                    ENDIF
  E206           
  E206                    ENDIF
  E206           
  E206                    ENDIF
  E206           
  E206           WHLMASK DEFL    FALSE
  E206           
  E206                   ENDM    ;IRPC
  E206           
  0003 =         COUNT   DEFL    COUNT - 1
  E206           
  E206                    IF     [ COUNT LT CMDSIZE ]
ZAS Relocating Macro Assembler (v3.05                             page   21
                                                            
                                                            

  E206           
  E206           
  E206                    IF     [ 'C' GE 'a' ] AND [ 'C' LE 'z' ]
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    [ 'C' AND 5FH ] + 80H
  E206                    ELSE
  E206                   DEFB    [ 'C' AND 5FH ]
  E206                    ENDIF
  E206           
  E206                    ELSE
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    'C' + 80H
  E206                    ELSE
  E206 43                DEFB    'C'
  E207                    ENDIF
  E207           
  E207                    ENDIF
  E207           
  E207                    ENDIF
  E207           
  0000 =         WHLMASK DEFL    FALSE
  E207           
  E207           
  0002 =         COUNT   DEFL    COUNT - 1
  E207           
  E207                    IF     [ COUNT LT CMDSIZE ]
  E207           
  E207           
  E207                    IF     [ 'L' GE 'a' ] AND [ 'L' LE 'z' ]
  E207           
  E207                    IF     WHLMASK
  E207                   DEFB    [ 'L' AND 5FH ] + 80H
  E207                    ELSE
  E207                   DEFB    [ 'L' AND 5FH ]
  E207                    ENDIF
  E207           
  E207                    ELSE
  E207           
  E207                    IF     WHLMASK
  E207                   DEFB    'L' + 80H
  E207                    ELSE
  E207 4C                DEFB    'L'
  E208                    ENDIF
  E208           
  E208                    ENDIF
  E208           
  E208                    ENDIF
  E208           
  0000 =         WHLMASK DEFL    FALSE
  E208           
  E208           
  0001 =         COUNT   DEFL    COUNT - 1
  E208           
  E208                    IF     [ COUNT LT CMDSIZE ]
ZAS Relocating Macro Assembler (v3.05                             page   22
                                                            
                                                            

  E208           
  E208           
  E208                    IF     [ 'S' GE 'a' ] AND [ 'S' LE 'z' ]
  E208           
  E208                    IF     WHLMASK
  E208                   DEFB    [ 'S' AND 5FH ] + 80H
  E208                    ELSE
  E208                   DEFB    [ 'S' AND 5FH ]
  E208                    ENDIF
  E208           
  E208                    ELSE
  E208           
  E208                    IF     WHLMASK
  E208                   DEFB    'S' + 80H
  E208                    ELSE
  E208 53                DEFB    'S'
  E209                    ENDIF
  E209           
  E209                    ENDIF
  E209           
  E209                    ENDIF
  E209           
  0000 =         WHLMASK DEFL    FALSE
  E209           
  E209                   ENDM    ;IRPC
  E209           
  E209           
  E209                    IF     [ COUNT GT CMDSIZE ]
  E209                   *** COMMAND NAME "CLS" IS TOO LONG / TRUNCATED ***
  E209                    ELSE
  E209                   REPT    COUNT
  E209                   DEFB    ' '
  E209                   ENDM
  E209 20                DEFB    ' '
  E20A                   ENDM
  E20A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E20A           
  E20A AEE2              DW      cls
  E20C           
  E20C                    ENDIF  ;ENABLE
  E20C           
  E20C                   ENDM    ;COMMAND
  E20C                   command CP,     cpon,   wcp,    copy
  E20C           
  E20C                    IF     cpon
  E20C           
  E20C           WHLMASK DEFL    wcp
  E20C           COUNT   DEFL    CMDSIZE
  E20C           
  E20C                   IRPC    CHAR,CP
  E20C           
  E20C           COUNT   DEFL    COUNT - 1
  E20C           
  E20C                    IF     [ COUNT LT CMDSIZE ]
  E20C           
  E20C           
ZAS Relocating Macro Assembler (v3.05                             page   23
                                                            
                                                            

  E20C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E20C                    ELSE
  E20C                   DEFB    [ '&CHAR' AND 5FH ]
  E20C                    ENDIF
  E20C           
  E20C                    ELSE
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    '&CHAR' + 80H
  E20C                    ELSE
  E20C                   DEFB    '&CHAR'
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C           WHLMASK DEFL    FALSE
  E20C           
  E20C                   ENDM    ;IRPC
  E20C           
  E20C           
  E20C                    IF     [ COUNT GT CMDSIZE ]
  E20C                   *** COMMAND NAME "CP" IS TOO LONG / TRUNCATED ***
  E20C                    ELSE
  E20C                   REPT    COUNT
  E20C                   DEFB    ' '
  E20C                   ENDM
  E20C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E20C           
  E20C                   DW      copy
  E20C           
  E20C                    ENDIF  ;ENABLE
  E20C           
  E20C                   ENDM    ;COMMAND
  E20C                   command DIR,    diron,  wdir,   dir
  E20C           
  E20C                    IF     diron
  E20C           
  0000 =         WHLMASK DEFL    wdir
  0004 =         COUNT   DEFL    CMDSIZE
  E20C           
  E20C                   IRPC    CHAR,DIR
  E20C           
  E20C           COUNT   DEFL    COUNT - 1
  E20C           
  E20C                    IF     [ COUNT LT CMDSIZE ]
  E20C           
  E20C           
  E20C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
ZAS Relocating Macro Assembler (v3.05                             page   24
                                                            
                                                            

  E20C                    ELSE
  E20C                   DEFB    [ '&CHAR' AND 5FH ]
  E20C                    ENDIF
  E20C           
  E20C                    ELSE
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    '&CHAR' + 80H
  E20C                    ELSE
  E20C                   DEFB    '&CHAR'
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C           WHLMASK DEFL    FALSE
  E20C           
  E20C                   ENDM    ;IRPC
  E20C           
  0003 =         COUNT   DEFL    COUNT - 1
  E20C           
  E20C                    IF     [ COUNT LT CMDSIZE ]
  E20C           
  E20C           
  E20C                    IF     [ 'D' GE 'a' ] AND [ 'D' LE 'z' ]
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    [ 'D' AND 5FH ] + 80H
  E20C                    ELSE
  E20C                   DEFB    [ 'D' AND 5FH ]
  E20C                    ENDIF
  E20C           
  E20C                    ELSE
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    'D' + 80H
  E20C                    ELSE
  E20C 44                DEFB    'D'
  E20D                    ENDIF
  E20D           
  E20D                    ENDIF
  E20D           
  E20D                    ENDIF
  E20D           
  0000 =         WHLMASK DEFL    FALSE
  E20D           
  E20D           
  0002 =         COUNT   DEFL    COUNT - 1
  E20D           
  E20D                    IF     [ COUNT LT CMDSIZE ]
  E20D           
  E20D           
  E20D                    IF     [ 'I' GE 'a' ] AND [ 'I' LE 'z' ]
  E20D           
  E20D                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   25
                                                            
                                                            

  E20D                   DEFB    [ 'I' AND 5FH ] + 80H
  E20D                    ELSE
  E20D                   DEFB    [ 'I' AND 5FH ]
  E20D                    ENDIF
  E20D           
  E20D                    ELSE
  E20D           
  E20D                    IF     WHLMASK
  E20D                   DEFB    'I' + 80H
  E20D                    ELSE
  E20D 49                DEFB    'I'
  E20E                    ENDIF
  E20E           
  E20E                    ENDIF
  E20E           
  E20E                    ENDIF
  E20E           
  0000 =         WHLMASK DEFL    FALSE
  E20E           
  E20E           
  0001 =         COUNT   DEFL    COUNT - 1
  E20E           
  E20E                    IF     [ COUNT LT CMDSIZE ]
  E20E           
  E20E           
  E20E                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E20E           
  E20E                    IF     WHLMASK
  E20E                   DEFB    [ 'R' AND 5FH ] + 80H
  E20E                    ELSE
  E20E                   DEFB    [ 'R' AND 5FH ]
  E20E                    ENDIF
  E20E           
  E20E                    ELSE
  E20E           
  E20E                    IF     WHLMASK
  E20E                   DEFB    'R' + 80H
  E20E                    ELSE
  E20E 52                DEFB    'R'
  E20F                    ENDIF
  E20F           
  E20F                    ENDIF
  E20F           
  E20F                    ENDIF
  E20F           
  0000 =         WHLMASK DEFL    FALSE
  E20F           
  E20F                   ENDM    ;IRPC
  E20F           
  E20F           
  E20F                    IF     [ COUNT GT CMDSIZE ]
  E20F                   *** COMMAND NAME "DIR" IS TOO LONG / TRUNCATED ***
  E20F                    ELSE
  E20F                   REPT    COUNT
  E20F                   DEFB    ' '
  E20F                   ENDM
ZAS Relocating Macro Assembler (v3.05                             page   26
                                                            
                                                            

  E20F 20                DEFB    ' '
  E210                   ENDM
  E210                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E210           
  E210 55E3              DW      dir
  E212           
  E212                    ENDIF  ;ENABLE
  E212           
  E212                   ENDM    ;COMMAND
  E212                   command ECHO,   echoon, false,  echo
  E212           
  E212                    IF     echoon
  E212           
  E212           WHLMASK DEFL    false
  E212           COUNT   DEFL    CMDSIZE
  E212           
  E212                   IRPC    CHAR,ECHO
  E212           
  E212           COUNT   DEFL    COUNT - 1
  E212           
  E212                    IF     [ COUNT LT CMDSIZE ]
  E212           
  E212           
  E212                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E212                    ELSE
  E212                   DEFB    [ '&CHAR' AND 5FH ]
  E212                    ENDIF
  E212           
  E212                    ELSE
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    '&CHAR' + 80H
  E212                    ELSE
  E212                   DEFB    '&CHAR'
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212           WHLMASK DEFL    FALSE
  E212           
  E212                   ENDM    ;IRPC
  E212           
  E212           
  E212                    IF     [ COUNT GT CMDSIZE ]
  E212                   *** COMMAND NAME "ECHO" IS TOO LONG / TRUNCATED ***
  E212                    ELSE
  E212                   REPT    COUNT
  E212                   DEFB    ' '
  E212                   ENDM
  E212                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E212           
ZAS Relocating Macro Assembler (v3.05                             page   27
                                                            
                                                            

  E212                   DW      echo
  E212           
  E212                    ENDIF  ;ENABLE
  E212           
  E212                   ENDM    ;COMMAND
  E212                   command ERA,    eraon,  wera,   era
  E212           
  E212                    IF     eraon
  E212           
  FFFF =         WHLMASK DEFL    wera
  0004 =         COUNT   DEFL    CMDSIZE
  E212           
  E212                   IRPC    CHAR,ERA
  E212           
  E212           COUNT   DEFL    COUNT - 1
  E212           
  E212                    IF     [ COUNT LT CMDSIZE ]
  E212           
  E212           
  E212                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E212                    ELSE
  E212                   DEFB    [ '&CHAR' AND 5FH ]
  E212                    ENDIF
  E212           
  E212                    ELSE
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    '&CHAR' + 80H
  E212                    ELSE
  E212                   DEFB    '&CHAR'
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212           WHLMASK DEFL    FALSE
  E212           
  E212                   ENDM    ;IRPC
  E212           
  0003 =         COUNT   DEFL    COUNT - 1
  E212           
  E212                    IF     [ COUNT LT CMDSIZE ]
  E212           
  E212           
  E212                    IF     [ 'E' GE 'a' ] AND [ 'E' LE 'z' ]
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    [ 'E' AND 5FH ] + 80H
  E212                    ELSE
  E212                   DEFB    [ 'E' AND 5FH ]
  E212                    ENDIF
  E212           
ZAS Relocating Macro Assembler (v3.05                             page   28
                                                            
                                                            

  E212                    ELSE
  E212           
  E212                    IF     WHLMASK
  E212 C5                DEFB    'E' + 80H
  E213                    ELSE
  E213                   DEFB    'E'
  E213                    ENDIF
  E213           
  E213                    ENDIF
  E213           
  E213                    ENDIF
  E213           
  0000 =         WHLMASK DEFL    FALSE
  E213           
  E213           
  0002 =         COUNT   DEFL    COUNT - 1
  E213           
  E213                    IF     [ COUNT LT CMDSIZE ]
  E213           
  E213           
  E213                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E213           
  E213                    IF     WHLMASK
  E213                   DEFB    [ 'R' AND 5FH ] + 80H
  E213                    ELSE
  E213                   DEFB    [ 'R' AND 5FH ]
  E213                    ENDIF
  E213           
  E213                    ELSE
  E213           
  E213                    IF     WHLMASK
  E213                   DEFB    'R' + 80H
  E213                    ELSE
  E213 52                DEFB    'R'
  E214                    ENDIF
  E214           
  E214                    ENDIF
  E214           
  E214                    ENDIF
  E214           
  0000 =         WHLMASK DEFL    FALSE
  E214           
  E214           
  0001 =         COUNT   DEFL    COUNT - 1
  E214           
  E214                    IF     [ COUNT LT CMDSIZE ]
  E214           
  E214           
  E214                    IF     [ 'A' GE 'a' ] AND [ 'A' LE 'z' ]
  E214           
  E214                    IF     WHLMASK
  E214                   DEFB    [ 'A' AND 5FH ] + 80H
  E214                    ELSE
  E214                   DEFB    [ 'A' AND 5FH ]
  E214                    ENDIF
  E214           
ZAS Relocating Macro Assembler (v3.05                             page   29
                                                            
                                                            

  E214                    ELSE
  E214           
  E214                    IF     WHLMASK
  E214                   DEFB    'A' + 80H
  E214                    ELSE
  E214 41                DEFB    'A'
  E215                    ENDIF
  E215           
  E215                    ENDIF
  E215           
  E215                    ENDIF
  E215           
  0000 =         WHLMASK DEFL    FALSE
  E215           
  E215                   ENDM    ;IRPC
  E215           
  E215           
  E215                    IF     [ COUNT GT CMDSIZE ]
  E215                   *** COMMAND NAME "ERA" IS TOO LONG / TRUNCATED ***
  E215                    ELSE
  E215                   REPT    COUNT
  E215                   DEFB    ' '
  E215                   ENDM
  E215 20                DEFB    ' '
  E216                   ENDM
  E216                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E216           
  E216 B3E3              DW      era
  E218           
  E218                    ENDIF  ;ENABLE
  E218           
  E218                   ENDM    ;COMMAND
  E218                   command H,      true,   whrc,   clist
  E218           
  E218                    IF     true
  E218           
  0000 =         WHLMASK DEFL    whrc
  0004 =         COUNT   DEFL    CMDSIZE
  E218           
  E218                   IRPC    CHAR,H
  E218           
  E218           COUNT   DEFL    COUNT - 1
  E218           
  E218                    IF     [ COUNT LT CMDSIZE ]
  E218           
  E218           
  E218                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E218           
  E218                    IF     WHLMASK
  E218                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E218                    ELSE
  E218                   DEFB    [ '&CHAR' AND 5FH ]
  E218                    ENDIF
  E218           
  E218                    ELSE
  E218           
ZAS Relocating Macro Assembler (v3.05                             page   30
                                                            
                                                            

  E218                    IF     WHLMASK
  E218                   DEFB    '&CHAR' + 80H
  E218                    ELSE
  E218                   DEFB    '&CHAR'
  E218                    ENDIF
  E218           
  E218                    ENDIF
  E218           
  E218                    ENDIF
  E218           
  E218           WHLMASK DEFL    FALSE
  E218           
  E218                   ENDM    ;IRPC
  E218           
  0003 =         COUNT   DEFL    COUNT - 1
  E218           
  E218                    IF     [ COUNT LT CMDSIZE ]
  E218           
  E218           
  E218                    IF     [ 'H' GE 'a' ] AND [ 'H' LE 'z' ]
  E218           
  E218                    IF     WHLMASK
  E218                   DEFB    [ 'H' AND 5FH ] + 80H
  E218                    ELSE
  E218                   DEFB    [ 'H' AND 5FH ]
  E218                    ENDIF
  E218           
  E218                    ELSE
  E218           
  E218                    IF     WHLMASK
  E218                   DEFB    'H' + 80H
  E218                    ELSE
  E218 48                DEFB    'H'
  E219                    ENDIF
  E219           
  E219                    ENDIF
  E219           
  E219                    ENDIF
  E219           
  0000 =         WHLMASK DEFL    FALSE
  E219           
  E219                   ENDM    ;IRPC
  E219           
  E219           
  E219                    IF     [ COUNT GT CMDSIZE ]
  E219                   *** COMMAND NAME "H" IS TOO LONG / TRUNCATED ***
  E219                    ELSE
  E219                   REPT    COUNT
  E219                   DEFB    ' '
  E219                   ENDM
  E219 20                DEFB    ' '
  E21A 20                DEFB    ' '
  E21B 20                DEFB    ' '
  E21C                   ENDM
  E21C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21C           
ZAS Relocating Macro Assembler (v3.05                             page   31
                                                            
                                                            

  E21C 41E2              DW      clist
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command LIST,   liston, wlist,  list
  E21E           
  E21E                    IF     liston
  E21E           
  E21E           WHLMASK DEFL    wlist
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,LIST
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "LIST" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      list
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
ZAS Relocating Macro Assembler (v3.05                             page   32
                                                            
                                                            

  E21E                   ENDM    ;COMMAND
  E21E                   command NOTE,   noteon, false,  note
  E21E           
  E21E                    IF     noteon
  E21E           
  E21E           WHLMASK DEFL    false
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,NOTE
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "NOTE" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      note
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command P,      peekon, wpeek,  peek
  E21E           
  E21E                    IF     peekon
ZAS Relocating Macro Assembler (v3.05                             page   33
                                                            
                                                            

  E21E           
  E21E           WHLMASK DEFL    wpeek
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,P
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "P" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      peek
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command POKE,   pokeon, wpoke,  poke
  E21E           
  E21E                    IF     pokeon
  E21E           
  E21E           WHLMASK DEFL    wpoke
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
ZAS Relocating Macro Assembler (v3.05                             page   34
                                                            
                                                            

  E21E                   IRPC    CHAR,POKE
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "POKE" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      poke
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command PORT,   porton, wport,  port
  E21E           
  E21E                    IF     porton
  E21E           
  E21E           WHLMASK DEFL    wport
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,PORT
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
ZAS Relocating Macro Assembler (v3.05                             page   35
                                                            
                                                            

  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "PORT" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      port
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command PROT,   proton, wprot,  att
  E21E           
  E21E                    IF     proton
  E21E           
  FFFF =         WHLMASK DEFL    wprot
  0004 =         COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,PROT
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
ZAS Relocating Macro Assembler (v3.05                             page   36
                                                            
                                                            

  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  0003 =         COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ 'P' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ 'P' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E D0                DEFB    'P' + 80H
  E21F                    ELSE
  E21F                   DEFB    'P'
  E21F                    ENDIF
  E21F           
  E21F                    ENDIF
  E21F           
  E21F                    ENDIF
  E21F           
  0000 =         WHLMASK DEFL    FALSE
  E21F           
  E21F           
  0002 =         COUNT   DEFL    COUNT - 1
  E21F           
  E21F                    IF     [ COUNT LT CMDSIZE ]
  E21F           
  E21F           
ZAS Relocating Macro Assembler (v3.05                             page   37
                                                            
                                                            

  E21F                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E21F           
  E21F                    IF     WHLMASK
  E21F                   DEFB    [ 'R' AND 5FH ] + 80H
  E21F                    ELSE
  E21F                   DEFB    [ 'R' AND 5FH ]
  E21F                    ENDIF
  E21F           
  E21F                    ELSE
  E21F           
  E21F                    IF     WHLMASK
  E21F                   DEFB    'R' + 80H
  E21F                    ELSE
  E21F 52                DEFB    'R'
  E220                    ENDIF
  E220           
  E220                    ENDIF
  E220           
  E220                    ENDIF
  E220           
  0000 =         WHLMASK DEFL    FALSE
  E220           
  E220           
  0001 =         COUNT   DEFL    COUNT - 1
  E220           
  E220                    IF     [ COUNT LT CMDSIZE ]
  E220           
  E220           
  E220                    IF     [ 'O' GE 'a' ] AND [ 'O' LE 'z' ]
  E220           
  E220                    IF     WHLMASK
  E220                   DEFB    [ 'O' AND 5FH ] + 80H
  E220                    ELSE
  E220                   DEFB    [ 'O' AND 5FH ]
  E220                    ENDIF
  E220           
  E220                    ELSE
  E220           
  E220                    IF     WHLMASK
  E220                   DEFB    'O' + 80H
  E220                    ELSE
  E220 4F                DEFB    'O'
  E221                    ENDIF
  E221           
  E221                    ENDIF
  E221           
  E221                    ENDIF
  E221           
  0000 =         WHLMASK DEFL    FALSE
  E221           
  E221           
  0000 =         COUNT   DEFL    COUNT - 1
  E221           
  E221                    IF     [ COUNT LT CMDSIZE ]
  E221           
  E221           
ZAS Relocating Macro Assembler (v3.05                             page   38
                                                            
                                                            

  E221                    IF     [ 'T' GE 'a' ] AND [ 'T' LE 'z' ]
  E221           
  E221                    IF     WHLMASK
  E221                   DEFB    [ 'T' AND 5FH ] + 80H
  E221                    ELSE
  E221                   DEFB    [ 'T' AND 5FH ]
  E221                    ENDIF
  E221           
  E221                    ELSE
  E221           
  E221                    IF     WHLMASK
  E221                   DEFB    'T' + 80H
  E221                    ELSE
  E221 54                DEFB    'T'
  E222                    ENDIF
  E222           
  E222                    ENDIF
  E222           
  E222                    ENDIF
  E222           
  0000 =         WHLMASK DEFL    FALSE
  E222           
  E222                   ENDM    ;IRPC
  E222           
  E222           
  E222                    IF     [ COUNT GT CMDSIZE ]
  E222                   *** COMMAND NAME "PROT" IS TOO LONG / TRUNCATED ***
  E222                    ELSE
  E222                   REPT    COUNT
  E222                   DEFB    ' '
  E222                   ENDM
  E222                   ENDM
  E222                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E222           
  E222 E1E4              DW      att
  E224           
  E224                    ENDIF  ;ENABLE
  E224           
  E224                   ENDM    ;COMMAND
  E224                   command R,      reson,  false,  reset
  E224           
  E224                    IF     reson
  E224           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E224           
  E224                   IRPC    CHAR,R
  E224           
  E224           COUNT   DEFL    COUNT - 1
  E224           
  E224                    IF     [ COUNT LT CMDSIZE ]
  E224           
  E224           
  E224                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E224           
  E224                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   39
                                                            
                                                            

  E224                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E224                    ELSE
  E224                   DEFB    [ '&CHAR' AND 5FH ]
  E224                    ENDIF
  E224           
  E224                    ELSE
  E224           
  E224                    IF     WHLMASK
  E224                   DEFB    '&CHAR' + 80H
  E224                    ELSE
  E224                   DEFB    '&CHAR'
  E224                    ENDIF
  E224           
  E224                    ENDIF
  E224           
  E224                    ENDIF
  E224           
  E224           WHLMASK DEFL    FALSE
  E224           
  E224                   ENDM    ;IRPC
  E224           
  0003 =         COUNT   DEFL    COUNT - 1
  E224           
  E224                    IF     [ COUNT LT CMDSIZE ]
  E224           
  E224           
  E224                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E224           
  E224                    IF     WHLMASK
  E224                   DEFB    [ 'R' AND 5FH ] + 80H
  E224                    ELSE
  E224                   DEFB    [ 'R' AND 5FH ]
  E224                    ENDIF
  E224           
  E224                    ELSE
  E224           
  E224                    IF     WHLMASK
  E224                   DEFB    'R' + 80H
  E224                    ELSE
  E224 52                DEFB    'R'
  E225                    ENDIF
  E225           
  E225                    ENDIF
  E225           
  E225                    ENDIF
  E225           
  0000 =         WHLMASK DEFL    FALSE
  E225           
  E225                   ENDM    ;IRPC
  E225           
  E225           
  E225                    IF     [ COUNT GT CMDSIZE ]
  E225                   *** COMMAND NAME "R" IS TOO LONG / TRUNCATED ***
  E225                    ELSE
  E225                   REPT    COUNT
  E225                   DEFB    ' '
ZAS Relocating Macro Assembler (v3.05                             page   40
                                                            
                                                            

  E225                   ENDM
  E225 20                DEFB    ' '
  E226 20                DEFB    ' '
  E227 20                DEFB    ' '
  E228                   ENDM
  E228                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E228           
  E228 C7E2              DW      reset
  E22A           
  E22A                    ENDIF  ;ENABLE
  E22A           
  E22A                   ENDM    ;COMMAND
  E22A                   command REG,    regon,  wreg,   register
  E22A           
  E22A                    IF     regon
  E22A           
  E22A           WHLMASK DEFL    wreg
  E22A           COUNT   DEFL    CMDSIZE
  E22A           
  E22A                   IRPC    CHAR,REG
  E22A           
  E22A           COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ '&CHAR' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    '&CHAR' + 80H
  E22A                    ELSE
  E22A                   DEFB    '&CHAR'
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A           WHLMASK DEFL    FALSE
  E22A           
  E22A                   ENDM    ;IRPC
  E22A           
  E22A           
  E22A                    IF     [ COUNT GT CMDSIZE ]
  E22A                   *** COMMAND NAME "REG" IS TOO LONG / TRUNCATED ***
  E22A                    ELSE
  E22A                   REPT    COUNT
  E22A                   DEFB    ' '
ZAS Relocating Macro Assembler (v3.05                             page   41
                                                            
                                                            

  E22A                   ENDM
  E22A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E22A           
  E22A                   DW      register
  E22A           
  E22A                    ENDIF  ;ENABLE
  E22A           
  E22A                   ENDM    ;COMMAND
  E22A                   command REN,    renon,  wren,   ren
  E22A           
  E22A                    IF     renon
  E22A           
  E22A           WHLMASK DEFL    wren
  E22A           COUNT   DEFL    CMDSIZE
  E22A           
  E22A                   IRPC    CHAR,REN
  E22A           
  E22A           COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ '&CHAR' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    '&CHAR' + 80H
  E22A                    ELSE
  E22A                   DEFB    '&CHAR'
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A           WHLMASK DEFL    FALSE
  E22A           
  E22A                   ENDM    ;IRPC
  E22A           
  E22A           
  E22A                    IF     [ COUNT GT CMDSIZE ]
  E22A                   *** COMMAND NAME "REN" IS TOO LONG / TRUNCATED ***
  E22A                    ELSE
  E22A                   REPT    COUNT
  E22A                   DEFB    ' '
  E22A                   ENDM
  E22A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E22A           
  E22A                   DW      ren
ZAS Relocating Macro Assembler (v3.05                             page   42
                                                            
                                                            

  E22A           
  E22A                    ENDIF  ;ENABLE
  E22A           
  E22A                   ENDM    ;COMMAND
  E22A                   command SP,     spaceon,false,  space
  E22A           
  E22A                    IF     spaceon
  E22A           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E22A           
  E22A                   IRPC    CHAR,SP
  E22A           
  E22A           COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ '&CHAR' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    '&CHAR' + 80H
  E22A                    ELSE
  E22A                   DEFB    '&CHAR'
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A           WHLMASK DEFL    FALSE
  E22A           
  E22A                   ENDM    ;IRPC
  E22A           
  0003 =         COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ 'S' GE 'a' ] AND [ 'S' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ 'S' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ 'S' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   43
                                                            
                                                            

  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    'S' + 80H
  E22A                    ELSE
  E22A 53                DEFB    'S'
  E22B                    ENDIF
  E22B           
  E22B                    ENDIF
  E22B           
  E22B                    ENDIF
  E22B           
  0000 =         WHLMASK DEFL    FALSE
  E22B           
  E22B           
  0002 =         COUNT   DEFL    COUNT - 1
  E22B           
  E22B                    IF     [ COUNT LT CMDSIZE ]
  E22B           
  E22B           
  E22B                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  E22B           
  E22B                    IF     WHLMASK
  E22B                   DEFB    [ 'P' AND 5FH ] + 80H
  E22B                    ELSE
  E22B                   DEFB    [ 'P' AND 5FH ]
  E22B                    ENDIF
  E22B           
  E22B                    ELSE
  E22B           
  E22B                    IF     WHLMASK
  E22B                   DEFB    'P' + 80H
  E22B                    ELSE
  E22B 50                DEFB    'P'
  E22C                    ENDIF
  E22C           
  E22C                    ENDIF
  E22C           
  E22C                    ENDIF
  E22C           
  0000 =         WHLMASK DEFL    FALSE
  E22C           
  E22C                   ENDM    ;IRPC
  E22C           
  E22C           
  E22C                    IF     [ COUNT GT CMDSIZE ]
  E22C                   *** COMMAND NAME "SP" IS TOO LONG / TRUNCATED ***
  E22C                    ELSE
  E22C                   REPT    COUNT
  E22C                   DEFB    ' '
  E22C                   ENDM
  E22C 20                DEFB    ' '
  E22D 20                DEFB    ' '
  E22E                   ENDM
  E22E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E22E           
  E22E D8E2              DW      space
ZAS Relocating Macro Assembler (v3.05                             page   44
                                                            
                                                            

  E230           
  E230                    ENDIF  ;ENABLE
  E230           
  E230                   ENDM    ;COMMAND
  E230                   command TST,    tston,  false,  testerr
  E230           
  E230                    IF     tston
  E230           
  E230           WHLMASK DEFL    false
  E230           COUNT   DEFL    CMDSIZE
  E230           
  E230                   IRPC    CHAR,TST
  E230           
  E230           COUNT   DEFL    COUNT - 1
  E230           
  E230                    IF     [ COUNT LT CMDSIZE ]
  E230           
  E230           
  E230                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E230                    ELSE
  E230                   DEFB    [ '&CHAR' AND 5FH ]
  E230                    ENDIF
  E230           
  E230                    ELSE
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    '&CHAR' + 80H
  E230                    ELSE
  E230                   DEFB    '&CHAR'
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230           WHLMASK DEFL    FALSE
  E230           
  E230                   ENDM    ;IRPC
  E230           
  E230           
  E230                    IF     [ COUNT GT CMDSIZE ]
  E230                   *** COMMAND NAME "TST" IS TOO LONG / TRUNCATED ***
  E230                    ELSE
  E230                   REPT    COUNT
  E230                   DEFB    ' '
  E230                   ENDM
  E230                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E230           
  E230                   DW      testerr
  E230           
  E230                    ENDIF  ;ENABLE
  E230           
  E230                   ENDM    ;COMMAND
ZAS Relocating Macro Assembler (v3.05                             page   45
                                                            
                                                            

  E230                   command TYPE,   lton,   wtype,  type
  E230           
  E230                    IF     lton
  E230           
  FFFF =         WHLMASK DEFL    wtype
  0004 =         COUNT   DEFL    CMDSIZE
  E230           
  E230                   IRPC    CHAR,TYPE
  E230           
  E230           COUNT   DEFL    COUNT - 1
  E230           
  E230                    IF     [ COUNT LT CMDSIZE ]
  E230           
  E230           
  E230                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E230                    ELSE
  E230                   DEFB    [ '&CHAR' AND 5FH ]
  E230                    ENDIF
  E230           
  E230                    ELSE
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    '&CHAR' + 80H
  E230                    ELSE
  E230                   DEFB    '&CHAR'
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230           WHLMASK DEFL    FALSE
  E230           
  E230                   ENDM    ;IRPC
  E230           
  0003 =         COUNT   DEFL    COUNT - 1
  E230           
  E230                    IF     [ COUNT LT CMDSIZE ]
  E230           
  E230           
  E230                    IF     [ 'T' GE 'a' ] AND [ 'T' LE 'z' ]
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    [ 'T' AND 5FH ] + 80H
  E230                    ELSE
  E230                   DEFB    [ 'T' AND 5FH ]
  E230                    ENDIF
  E230           
  E230                    ELSE
  E230           
  E230                    IF     WHLMASK
  E230 D4                DEFB    'T' + 80H
  E231                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   46
                                                            
                                                            

  E231                   DEFB    'T'
  E231                    ENDIF
  E231           
  E231                    ENDIF
  E231           
  E231                    ENDIF
  E231           
  0000 =         WHLMASK DEFL    FALSE
  E231           
  E231           
  0002 =         COUNT   DEFL    COUNT - 1
  E231           
  E231                    IF     [ COUNT LT CMDSIZE ]
  E231           
  E231           
  E231                    IF     [ 'Y' GE 'a' ] AND [ 'Y' LE 'z' ]
  E231           
  E231                    IF     WHLMASK
  E231                   DEFB    [ 'Y' AND 5FH ] + 80H
  E231                    ELSE
  E231                   DEFB    [ 'Y' AND 5FH ]
  E231                    ENDIF
  E231           
  E231                    ELSE
  E231           
  E231                    IF     WHLMASK
  E231                   DEFB    'Y' + 80H
  E231                    ELSE
  E231 59                DEFB    'Y'
  E232                    ENDIF
  E232           
  E232                    ENDIF
  E232           
  E232                    ENDIF
  E232           
  0000 =         WHLMASK DEFL    FALSE
  E232           
  E232           
  0001 =         COUNT   DEFL    COUNT - 1
  E232           
  E232                    IF     [ COUNT LT CMDSIZE ]
  E232           
  E232           
  E232                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  E232           
  E232                    IF     WHLMASK
  E232                   DEFB    [ 'P' AND 5FH ] + 80H
  E232                    ELSE
  E232                   DEFB    [ 'P' AND 5FH ]
  E232                    ENDIF
  E232           
  E232                    ELSE
  E232           
  E232                    IF     WHLMASK
  E232                   DEFB    'P' + 80H
  E232                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   47
                                                            
                                                            

  E232 50                DEFB    'P'
  E233                    ENDIF
  E233           
  E233                    ENDIF
  E233           
  E233                    ENDIF
  E233           
  0000 =         WHLMASK DEFL    FALSE
  E233           
  E233           
  0000 =         COUNT   DEFL    COUNT - 1
  E233           
  E233                    IF     [ COUNT LT CMDSIZE ]
  E233           
  E233           
  E233                    IF     [ 'E' GE 'a' ] AND [ 'E' LE 'z' ]
  E233           
  E233                    IF     WHLMASK
  E233                   DEFB    [ 'E' AND 5FH ] + 80H
  E233                    ELSE
  E233                   DEFB    [ 'E' AND 5FH ]
  E233                    ENDIF
  E233           
  E233                    ELSE
  E233           
  E233                    IF     WHLMASK
  E233                   DEFB    'E' + 80H
  E233                    ELSE
  E233 45                DEFB    'E'
  E234                    ENDIF
  E234           
  E234                    ENDIF
  E234           
  E234                    ENDIF
  E234           
  0000 =         WHLMASK DEFL    FALSE
  E234           
  E234                   ENDM    ;IRPC
  E234           
  E234           
  E234                    IF     [ COUNT GT CMDSIZE ]
  E234                   *** COMMAND NAME "TYPE" IS TOO LONG / TRUNCATED ***
  E234                    ELSE
  E234                   REPT    COUNT
  E234                   DEFB    ' '
  E234                   ENDM
  E234                   ENDM
  E234                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E234           
  E234 FCE3              DW      type
  E236           
  E236                    ENDIF  ;ENABLE
  E236           
  E236                   ENDM    ;COMMAND
  E236                   command WHL,    whlon,  false,  whl
  E236           
ZAS Relocating Macro Assembler (v3.05                             page   48
                                                            
                                                            

  E236                    IF     whlon
  E236           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E236           
  E236                   IRPC    CHAR,WHL
  E236           
  E236           COUNT   DEFL    COUNT - 1
  E236           
  E236                    IF     [ COUNT LT CMDSIZE ]
  E236           
  E236           
  E236                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E236                    ELSE
  E236                   DEFB    [ '&CHAR' AND 5FH ]
  E236                    ENDIF
  E236           
  E236                    ELSE
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    '&CHAR' + 80H
  E236                    ELSE
  E236                   DEFB    '&CHAR'
  E236                    ENDIF
  E236           
  E236                    ENDIF
  E236           
  E236                    ENDIF
  E236           
  E236           WHLMASK DEFL    FALSE
  E236           
  E236                   ENDM    ;IRPC
  E236           
  0003 =         COUNT   DEFL    COUNT - 1
  E236           
  E236                    IF     [ COUNT LT CMDSIZE ]
  E236           
  E236           
  E236                    IF     [ 'W' GE 'a' ] AND [ 'W' LE 'z' ]
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    [ 'W' AND 5FH ] + 80H
  E236                    ELSE
  E236                   DEFB    [ 'W' AND 5FH ]
  E236                    ENDIF
  E236           
  E236                    ELSE
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    'W' + 80H
  E236                    ELSE
  E236 57                DEFB    'W'
  E237                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   49
                                                            
                                                            

  E237           
  E237                    ENDIF
  E237           
  E237                    ENDIF
  E237           
  0000 =         WHLMASK DEFL    FALSE
  E237           
  E237           
  0002 =         COUNT   DEFL    COUNT - 1
  E237           
  E237                    IF     [ COUNT LT CMDSIZE ]
  E237           
  E237           
  E237                    IF     [ 'H' GE 'a' ] AND [ 'H' LE 'z' ]
  E237           
  E237                    IF     WHLMASK
  E237                   DEFB    [ 'H' AND 5FH ] + 80H
  E237                    ELSE
  E237                   DEFB    [ 'H' AND 5FH ]
  E237                    ENDIF
  E237           
  E237                    ELSE
  E237           
  E237                    IF     WHLMASK
  E237                   DEFB    'H' + 80H
  E237                    ELSE
  E237 48                DEFB    'H'
  E238                    ENDIF
  E238           
  E238                    ENDIF
  E238           
  E238                    ENDIF
  E238           
  0000 =         WHLMASK DEFL    FALSE
  E238           
  E238           
  0001 =         COUNT   DEFL    COUNT - 1
  E238           
  E238                    IF     [ COUNT LT CMDSIZE ]
  E238           
  E238           
  E238                    IF     [ 'L' GE 'a' ] AND [ 'L' LE 'z' ]
  E238           
  E238                    IF     WHLMASK
  E238                   DEFB    [ 'L' AND 5FH ] + 80H
  E238                    ELSE
  E238                   DEFB    [ 'L' AND 5FH ]
  E238                    ENDIF
  E238           
  E238                    ELSE
  E238           
  E238                    IF     WHLMASK
  E238                   DEFB    'L' + 80H
  E238                    ELSE
  E238 4C                DEFB    'L'
  E239                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   50
                                                            
                                                            

  E239           
  E239                    ENDIF
  E239           
  E239                    ENDIF
  E239           
  0000 =         WHLMASK DEFL    FALSE
  E239           
  E239                   ENDM    ;IRPC
  E239           
  E239           
  E239                    IF     [ COUNT GT CMDSIZE ]
  E239                   *** COMMAND NAME "WHL" IS TOO LONG / TRUNCATED ***
  E239                    ELSE
  E239                   REPT    COUNT
  E239                   DEFB    ' '
  E239                   ENDM
  E239 20                DEFB    ' '
  E23A                   ENDM
  E23A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E23A           
  E23A 94E5              DW      whl
  E23C           
  E23C                    ENDIF  ;ENABLE
  E23C           
  E23C                   ENDM    ;COMMAND
  E23C                   command WHLQ,   whlqon, wwhlq,  whlmsg
  E23C           
  E23C                    IF     whlqon
  E23C           
  E23C           WHLMASK DEFL    wwhlq
  E23C           COUNT   DEFL    CMDSIZE
  E23C           
  E23C                   IRPC    CHAR,WHLQ
  E23C           
  E23C           COUNT   DEFL    COUNT - 1
  E23C           
  E23C                    IF     [ COUNT LT CMDSIZE ]
  E23C           
  E23C           
  E23C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E23C           
  E23C                    IF     WHLMASK
  E23C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E23C                    ELSE
  E23C                   DEFB    [ '&CHAR' AND 5FH ]
  E23C                    ENDIF
  E23C           
  E23C                    ELSE
  E23C           
  E23C                    IF     WHLMASK
  E23C                   DEFB    '&CHAR' + 80H
  E23C                    ELSE
  E23C                   DEFB    '&CHAR'
  E23C                    ENDIF
  E23C           
  E23C                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   51
                                                            
                                                            

  E23C           
  E23C                    ENDIF
  E23C           
  E23C           WHLMASK DEFL    FALSE
  E23C           
  E23C                   ENDM    ;IRPC
  E23C           
  E23C           
  E23C                    IF     [ COUNT GT CMDSIZE ]
  E23C                   *** COMMAND NAME "WHLQ" IS TOO LONG / TRUNCATED ***
  E23C                    ELSE
  E23C                   REPT    COUNT
  E23C                   DEFB    ' '
  E23C                   ENDM
  E23C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E23C           
  E23C                   DW      whlmsg
  E23C           
  E23C                    ENDIF  ;ENABLE
  E23C           
  E23C                   ENDM    ;COMMAND
  E23C           
  E23C                    endm
  E23C 00                db      0               ; Marks end of command jump table
  E23D           
  E23D           
  E23D           ;----------------------------------------
  E23D           
  E23D           ; Name of RCP
  E23D           
  E23D           ; This block allows the 'H' command and/or the SHOW utility to display a name
  E23D           ; and version number for this RCP as well as the commands that are supported.
  E23D           
  E23D           rcpname:
  E23D                   idstring                ; From macro in Z33RCP.LIB
  E23D 524350            db      'RCP'           ; Name of Z33RCP module
  E240           ;       db      ' '
  E240           ;       db      version + '0'   ; Main version number
  E240           ;       db      '.'
  E240           ;       db      subver + '0'    ; Subversion number
  E240           ;       db      rcpid           ; User's ID character from Z33RCP.LIB
  E240 00                db      0               ; End of name string
  E241                    endm
  E241           
  E241           ; Include only those code sections that are required.
  E241           
  E241+                  include rcph            ; 'H'   help (command list) command
ZAS Relocating Macro Assembler (v3.05                             page   52
                                                            
                                                            

  E241+                  page
  E241+          
  E241+          ; RCP-H.Z80     'H' Command
  E241+          
  E241+          ;=============================================================================
  E241+          ;
  E241+          ;       H E L P    C O M M A N D
  E241+          ;
  E241+          ;=============================================================================
  E241+          
  E241+          ; This command displays a list of all resident commands that are supported,
  E241+          ; including those in the CPR (command processor), RCP, and FCP.
  E241+          
  E241+          clist:
  E241+          
  E241+          ; Print the FCP-resident command names
  E241+          
  E241+                   if     listfcp
  E241+          
  E241+2A12EC            ld      hl,(z3env+12h)  ; Get FCP address
  E244+7C                ld      a,h             ; See if implemented
  E245+B5                or      l
  E246+280E              jr      z,nofcp
  E248+          
  E248+110500            ld      de,5
  E24B+19                add     hl,de
  E24C+          
  E24C+CD0FE6            call    print           ; Print header for FCP
  E24F+0A                db      lf
  E250+4643D0            db      'FC','P'+80h
  E253+CD6FE2            call    cmdlist         ; Display list of commands
  E256+          
  E256+          nofcp:
  E256+          
  E256+                   endif  ;listfcp
  E256+          
  E256+          ; Print the CPR-resident command names
  E256+          
  E256+                   if     listcpr
  E256+          
  E256+CD0FE6            call    print           ; Print "CPR"
  E259+0A                db      lf
  E25A+4350D2            db      'CP','R'+80h
  E25D+2119C2            ld      hl,ccp+offcmd   ; Point to command table in CPR
  E260+CD6FE2            call    cmdlist         ; Display the list of commands
  E263+          
  E263+                   endif  ;listcpr
  E263+          
  E263+          ; Print the RCP-resident command names
  E263+          
  E263+CD1FE6            call    crlf            ; Skip a line
  E266+213DE2            ld      hl,rcpname      ; Print RCP name
  E269+CD15E6            call    printhl
  E26C+2105E2            ld      hl,rcp+5        ; Point to RCP command table
  E26F+                                          ; Fall through to CMDLIST
  E26F+          
ZAS Relocating Macro Assembler (v3.05                             page   53
                                                            
                                                            

  E26F+          ;----------------------------------------
  E26F+          
  E26F+          ; Subroutine to display list of commands in a command table (code above
  E26F+          ; falls through to this routine -- do not move it).  The commands are
  E26F+          ; displayed 5 per line with 8 character spaces allowed for each command
  E26F+          ; (subject to equates below).
  E26F+          
  E26F+          cmdlist:
  E26F+CD1FE6            call    crlf            ; Start with new line
  E272+5E                ld      e,(hl)          ; Get size of each command name into DE
  E273+1600              ld      d,0
  E275+23                inc     hl              ; Point to name of first command
  E276+0E05              ld      c,cmdsline      ; Set names-per-line value
  E278+          
  E278+          cmdlist1:
  E278+7E                ld      a,(hl)          ; Get first character of the command name
  E279+B7                or      a               ; See if it is null
  E27A+2007              jr      nz,cmdlist1a    ; If not, continue
  E27C+3E05              ld      a,cmdsline      ; See if we are already on a new line
  E27E+B9                cp      c
  E27F+C41FE6            call    nz,crlf         ; If not, skip a line
  E282+C9                ret
  E283+          
  E283+          cmdlist1a:
  E283+                   if     noshow          ; Option to suppress wheel-limited cmds
  E283+17                rla                     ; Shift high bit of name into carry bit
  E284+3009              jr      nc,cmdlist2     ; If not restricted, go on
  E286+3AFFED            ld      a,(z3whl)       ; Otherwise, check wheel byte
  E289+B7                or      a
  E28A+2003              jr      nz,cmdlist2     ; If wheel set, continue as usual
  E28C+19                add     hl,de           ; Otherwise skip this command
  E28D+181B              jr      cmdlist5
  E28F+                   endif
  E28F+          
  E28F+          ; Print leading spaces between names
  E28F+          
  E28F+          cmdlist2:
  E28F+3E08              ld      a,cmdspace      ; Spacing between command names
  E291+93                sub     e               ; Less length of each command name
  E292+47                ld      b,a
  E293+3E20              ld      a,' '
  E295+          cmdlist3:
  E295+CDFEE5            call    conout
  E298+10FB              djnz    cmdlist3
  E29A+          
  E29A+          ; Print name of command
  E29A+          
  E29A+43                ld      b,e             ; Length of each name into B
  E29B+          cmdlist4:
  E29B+7E                ld      a,(hl)          ; Get command name character
  E29C+CDFEE5            call    conout
  E29F+23                inc     hl              ; Point to next
  E2A0+10F9              djnz    cmdlist4
  E2A2+          
  E2A2+0D                dec     c               ; Decrement count of names on this line
  E2A3+2005              jr      nz,cmdlist5     ; Branch if room for more names
ZAS Relocating Macro Assembler (v3.05                             page   54
                                                            
                                                            

  E2A5+CD1FE6            call    crlf            ; Otherwise, end this line and
  E2A8+0E05              ld      c,cmdsline      ; ..reset count for another line of commands
  E2AA+          
  E2AA+          ; Skip to next command name
  E2AA+          
  E2AA+          cmdlist5:
  E2AA+23                inc     hl              ; Skip jump vector
  E2AB+23                inc     hl
  E2AC+18CA              jr      cmdlist1        ; Back to process next name
  E2AE+          
  E2AE+          ; End RCP-H.Z80
  E2AE+          
  E2AE           
  E2AE                    if     clson
  E2AE+                  include rcpcls          ; 'CLS' clear screen command
ZAS Relocating Macro Assembler (v3.05                             page   55
                                                            
                                                            

  E2AE+                  page
  E2AE+          
  E2AE+          ; RCP-CLS.Z80   'CLS' Command
  E2AE+          
  E2AE+          ;=============================================================================
  E2AE+          ;
  E2AE+          ;               C L E A R    S C R E E N    C O M M A N D
  E2AE+          ;
  E2AE+          ;=============================================================================
  E2AE+          
  E2AE+          ; Command:      CLS
  E2AE+          ; Function:     To clear the CRT screen
  E2AE+          ; Comments:     The setting of the CLSTCAP equate determines whether this
  E2AE+          ;               command uses the TCAP information or not.  If not, it uses the
  E2AE+          ;               clear-screen string passed in macro CLSSTR.  That string should
  E2AE+          ;               end with the high bit set.
  E2AE+          
  E2AE+          cls:
  E2AE+                   if     clstcap         ; If using TCAP for clear screen string
  E2AE+          
  E2AE+3A80EC            ld      a,(z3env+80h)   ; Get beginning of tcap
  E2B1+FE21              cp      ' '+1           ; See if blank
  E2B3+300C              jr      nc,cls1         ; If not, go to clear screen code
  E2B5+CD0FE6            call    print           ; If blank, then give error message
  E2B8+204E6F2054        db      ' No TCA','P'+80h
  E2C0+C9                ret
  E2C1+          
  E2C1+2197EC    cls1:   ld      hl,z3env+97h    ; Point to beginning of clear screen string
  E2C4+C315E6            jp      printhl         ; Display it
  E2C7+          
  E2C7+                   else                   ; Not using tcap
  E2C7+          
  E2C7+                  call    print
  E2C7+                  clsstr                  ; String from Z33RCP.LIB
  E2C7+                  ret
  E2C7+          
  E2C7+                   endif  ;clstcap
  E2C7+          
  E2C7+          ; End RCP-CLS.Z80
  E2C7+          
  E2C7                    endif  ;clson
  E2C7           
  E2C7                    if     reson
  E2C7+                  include rcpr            ; 'R'   disk reset command
ZAS Relocating Macro Assembler (v3.05                             page   56
                                                            
                                                            

  E2C7+                  page
  E2C7+          
  E2C7+          ; RCP-R.Z80     'R' command
  E2C7+          
  E2C7+          ;=============================================================================
  E2C7+          ;
  E2C7+          ;       D I S K    R E S E T    C O M M A N D
  E2C7+          ;
  E2C7+          ;=============================================================================
  E2C7+          
  E2C7+          ; Command:      RESET
  E2C7+          ; Function:     Reset the disk system
  E2C7+          ; Comments:     ZRDOS does not require a disk system reset when disks are
  E2C7+          ;               changed, but directory programs will not show the correct
  E2C7+          ;               size if this is not done.  It is also good practice.  Since
  E2C7+          ;               no warm boot performed, the disk in drive A need not have the
  E2C7+          ;               operating system on it.
  E2C7+          
  E2C7+          reset:
  E2C7+0E0D              ld      c,13            ; Disk reset BDOS function
  E2C9+          
  E2C9+                   if     resmsg          ; If displaying a reset message
  E2C9+CD06CA            call    bdos            ; Reset disk system
  E2CC+CD0FE6            call    print           ; Report action
  E2CF+72657365F4        db      'rese','t'+80h
  E2D4+C9                ret
  E2D5+                   else                   ; No reset message
  E2D5+                  jp      bdos            ; Call bdos and return
  E2D5+                   endif  ;resmsg
  E2D5+          
  E2D5+          ; End RCP-R.Z80
  E2D5+          
  E2D5                    endif  ;reson
  E2D5           
  E2D5                    if     tston
  E2D5                   include rcptst          ; 'TST' error test command
  E2D5                    endif  ;tston
  E2D5           
  E2D5                    if     spaceon
  E2D5+                  include rcpsp           ; 'SP'  space on disk command
ZAS Relocating Macro Assembler (v3.05                             page   57
                                                            
                                                            

  E2D5+                  page
  E2D5+          
  E2D5+          ; RCP-SP.Z80    'SP' Command
  E2D5+          
  E2D5+          ;=============================================================================
  E2D5+          ;
  E2D5+          ;       D I S K    S P A C E    C O M M A N D
  E2D5+          ;
  E2D5+          ;=============================================================================
  E2D5+          
  E2D5+          ; Command:      SP
  E2D5+          ; Function:     Shows space remaining on designated drive
  E2D5+          ; Syntax:       SP [DIR:|DU:]
  E2D5+          ; Comments:     This code can be called by several other RCP commands so that
  E2D5+          ;               they can show the space remaining on the disk after their
  E2D5+          ;               operation.
  E2D5+          
  E2D5+                   if     [erasp or cpsp or dirsp]
  E2D5+          crspace:                        ; Used to call space after other subroutines
  E2D5+CD1FE6            call    crlf            ; Start new line
  E2D8+                   endif  ;[erasp or cpsp or dirsp]
  E2D8+          
  E2D8+          space:
  E2D8+3A5C00            ld      a,(fcb1)        ; Determine requested drive
  E2DB+B7                or      a               ; If drive explicitly selected
  E2DC+2006              jr      nz,space1       ; ..then skip
  E2DE+          
  E2DE+0E19              ld      c,25            ; BDOS get current drive function
  E2E0+CD06CA            call    bdos
  E2E3+3C                inc     a               ; Shift to range 1..16
  E2E4+          
  E2E4+          space1:
  E2E4+3D                dec     a               ; Shift to range 0..15
  E2E5+5F                ld      e,a             ; Save in E for selecting disk below
  E2E6+C641              add     'A'             ; Convert to letter and
  E2E8+323CE3            ld      (seldrv),a      ;   save in message string below
  E2EB+0E0E              ld      c,14            ; BDOS select disk function
  E2ED+CD06CA            call    bdos            ; Not needed if no drive selected, but smallest
  E2F0+                                          ; ..possible code size this way.
  E2F0+          
  E2F0+          ; Here we extract the following disk parameter information from the disk
  E2F0+          ; parameter block (DPB):
  E2F0+          ;       BLKSHF: block shift factor (1 byte)
  E2F0+          ;       BLKMAX: max number of blocks on disk (2 bytes)
  E2F0+          
  E2F0+          dparams:
  E2F0+0E1F              ld      c,31            ; BDOS get disk parameters function
  E2F2+CD06CA            call    bdos
  E2F5+23                inc     hl              ; Advance to block shift factor byte
  E2F6+23                inc     hl
  E2F7+7E                ld      a,(hl)          ; Get value and
  E2F8+3226E3            ld      (blkshf),a      ; ..save it in code below
  E2FB+23                inc     hl              ; Advance to max block number word
  E2FC+23                inc     hl
  E2FD+23                inc     hl
  E2FE+5E                ld      e,(hl)          ; Get value into HL
ZAS Relocating Macro Assembler (v3.05                             page   58
                                                            
                                                            

  E2FF+23                inc     hl
  E300+56                ld      d,(hl)
  E301+13                inc     de              ; Add 1 for max number of blocks
  E302+          
  E302+          ; Compute amount of free space left on disk
  E302+          
  E302+          dfree:
  E302+0E1B              ld      c,27            ; BDOS get allocation vector function
  E304+D5                push    de              ; Save BLKMAX value
  E305+CD06CA            call    bdos            ; Get allocation vector into HL
  E308+44                ld      b,h             ; Copy allocation vector to BC
  E309+4D                ld      c,l
  E30A+E1                pop     hl              ; Restore MAXBLK value to HL
  E30B+110000            ld      de,0            ; Inititialize count of free blocks
  E30E+          
  E30E+          ; At this point we have
  E30E+          ;       BC = allocation vector address
  E30E+          ;       DE = free block count
  E30E+          ;       HL = number of blocks on disk
  E30E+          
  E30E+          free1:
  E30E+C5                push    bc              ; Save allocation address
  E30F+0A                ld      a,(bc)          ; Get bit pattern of allocation byte
  E310+0608              ld      b,8             ; Set to process 8 blocks
  E312+          free2:
  E312+17                rla                     ; Rotate allocated block bit into carry flag
  E313+3801              jr      c,free3         ; If set (bit=1), block is allocated
  E315+13                inc     de              ; If not set, block is not allocated, so
  E316+                                          ; ..increment free block count
  E316+          free3:
  E316+4F                ld      c,a             ; Save remaining allocation bits in C
  E317+2B                dec     hl              ; Count down number of blocks on disk
  E318+7D                ld      a,l             ; See if we are down to zero
  E319+B4                or      h
  E31A+2807              jr      z,free4         ; Branch if no more blocks to check
  E31C+79                ld      a,c             ; Get back current allocation bit pattern
  E31D+10F3              djnz    free2           ; Loop through 8 bits
  E31F+C1                pop     bc              ; Get pointer to allocation vector
  E320+03                inc     bc              ; Point to next allocation byte
  E321+18EB              jr      free1           ; Continue by processing next allocation byte
  E323+          
  E323+          free4:
  E323+C1                pop     bc              ; Clean up stack
  E324+EB                ex      de,hl           ; Free block count to HL
  E326+=         blkshf  equ     $+1             ; Pointer for in-the-code modification
  E325+3E00              ld      a,0             ; Get block shift factor
  E327+D603              sub     3               ; Convert to log base 2 of K per block
  E329+2804              jr      z,free6         ; Done if single density (1k per block)
  E32B+          
  E32B+          ; Convert for blocks of more than 1K each
  E32B+          
  E32B+          free5:
  E32B+29                add     hl,hl
  E32C+3D                dec     a
  E32D+20FC              jr      nz,free5
  E32F+          
ZAS Relocating Macro Assembler (v3.05                             page   59
                                                            
                                                            

  E32F+          ; At this point HL = amount of free space on disk in K
  E32F+          
  E32F+          free6:
  E32F+CD0FE6            call    print
  E332+2053706163        db      ' Space on '
  E33C+00        seldrv: db      0               ; Modified above to contain drive letter
  E33D+3AA0              db      ':',[' '+80h]
  E33F+          
  E33F+          ; Display decimal value of HL
  E33F+          
  E33F+0600              ld      b,0             ; Initialize count of digits already printed
  E341+111027            ld      de,10000        ; Divisor in DE
  E344+CDE9E5            call    decdsp          ; Print digit (or space if leading '0')
  E347+11E803            ld      de,1000
  E34A+CDE9E5            call    decdsp
  E34D+CDD9E5            call    decdsp3         ; Display hundreds, tens, and units
  E350+3E4B              ld      a,'K'
  E352+C3FEE5            jp      conout          ; Final return from space routine
  E355+          
  E355+          ; End RCP-SP.Z80
  E355+          
  E355                    endif  ;spaceon
  E355           
  E355                    if     diron
  E355+                  include rcpdir          ; 'DIR' directory command
ZAS Relocating Macro Assembler (v3.05                             page   60
                                                            
                                                            

  E355+                  page
  E355+          
  E355+          ; RCP-DIR.Z80   'DIR' Command
  E355+          
  E355+          ;=============================================================================
  E355+          ;
  E355+          ;       D I R E C T O R Y    D I S P L A Y    C O M M A N D
  E355+          ;
  E355+          ;=============================================================================
  E355+          
  E355+          ; Command:      DIR
  E355+          ; Function:     Display a directory of the files on disk
  E355+          ; Syntax:       DIR <afn>       Displays the DIR files
  E355+          ;               DIR <afn> S     Displays the SYS files
  E355+          ;               DIR <afn> A     Display both DIR and SYS files
  E355+          ;               DIR /S          Equivalent to DIR *.* S
  E355+          ;               DIR /A          Equivalent to DIR *.* A
  E355+          
  E355+          dir:
  E355+CD38E6            call    retsave         ; Save return address and set stack
  E358+          
  E358+          ; See if FCB should be made wild (all '?')
  E358+          
  E358+215D00            ld      hl,fcb1+1       ; Point to file name in FCP
  E35B+7E                ld      a,(hl)          ; Get first character of filename
  E35C+          
  E35C+                   if     slashchk        ; Allow "DIR /S" and "DIR /A" formats
  E35C+FE2F              cp      '/'             ; If name does not start with '/'
  E35E+2008              jr      nz,dir01        ; ..branch and process normally
  E360+23                inc     hl              ; Point to second character
  E361+7E                ld      a,(hl)          ; Get option character after slash
  E362+326D00            ld      (fcb2+1),a      ; ..and put it into second FCB
  E365+2B                dec     hl              ; Back to first character
  E366+3E20              ld      a,' '           ; Simulate empty FCB
  E368+                   endif  ;slashchk
  E368+          
  E368+          dir01:
  E368+060B              ld      b,11            ; Prepare to fill FCB name and type with '?'
  E36A+FE20              cp      ' '             ; See if no file spec given
  E36C+3E3F              ld      a,'?'           ; Get ready to fill with '?'
  E36E+CC9AE6            call    z,fillp         ; ..carry out fill
  E371+          
  E371+                   if     nosys           ; Suppress-SYS-file-if-no-wheel option
  E371+3AFFED            ld      a,(z3whl)       ; Get wheel byte
  E374+B7                or      a
  E375+280E              jr      z,dirnly        ; If wheel off, ignore options
  E377+                   endif
  E377+          
  E377+3A6D00            ld      a,(fcb2+1)      ; Get first char of 2nd file name
  E37A+0601              ld      b,1             ; Set for both dir and sys files
  E37C+FE41              cp      allflag         ; SYS and DIR flag specifier?
  E37E+2807              jr      z,dirpr         ; Got system specifier
  E380+05                dec     b               ; B=0 for sys files only
  E381+FE53              cp      sysflag         ; SYS only?
  E383+2802              jr      z,dirpr
  E385+          
ZAS Relocating Macro Assembler (v3.05                             page   61
                                                            
                                                            

  E385+0680      dirnly: ld      b,80h           ; Must be dir-only selection
  E387+          
  E387+          ; DIRECTORY PRINT ROUTINE; ON ENTRY, B REG IS SET AS FOLLOWS:
  E387+          ;       0 FOR ONLY SYSTEM FILES, 80H FOR ONLY DIR FILES, 1 FOR BOTH
  E387+          ;
  E387+          dirpr:
  E387+78                ld      a,b             ; Get systst flag
  E388+CD4BE7            call    getdir          ; Load and sort directory
  E38B+CAD5E6            jp      z,prfnf         ; Print no file message
  E38E+1E04              ld      e,4             ; Count down to 0
  E390+          ;
  E390+          ; ENTRY PRINT LOOP; ON ENTRY, HL PTS TO FILES SELECTED (TERMINATED BY 0)
  E390+          ;       AND E IS ENTRY COUNTER
  E390+          ;
  E390+          dir3:
  E390+7E                ld      a,(hl)          ; Check for done
  E391+B7                or      a
  E392+                   if     dirsp and spaceon
  E392+CA40E6            jp      z,spaexit       ; Show space when done
  E395+                   else
  E395+                  jp      z,exit          ; Exit if done
  E395+                   endif                  ; Dirsp and spaceon
  E395+7B                ld      a,e             ; Get entry counter
  E396+B7                or      a               ; Output <crlf> if 4 entries printed in line
  E397+2006              jr      nz,dir3a        ; Continue
  E399+CD1FE6            call    crlf            ; New line
  E39C+1E04              ld      e,4             ; Reset entry count
  E39E+7B                ld      a,e             ; Get entry count
  E39F+FE04      dir3a   cp      4               ; First entry?
  E3A1+2807              jr      z,dir4
  E3A3+CD0FE6            call    print
  E3A6+          ;
  E3A6+                   if     wide
  E3A6+          ;
  E3A6+2020              db      '  '            ; 2 spaces
  E3A8+7C                db      fence           ; Then fence char
  E3A9+A0                db      ' '+80h         ; Then 1 more space
  E3AA+          ;
  E3AA+                   else
  E3AA+          ;
  E3AA+                  db      ' '             ; Space
  E3AA+                  db      fence+80h       ; Then fence char
  E3AA+          ;
  E3AA+                   endif                  ; Wide
  E3AA+          ;
  E3AA+          dir4:
  E3AA+CDEDE6            call    prfn            ; Print file name
  E3AD+CD9FE6            call    break           ; Check for abort
  E3B0+1D                dec     e               ; Decrement entry counter
  E3B1+18DD              jr      dir3
  E3B3+          
  E3B3+          ; End RCP-DIR.Z80
  E3B3+          
  E3B3                    endif  ;diron
  E3B3           
  E3B3                    if     eraon
ZAS Relocating Macro Assembler (v3.05                             page   62
                                                            
                                                            

  E3B3+                  include rcpera          ; 'ERA' erase command
ZAS Relocating Macro Assembler (v3.05                             page   63
                                                            
                                                            

  E3B3+                  page
  E3B3+          
  E3B3+          ; RCP-ERA.Z80   'ERA' Command
  E3B3+          
  E3B3+          ;=============================================================================
  E3B3+          ;
  E3B3+          ;               E R A S E    C O M M A N D
  E3B3+          ;
  E3B3+          ;=============================================================================
  E3B3+          
  E3B3+          ;Command: ERA
  E3B3+          ;Function:  Erase files
  E3B3+          ;Forms:
  E3B3+          ;       ERA <afn>       Erase Specified files and print their names
  E3B3+          ;       ERA <afn> I     Erase Specified files and print their names, but ask
  E3B3+          ;                               for verification before Erase is done
  E3B3+          
  E3B3+          era:
  E3B3+CD38E6            call    retsave
  E3B6+3A6D00            ld      a,(fcb2+1)      ; Get eraflg if it's there
  E3B9+32D5E3            ld      (eraflg),a      ; Save it as a flag
  E3BC+3E01              ld      a,1             ; Dir files only
  E3BE+CD4BE7            call    getdir          ; Load directory of files
  E3C1+CAD5E6            jp      z,prfnf         ; Abort if no files
  E3C4+          ;
  E3C4+          ; MAIN ERASE LOOP
  E3C4+          ;
  E3C4+          era1:
  E3C4+CD9FE6            call    break           ; See if user wants to stop
  E3C7+E5                push    hl              ; Save ptr to file
  E3C8+CDEDE6            call    prfn            ; Print its name
  E3CB+2226E8            ld      (nxtfile),hl    ; Save ptr to next file
  E3CE+E1                pop     hl              ; Get ptr to this file
  E3CF+CD4EE6            call    rotest          ; Test file pted to by hl for r/o
  E3D2+201B              jr      nz,era3
  E3D5+=         eraflg  equ     $+1             ; Address of flag
  E3D4+3E00              ld      a,0             ; 2nd byte is flag
  E3D6+FE49              cp      'I'             ; Is it an inspect option?
  E3D8+2005              jr      nz,era2         ; Skip prompt if it is not
  E3DA+CD67E6            call    eraq            ; Erase?
  E3DD+2010              jr      nz,era3         ; Skip if not
  E3DF+          era2:
  E3DF+115D00            ld      de,fcb1+1       ; Copy into fcb1
  E3E2+060B              ld      b,11            ; 11 bytes
  E3E4+CDCEE6            call    blkmov
  E3E7+CD8AE6            call    initfcb1        ; Init fcb
  E3EA+0E13              ld      c,19            ; Delete file
  E3EC+CD06CA            call    bdos
  E3EF+          era3:
  E3EF+2A26E8            ld      hl,(nxtfile)    ; Hl pts to next file
  E3F2+7E                ld      a,(hl)          ; Get char
  E3F3+B7                or      a               ; Done?
  E3F4+                   if     erasp and spaceon
  E3F4+CA40E6            jp      z,spaexit
  E3F7+                   else
  E3F7+                  jp      z,exit
ZAS Relocating Macro Assembler (v3.05                             page   64
                                                            
                                                            

  E3F7+                   endif                  ; Erasp and spaceon
  E3F7+CD1FE6            call    crlf            ; New line
  E3FA+18C8              jr      era1
  E3FC+          
  E3FC+          ; End RCP-ERA.Z80
  E3FC+          
  E3FC                    endif  ;eraon
  E3FC           
  E3FC                    if     lton
  E3FC+                  include rcplt           ; 'LIST' and 'TYPE' commands
ZAS Relocating Macro Assembler (v3.05                             page   65
                                                            
                                                            

  E3FC+                  page
  E3FC+          
  E3FC+          ; RCP-LT.Z80
  E3FC+          
  E3FC+          ;=============================================================================
  E3FC+          ;
  E3FC+          ;       L I S T    A N D    T Y P E    C O M M A N D S
  E3FC+          ;
  E3FC+          ;=============================================================================
  E3FC+          
  E3FC+          ;Command: LIST
  E3FC+          ;Function:  Print out specified file on the LST: Device
  E3FC+          ;Forms:
  E3FC+          ;       LIST <afn>      Print file (NO Paging)
  E3FC+          ;Notes:
  E3FC+          ;       The flags which apply to TYPE do not take effect with LIST
  E3FC+          
  E3FC+                   if     liston
  E3FC+          list:
  E3FC+          ;
  E3FC+          ; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
  E3FC+          
  E3FC+          
  E3FC+                  call    retsave
  E3FC+                  ld      a,0ffh          ; Turn on printer flag
  E3FC+                  jr      type0
  E3FC+                   endif  ;liston
  E3FC+          
  E3FC+          ;Command: TYPE
  E3FC+          ;Function:  Print out specified file on the CON: Device
  E3FC+          ;Forms:
  E3FC+          ;       TYPE <afn>      Print file
  E3FC+          ;       TYPE <afn> P    Print file with paging flag
  E3FC+          ;Notes:
  E3FC+          ;       The flag PGDFLG defines the letter which toggles the paging
  E3FC+          ;               facility (P in the forms section above)
  E3FC+          ;       The flag PGDFLT determines if TYPE is to page by default
  E3FC+          ;               (PGDFLT=TRUE if TYPE pages by default); combined with
  E3FC+          ;               PGDFLG, the following events occur --
  E3FC+          ;                       If PGDFLT = TRUE, PGDFLG turns OFF paging
  E3FC+          ;                       If PGDFLT = FALSE, PGDFLG turns ON paging
  E3FC+          ;
  E3FC+          type:
  E3FC+          ;
  E3FC+          ; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
  E3FC+          ;
  E3FC+          ;
  E3FC+CD38E6            call    retsave
  E3FF+AF                xor     a               ; Turn off printer flag
  E400+          ;
  E400+          ; ENTRY POINT FOR CPR LIST FUNCTION (LIST)
  E400+          ;
  E400+          type0:
  E400+                   if     liston
  E400+                  ld      (prflg),a       ; Set flag
  E400+                   endif                  ; Liston
ZAS Relocating Macro Assembler (v3.05                             page   66
                                                            
                                                            

  E400+          
  E400+3A6D00            ld      a,(fcb2+1)      ; Get page flag
  E403+32B0E4            ld      (pgflg),a       ; Save it as a flag
  E406+3E01              ld      a,1             ; Select dir files
  E408+CD4BE7            call    getdir          ; Allow ambiguous files (HL points to buffer)
  E40B+CAD5E6            jp      z,prfnf         ; No files
  E40E+1813              jr      typex2
  E410+          
  E410+                                          ; Entry point for successive files
  E410+          typex:
  E410+2A26E8            ld      hl,(nxtfile)    ; Get ptr to next file
  E413+7E                ld      a,(hl)          ; Any files?
  E414+B7                or      a
  E415+CA43E6            jp      z,exit
  E418+          
  E418+                   if     liston
  E418+                  ld      a,(prflg)       ; Check for list output
  E418+                  or      a               ; 0=type
  E418+                  jr      z,typex1
  E418+                  ld      a,cr            ; Bol on printer
  E418+                  call    lcout
  E418+                  ld      a,ff            ; Form feed the printer
  E418+                  call    lcout
  E418+                  jr      typex2
  E418+                   endif                  ; Liston
  E418+          
  E418+          typex1:
  E418+          ;       LDA     PAGCNT          ; If we've just done so,
  E418+E5                push    hl
  E419+2A14E7            ld      hl,(pagcnt)
  E41C+7E                ld      a,(hl)
  E41D+E1                pop     hl
  E41E+FE16              cp      nlines-2        ; Don't type another
  E420+C4BEE4            call    nz,pagebreak    ; Page break message
  E423+          typex2:
  E423+115D00            ld      de,fcb1+1       ; Copy into fcb1
  E426+060B              ld      b,11            ; 11 bytes
  E428+CDCEE6            call    blkmov
  E42B+2226E8            ld      (nxtfile),hl    ; Set ptr to next file
  E42E+CD8AE6            call    initfcb1        ; Init fcb1
  E431+0E0F              ld      c,15            ; Open file
  E433+CD06CA            call    bdos
  E436+3C                inc     a               ; Set error flag
  E437+CAD5E6            jp      z,prfnf         ; Abort if error
  E43A+          ;       MVI     A,NLINES-2      ; Set line count
  E43A+          ;       STA     PAGCNT
  E43A+2A14E7            ld      hl,(pagcnt)
  E43D+3616              ld      (hl),nlines-2
  E43F+3E0D              ld      a,cr            ; New line
  E441+CD98E4            call    lcout
  E444+3E0A              ld      a,lf
  E446+CD98E4            call    lcout
  E449+018000            ld      bc,080h         ; Set char position and tab count
  E44C+                                          ; (b=0=tab, c=080h=char position)
  E44C+          ;
  E44C+          ;  MAIN LOOP FOR LOADING NEXT BLOCK
ZAS Relocating Macro Assembler (v3.05                             page   67
                                                            
                                                            

  E44C+          ;
  E44C+          type2:
  E44C+79                ld      a,c             ; Get char count
  E44D+FE80              cp      80h
  E44F+3812              jr      c,type3
  E451+          ;       PUSH    H               ; Read next block
  E451+C5                push    bc
  E452+115C00            ld      de,fcb1         ; Pt to fcb
  E455+0E14              ld      c,20            ; Read record
  E457+CD06CA            call    bdos
  E45A+B7                or      a               ; Set flags
  E45B+C1                pop     bc
  E45C+          ;       POP     H
  E45C+20B2              jr      nz,typex        ; End of file?
  E45E+0E00              ld      c,0             ; Set char count
  E460+218000            ld      hl,tbuff        ; Pt to first char
  E463+          ;
  E463+          ;  MAIN LOOP FOR PRINTING CHARS IN TBUFF
  E463+          ;
  E463+          type3:
  E463+7E                ld      a,(hl)          ; Get next char
  E464+E67F              and     7fh             ; Mask out msb
  E466+FE1A              cp      1ah             ; End of file (^z)?
  E468+28A6              jr      z,typex         ; Next file if so
  E46A+          ;
  E46A+          ; OUTPUT CHAR TO CON: OR LST: DEVICE WITH TABULATION
  E46A+          ;
  E46A+FE0D              cp      cr              ; Reset tab count?
  E46C+280E              jr      z,type4
  E46E+FE0A              cp      lf              ; Reset tab count?
  E470+280A              jr      z,type4
  E472+FE09              cp      tab             ; Tab?
  E474+280D              jr      z,type5
  E476+          ;
  E476+          ;  OUTPUT CHAR AND INCREMENT CHAR COUNT
  E476+          ;
  E476+CD98E4            call    lcout           ; Output char
  E479+04                inc     b               ; Increment tab count
  E47A+1812              jr      type6
  E47C+          ;
  E47C+          ;  OUTPUT <CR> OR <LF> AND RESET TAB COUNT
  E47C+          ;
  E47C+          type4:
  E47C+CD98E4            call    lcout           ; Output <cr> or <lf>
  E47F+0600              ld      b,0             ; Reset tab counter
  E481+180B              jr      type6
  E483+          ;
  E483+          ;  TABULATE
  E483+          ;
  E483+          type5:
  E483+3E20              ld      a,' '           ; <sp>
  E485+CD98E4            call    lcout
  E488+04                inc     b               ; Incr pos count
  E489+78                ld      a,b
  E48A+E607              and     7
  E48C+20F5              jr      nz,type5
ZAS Relocating Macro Assembler (v3.05                             page   68
                                                            
                                                            

  E48E+          ;
  E48E+          ; CONTINUE PROCESSING
  E48E+          ;
  E48E+          type6:
  E48E+0C                inc     c               ; Increment char count
  E48F+23                inc     hl              ; Pt to next char
  E490+CD9FE6            call    break           ; Check for abort
  E493+CA10E4            jp      z,typex         ; Skip
  E496+18B4              jr      type2
  E498+          ;
  E498+          ; SEND OUTPUT TO LST: OR CON:, AS PER THE FLAG
  E498+          ;   RETURN WITH Z IF ABORT
  E498+          ;
  E498+          lcout:
  E498+E5                push    hl              ; Save regs
  E499+C5                push    bc
  E49A+5F                ld      e,a             ; Char in e
  E49B+0E02              ld      c,2             ; Output to con:
  E49D+                   if     liston
  E49D+          prflg   equ     $+1             ; Pointer for in-the-code modification
  E49D+                  ld      a,0             ; 2nd byte is the print flag
  E49D+                  or      a               ; 0=type
  E49D+                  jr      z,lc1
  E49D+                  ld      c,5             ; Output to lst:
  E49D+                   endif                  ; Liston
  E49D+          
  E49D+          lc1:
  E49D+D5                push    de              ; Save char
  E49E+CD06CA            call    bdos            ; Output char in e
  E4A1+D1                pop     de              ; Get char
  E4A2+7B                ld      a,e
  E4A3+FE0A              cp      lf
  E4A5+2014              jr      nz,lc2
  E4A7+                   if     liston
  E4A7+                  ld      a,(prflg)       ; Output to lst:?
  E4A7+                  or      a               ; Nz = yes
  E4A7+                  jr      nz,lc2
  E4A7+                   endif                  ; Liston
  E4A7+          ;
  E4A7+          ; CHECK FOR PAGING
  E4A7+          ;
  E4A7+          ;       LXI     H,PAGCNT        ; Count down
  E4A7+2A14E7            ld      hl,(pagcnt)
  E4AA+35                dec     (hl)
  E4AB+200E              jr      nz,lc2          ; Jump if not end of page
  E4AD+3616              ld      (hl),nlines-2   ; Refill counter
  E4B0+=         pgflg   equ     $+1             ; Pointer to in-the-code buffer
  E4AF+3E00              ld      a,0             ; 2nd byte is the paging flag
  E4B1+FE50              cp      pgdflg          ; Page default override option wanted?
  E4B3+          ;
  E4B3+                   if     pgdflt          ; If paging is default
  E4B3+          ;
  E4B3+2806              jr      z,lc2           ; Pgdflg means no paging
  E4B5+          ;
  E4B5+                   else
  E4B5+          ;
ZAS Relocating Macro Assembler (v3.05                             page   69
                                                            
                                                            

  E4B5+                  jr      nz,lc2          ; Pgdflg means page
  E4B5+          ;
  E4B5+                   endif                  ; Pgdflt
  E4B5+          ;
  E4B5+CDBEE4            call    pagebreak       ; Print page break message
  E4B8+CA10E4            jp      z,typex         ; Z to skip
  E4BB+          lc2:
  E4BB+C1                pop     bc              ; Restore regs
  E4BC+E1                pop     hl
  E4BD+C9                ret
  E4BE+          ;
  E4BE+          ; PRINT PAGE BREAK MESSAGE AND GET USER INPUT
  E4BE+          ;   ABORT IF ^C, RZ IF ^X
  E4BE+          ;
  E4BE+          pagebreak:
  E4BE+E5                push    hl              ; Save hl
  E4BF+CD0FE6            call    print
  E4C2+0D0A205479        db      cr,lf,' Typing',' '+80h
  E4CC+215D00            ld      hl,fcb1+1       ; Print file name
  E4CF+CDEDE6            call    prfn
  E4D2+CD47E6            call    dash            ; Print dash
  E4D5+CD25E6            call    conin           ; Get input
  E4D8+E1                pop     hl              ; Restore hl
  E4D9+F5                push    af
  E4DA+CD1FE6            call    crlf            ; New line
  E4DD+F1                pop     af
  E4DE+C3B0E6            jp      break1
  E4E1+          ;
  E4E1+          ; End RCP-LT.Z80
  E4E1+          
  E4E1                    endif  ;lton
  E4E1           
  E4E1                    if     renon
  E4E1                   include rcpren          ; 'REN' rename command
  E4E1                    endif  ;renon
  E4E1           
  E4E1                    if     proton
  E4E1+                  include rcpprot         ; 'PROT' file attribute setting command
ZAS Relocating Macro Assembler (v3.05                             page   70
                                                            
                                                            

  E4E1+                  page
  E4E1+          
  E4E1+          ; RCP-PROT.Z80
  E4E1+          
  E4E1+          ;Section 5F
  E4E1+          ;Command: PROT
  E4E1+          ;Function:  To set the attributes of a file (R/O and SYS)
  E4E1+          ;
  E4E1+          ;Form:
  E4E1+          ;       PROT afn RSI
  E4E1+          ;If either R or S are omitted, the file is made R/W or DIR, resp;
  E4E1+          ;R and S may be in any order.  If I is present, Inspection is enabled.
  E4E1+          
  E4E1+          att:
  E4E1+CD38E6            call    retsave
  E4E4+AF                xor     a               ; Set no inspect
  E4E5+325DE5            ld      (inspect),a
  E4E8+210000            ld      hl,0            ; Set r/o and sys attributes off
  E4EB+116D00            ld      de,fcb2+1       ; Pt to attributes
  E4EE+0603              ld      b,3             ; 3 chars max
  E4F0+          att1:
  E4F0+1A                ld      a,(de)          ; Get char
  E4F1+13                inc     de              ; Pt to next
  E4F2+FE49              cp      'I'             ; Inspect?
  E4F4+280C              jr      z,atti
  E4F6+FE52              cp      'R'             ; Set r/o?
  E4F8+280D              jr      z,attr
  E4FA+FE53              cp      'S'             ; Set sys?
  E4FC+280D              jr      z,atts
  E4FE+          att2:
  E4FE+10F0              djnz    att1
  E500+180D              jr      att3
  E502+          atti:
  E502+325DE5            ld      (inspect),a     ; Set flag
  E505+18F7              jr      att2
  E507+          attr:
  E507+2680              ld      h,80h           ; Set r/o bit
  E509+18F3              jr      att2
  E50B+          atts:
  E50B+2E80              ld      l,80h           ; Set sys bit
  E50D+18EF              jr      att2
  E50F+          att3:
  E50F+2270E5            ld      (fatt),hl       ; Save file attributes
  E512+3E01              ld      a,1             ; Select dir and sys files
  E514+CD4BE7            call    getdir          ; Load directory
  E517+CAD5E6            jp      z,prfnf         ; No file error
  E51A+180B              jr      att5
  E51C+          att4:
  E51C+2A26E8            ld      hl,(nxtfile)    ; Pt to next file
  E51F+7E                ld      a,(hl)          ; End of list?
  E520+B7                or      a
  E521+CA43E6            jp      z,exit
  E524+CD1FE6            call    crlf            ; New line
  E527+          att5:
  E527+CD9FE6            call    break           ; Check for possible abort
  E52A+E5                push    hl              ; Save ptr to current file
ZAS Relocating Macro Assembler (v3.05                             page   71
                                                            
                                                            

  E52B+CDEDE6            call    prfn            ; Print its name
  E52E+2226E8            ld      (nxtfile),hl    ; Save ptr to next file
  E531+CD0FE6            call    print
  E534+2053657420        db      ' Set to R','/'+80h
  E53E+2A70E5            ld      hl,(fatt)       ; Get attributes
  E541+0E57              ld      c,'W'           ; Assume r/w
  E543+7C                ld      a,h             ; Get r/o bit
  E544+B7                or      a
  E545+2802              jr      z,att6
  E547+0E4F              ld      c,'O'           ; Set r/o
  E549+          att6:
  E549+79                ld      a,c             ; Get char
  E54A+CDFEE5            call    conout
  E54D+7D                ld      a,l             ; Get sys flag
  E54E+B7                or      a               ; Set flag
  E54F+280B              jr      z,att7
  E551+CD0FE6            call    print
  E554+20616E6420        db      ' and SY','S'+80h
  E55C+          att7:
  E55D+=         inspect equ     $+1             ; Ptr for in-the-code modification
  E55C+3E00              ld      a,0             ; Get inspect flag
  E55E+B7                or      a               ; Z=no
  E55F+E1                pop     hl              ; Get ptr to current file
  E560+2805              jr      z,att8
  E562+CD72E6            call    eraq1           ; Ask for y/n
  E565+20B5              jr      nz,att4         ; Advance to next file if not y
  E567+          att8:
  E567+115D00            ld      de,fcb1+1       ; Copy into fcb1
  E56A+060B              ld      b,11            ; 11 bytes
  E56C+CDCEE6            call    blkmov
  E570+=         fatt    equ     $+1             ; Ptr for in-the-code modification
  E56F+210000            ld      hl,0            ; Get attributes
  E572+1B                dec     de              ; Pt to sys byte
  E573+1B                dec     de
  E574+7D                ld      a,l             ; Get sys flag
  E575+CD87E5            call    attset          ; Set attribute correctly
  E578+1B                dec     de              ; Pt to r/o byte
  E579+7C                ld      a,h             ; Get r/o flag
  E57A+CD87E5            call    attset
  E57D+115C00            ld      de,fcb1         ; Pt to fcb
  E580+0E1E              ld      c,30            ; Set attributes
  E582+CD06CA            call    bdos
  E585+1895              jr      att4
  E587+          attset:
  E587+B7                or      a               ; 0=clear attribute
  E588+2805              jr      z,attst1
  E58A+1A                ld      a,(de)          ; Get byte
  E58B+F680              or      80h             ; Set attribute
  E58D+12                ld      (de),a
  E58E+C9                ret
  E58F+          attst1:
  E58F+1A                ld      a,(de)          ; Get byte
  E590+E67F              and     7fh             ; Clear attribute
  E592+12                ld      (de),a
  E593+C9                ret
  E594+          ;
ZAS Relocating Macro Assembler (v3.05                             page   72
                                                            
                                                            

  E594+          ; End RCP-PROT.Z80
  E594+          
  E594                    endif  ;proton
  E594           
  E594                    if     cpon
  E594                   include rcpcp           ; 'CP'  file copying command
  E594                    endif  ;cpon
  E594           
  E594                    if     peekon or pokeon or porton
  E594                   include rcpiom          ; 'PEEK', 'POKE', 'PORT' commands
  E594                    endif  ;peekon or pokeon or porton
  E594           
  E594                    if     regon
  E594                   include rcpreg          ; 'REG' register operation commands
  E594                    endif  ;regon
  E594           
  E594                    if     whlon
  E594+                  include rcpwhl          ; 'WHL' and 'WHLQ' commands
ZAS Relocating Macro Assembler (v3.05                             page   73
                                                            
                                                            

  E594+                  page
  E594+          ;
  E594+          ;Section 5K
  E594+          ;Command: WHL/WHLQ
  E594+          ;Function:  Set the Wheel Byte on or off
  E594+          ;
  E594+          ;If WHLQUIET equate is true, then RCP does not report wheel status with WHL
  E594+          ;command.
  E594+          ;
  E594+          ;Form:
  E594+          ;       WHL             -- turn Wheel Byte OFF
  E594+          ;       WHL password    -- turn Wheel Byte ON if password is correct
  E594+          ;                          no change if password is wrong
  E594+          ;       WHLQ            -- find out status of Wheel Byte
  E594+          
  E594+          whl:
  E594+215D00            ld      hl,fcb1+1       ; Pt to first char
  E597+7E                ld      a,(hl)          ; Get it
  E598+FE20              cp      ' '             ; Turn byte off if no password
  E59A+280E              jr      z,whloff
  E59C+11D1E5            ld      de,whlpass
  E59F+0608              ld      b,8             ; Check 8 chars
  E5A1+CD09E8            call    comp            ; Compare
  E5A4+2008              jr      nz,whlmsg1
  E5A6+          
  E5A6+          ; TURN ON WHEEL BYTE
  E5A6+          
  E5A6+3EFF              ld      a,0ffh          ; Turn on wheel byte
  E5A8+1801              jr      whlset
  E5AA+          
  E5AA+          ; TURN OFF WHEEL BYTE
  E5AA+          
  E5AA+          whloff:
  E5AA+AF                xor     a               ; Turn off wheel byte
  E5AB+          whlset:
  E5AB+32FFED            ld      (z3whl),a       ; Set wheel byte and print message
  E5AE+          
  E5AE+          whlmsg1:
  E5AE+                   if     whlquiet
  E5AE+                  ret
  E5AE+                   endif
  E5AE+          
  E5AE+          ; PRINT WHEEL BYTE MESSAGE
  E5AE+          
  E5AE+                   if     [not whlquiet] or whlqon
  E5AE+          
  E5AE+          whlmsg:
  E5AE+CD0FE6            call    print
  E5B1+2057686565        db      ' Wheel Byte',' '+80h
  E5BD+3AFFED            ld      a,(z3whl)       ; Get wheel byte
  E5C0+B7                or      a               ; Zero is off
  E5C1+2806              jr      z,offm
  E5C3+CD0FE6            call    print
  E5C6+4FCE              db      'O','N'+80h
  E5C8+C9                ret
  E5C9+          offm:
ZAS Relocating Macro Assembler (v3.05                             page   74
                                                            
                                                            

  E5C9+CD0FE6            call    print
  E5CC+4F46C6            db      'OF','F'+80h
  E5CF+C9                ret
  E5D0+          
  E5D0+                   endif  ;[not whlquiet] or whlqon
  E5D0+          
  E5D0+          
  E5D0+          ; WHEEL PASSWORD DEFINED FROM SYSRCP.LIB FILE
  E5D0+          
  E5D0+1A                db      'Z'-'@'         ; Leading ^z to block attempt to type rcp file
  E5D1+          whlpass:
  E5D1+                  wpass                   ; Use macro
  E5D1+5359535445                DB      'SYSTEM  '
  E5D9+                          ENDM
  E5D9+          ;
  E5D9+          ; End RCP-WHL.Z80
  E5D9+          
  E5D9                    endif  ;whlon
  E5D9           
  E5D9                    if     echoon
  E5D9                   include rcpecho         ; 'ECHO' command
  E5D9                    endif  ;echoon
  E5D9           
  E5D9+                  include rcpsubs         ; File of subroutines
ZAS Relocating Macro Assembler (v3.05                             page   75
                                                            
                                                            

  E5D9+                  page
  E5D9+          
  E5D9+          ; RCPSUBS.Z80   Subroutines for Z33RCP.Z80
  E5D9+          
  E5D9+          
  E5D9+          ;-----------------------------------------------------------------------------
  E5D9+          
  E5D9+          ; Display decimal digit routines
  E5D9+          
  E5D9+          ;--------------------
  E5D9+          
  E5D9+          ; Display hundreds, tens, and units digits (assumes flag in B has been set)
  E5D9+          
  E5D9+                   if     regon or spaceon
  E5D9+          
  E5D9+          decdsp3:
  E5D9+116400            ld      de,100          ; Display hundreds
  E5DC+CDE9E5            call    decdsp
  E5DF+1E0A              ld      e,10            ; Display tens
  E5E1+CDE9E5            call    decdsp
  E5E4+7D                ld      a,l             ; Get remaining units value
  E5E5+C630              add     '0'             ; Convert to character
  E5E7+1815              jr      conout          ; Print it and return
  E5E9+          
  E5E9+          ;--------------------
  E5E9+          
  E5E9+          ; Routine to print any single digit
  E5E9+          
  E5E9+          ; Actually, this routine displays the value of HL divided by DE and leaves the
  E5E9+          ; remainder in HL.  In computing the character to display, it assumes that the
  E5E9+          ; result of the division will be a decimal digit.  If the result is zero, the
  E5E9+          ; value in the B register, which is the number of digits already printed, is
  E5E9+          ; checked.  If it is zero, a space is printed instead of a leading '0'.  If it
  E5E9+          ; is not zero, the '0' is printed.  Whenever any digit (not a space) is
  E5E9+          ; printed, the value in B is incremented.
  E5E9+          
  E5E9+          decdsp:
  E5E9+0E2F              ld      c,'0'-1         ; Initialize digit count
  E5EB+AF                xor     a               ; Clear carry flag
  E5EC+          
  E5EC+          decdsp1:
  E5EC+0C                inc     c               ; Pre-increment the digit
  E5ED+ED52              sbc     hl,de           ; Subtract DE from HL
  E5EF+30FB              jr      nc,decdsp1
  E5F1+          
  E5F1+19                add     hl,de           ; Add back in to produce remainder
  E5F2+79                ld      a,c             ; Get decimal digit
  E5F3+FE30              cp      '0'             ; Check for leading 0
  E5F5+2005              jr      nz,decdsp2      ; If not 0, proceed to display it
  E5F7+78                ld      a,b             ; Digit printed already?
  E5F8+B7                or      a
  E5F9+3E20              ld      a,' '           ; Possible space for calling routine to print
  E5FB+C8                ret     z               ; If no digit printed, return zero flag set
  E5FC+          decdsp2:
  E5FC+04                inc     b               ; Indicate digit printed
  E5FD+79                ld      a,c             ; Else print real digit
ZAS Relocating Macro Assembler (v3.05                             page   76
                                                            
                                                            

  E5FE+                                          ; Fall through to CONOUT
  E5FE+          
  E5FE+                   endif  ;regon or spaceon
  E5FE+          
  E5FE+          ;-----------------------------------------------------------------------------
  E5FE+          
  E5FE+          ;  Console Output Routine
  E5FE+          
  E5FE+          conout:
  E5FE+                  putreg                  ; Save all register except AF
  E5FE+E5                PUSH    HL              ; Save registers in order
  E5FF+D5                PUSH    DE
  E600+C5                PUSH    BC
  E601+                   ENDM
  E601+F5                push    af              ; Save AF, too
  E602+E67F              and     7fh             ; Mask out MSB
  E604+5F                ld      e,a             ; Transfer character to E
  E605+0E02              ld      c,2             ; BDOS conout function number
  E607+CD06CA            call    bdos
  E60A+F1                pop     af
  E60B+                  getreg                  ; Restore registers
  E60B+C1                POP     BC              ; Restore registers in order
  E60C+D1                POP     DE
  E60D+E1                POP     HL
  E60E+                   ENDM
  E60E+          note:                           ; Use this RET for NOTE command
  E60E+C9                ret
  E60F+          
  E60F+          ;-----------------------------------------------------------------------------
  E60F+          
  E60F+          ; String printing routines
  E60F+          
  E60F+          ;--------------------
  E60F+          
  E60F+          ; Print string following call (terminated with null or character with the
  E60F+          ; high bit set)
  E60F+          
  E60F+          print:
  E60F+E3                ex      (sp),hl         ; Get address
  E610+CD15E6            call    printhl
  E613+E3                ex      (sp),hl         ; Put address
  E614+C9                ret
  E615+          
  E615+          ;--------------------
  E615+          
  E615+          ; Print string pointed to by HL (terminated with null or character with the
  E615+          ; high bit set)
  E615+          
  E615+          printhl:
  E615+7E                ld      a,(hl)          ; Get next character
  E616+23                inc     hl              ; Point to following one
  E617+B7                or      a               ; See if null terminator
  E618+C8                ret     z               ; If so, we are done
  E619+CDFEE5            call    conout          ; Display the character
  E61C+F8                ret     m               ; We are done if MSB is set (negative number)
  E61D+18F6              jr      printhl         ; Back for more
ZAS Relocating Macro Assembler (v3.05                             page   77
                                                            
                                                            

  E61F+          
  E61F+          ;-----------------------------------------------------------------------------
  E61F+          
  E61F+          ;  OUTPUT NEW LINE TO CON:
  E61F+          
  E61F+          crlf:
  E61F+CD0FE6            call    print
  E622+0D8A              db      cr,lf+80h
  E624+C9                ret
  E625+          
  E625+          ; CONSOLE INPUT
  E625+          
  E625+                   if     eraon or lton or proton or renon or cpon
  E625+          
  E625+          conin:
  E625+E5                push    hl              ; Save regs
  E626+D5                push    de
  E627+C5                push    bc
  E628+0E01              ld      c,1             ; Input
  E62A+CD06CA            call    bdos
  E62D+C1                pop     bc              ; Get regs
  E62E+D1                pop     de
  E62F+E1                pop     hl
  E630+E67F              and     7fh             ; Mask msb
  E632+FE61              cp      61h
  E634+D8                ret     c
  E635+E65F              and     5fh             ; To upper case
  E637+C9                ret
  E638+          
  E638+                   endif                  ; Eraon or lton or proton or renon or cpon
  E638+          
  E638+          ; SAVE RETURN ADDRESS
  E638+          
  E638+          retsave:
  E638+D1                pop     de              ; Get return address
  E639+E1                pop     hl              ; Get return address to zcpr3
  E63A+2244E6            ld      (z3ret),hl      ; Save it
  E63D+E5                push    hl              ; Put return address to zcpr3 back
  E63E+D5                push    de              ; Put return address back
  E63F+C9                ret
  E640+          
  E640+                   if     spaceon and [dirsp or cpsp or erasp]
  E640+          spaexit:
  E640+CDD5E2            call    crspace         ; Show space remaining
  E643+                   endif                  ; Spaceon and [dirsp or cpsp or erasp]
  E643+          
  E643+          ; EXIT TO ZCPR3
  E643+          
  E643+          exit:
  E644+=         z3ret   equ     $+1             ; Pointer to in-the-code modification
  E643+210000            ld      hl,0            ; Return address
  E646+E9                jp      (hl)            ; Goto zcpr3
  E647+          
  E647+          
  E647+          ; PRINT A DASH
  E647+          
ZAS Relocating Macro Assembler (v3.05                             page   78
                                                            
                                                            

  E647+                   if     lton or peekon
  E647+          dash:
  E647+CD0FE6            call    print
  E64A+202DA0            db      ' -',' '+80h
  E64D+C9                ret
  E64E+          
  E64E+                   endif                  ; Lton or peekon
  E64E+          
  E64E+          ; PRINT ADDRESS MESSAGE
  E64E+          ;   PRINT ADDRESS IN DE
  E64E+          
  E64E+                   if     peekon or pokeon
  E64E+                   if     not pokeq
  E64E+          adrat:
  E64E+                  call    print
  E64E+                  db      ' at',' '+80h
  E64E+                  ld      a,d             ; Print high
  E64E+                  call    pahc
  E64E+                  ld      a,e             ; Print low
  E64E+                  jp      pahc
  E64E+          
  E64E+                   endif                  ; Not pokeq
  E64E+                   endif                  ; Peekon or pokeon
  E64E+          
  E64E+          ; EXTRACT HEXADECIMAL NUMBER FROM LINE PTED TO BY HL
  E64E+          ;   RETURN WITH VALUE IN DE AND HL PTING TO OFFENDING CHAR
  E64E+          
  E64E+                   if     peekon or pokeon or porton
  E64E+          
  E64E+          hexnum:
  E64E+                  ld      de,0            ; De=accumulated value
  E64E+                  ld      b,5             ; B=char count
  E64E+          hnum1:
  E64E+                  ld      a,(hl)          ; Get char
  E64E+                  cp      ' '+1           ; Done?
  E64E+                  ret     c               ; Return if space or less
  E64E+                  inc     hl              ; Pt to next
  E64E+                  sub     '0'             ; Convert to binary
  E64E+                  jr      c,numerr        ; Return and done if error
  E64E+                  cp      10              ; 0-9?
  E64E+                  jr      c,hnum2
  E64E+                  sub     7               ; A-f?
  E64E+                  cp      10h             ; Error?
  E64E+                  jr      nc,numerr
  E64E+          hnum2:
  E64E+                  ld      c,a             ; Digit in c
  E64E+                  ld      a,d             ; Get accumulated value
  E64E+                  rlca                    ; Exchange nybbles
  E64E+                  rlca
  E64E+                  rlca
  E64E+                  rlca
  E64E+                  and     0f0h            ; Mask out low nybble
  E64E+                  ld      d,a
  E64E+                  ld      a,e             ; Switch low-order nybbles
  E64E+                  rlca
  E64E+                  rlca
ZAS Relocating Macro Assembler (v3.05                             page   79
                                                            
                                                            

  E64E+                  rlca
  E64E+                  rlca
  E64E+                  ld      e,a             ; High nybble of e=new high of e,
  E64E+                                          ; Low nybble of e=new low of d
  E64E+                  and     0fh             ; Get new low of d
  E64E+                  or      d               ; Mask in high of d
  E64E+                  ld      d,a             ; New high byte in d
  E64E+                  ld      a,e
  E64E+                  and     0f0h            ; Mask out low of e
  E64E+                  or      c               ; Mask in new low
  E64E+                  ld      e,a             ; New low byte in e
  E64E+                  djnz    hnum1           ; Count down
  E64E+                  ret
  E64E+          
  E64E+          ; NUMBER ERROR
  E64E+          
  E64E+          numerr:
  E64E+                  call    print
  E64E+                  db      ' Num','?'+80h
  E64E+                  jp      exit
  E64E+          
  E64E+          ; SKIP TO NEXT NON-BLANK
  E64E+          
  E64E+          sksp:
  E64E+                  ld      a,(hl)          ; Get char
  E64E+                  inc     hl              ; Pt to next
  E64E+                  cp      ' '             ; Skip spaces
  E64E+                  jr      z,sksp
  E64E+                  dec     hl              ; Pt to good char
  E64E+                  or      a               ; Set eol flag
  E64E+                  ret
  E64E+          
  E64E+                   endif                  ; Peekon or pokeon or porton
  E64E+          
  E64E+          ;-----------------------------------------------------------------------------
  E64E+          
  E64E+          ; Test File in FCB for unambiguity and existence, ask user to delete if so
  E64E+          ;   Return with Z flag set if R/O or no permission to delete
  E64E+          
  E64E+                   if     renon or cpon
  E64E+          extest:
  E64E+                  call    ambchk          ; Ambiguous file names not allowed
  E64E+                  call    searf           ; Look for specified file
  E64E+                  jr      z,exok          ; Ok if not found
  E64E+                  call    getsbit         ; Position into dir
  E64E+                  inc     de              ; Pt to file name
  E64E+                  ex      de,hl           ; Hl pts to file name
  E64E+                  push    hl              ; Save ptr to file name
  E64E+                  call    prfn            ; Print file name
  E64E+                  pop     hl
  E64E+                  call    rotest          ; Check for r/o
  E64E+                  jr      nz,exer
  E64E+                  call    eraq            ; Erase?
  E64E+                  jr      nz,exer         ; Restart as error if no
  E64E+                  ld      de,fcb1         ; Pt to fcb1
  E64E+                  ld      c,19            ; Delete file
ZAS Relocating Macro Assembler (v3.05                             page   80
                                                            
                                                            

  E64E+                  call    bdos
  E64E+          exok:
  E64E+                  xor     a
  E64E+                  dec     a               ; Nz = ok
  E64E+                  ret
  E64E+          exer:
  E64E+                  xor     a               ; Error flag - file is r/o or no permission
  E64E+                  ret
  E64E+          
  E64E+          
  E64E+          ; CHECK FOR AMBIGUOUS FILE NAME IN FCB1
  E64E+          ;   RETURN Z IF SO
  E64E+          
  E64E+          ambchk:
  E64E+                  ld      hl,fcb1+1       ; Pt to fcb
  E64E+          
  E64E+          ; CHECK FOR AMBIGUOUS FILE NAME PTED TO BY HL
  E64E+          
  E64E+          ambchk1:
  E64E+                  push    hl
  E64E+                  ld      b,11            ; 11 bytes
  E64E+          amb1:
  E64E+                  ld      a,(hl)          ; Get char
  E64E+                  and     7fh             ; Mask
  E64E+                  cp      '?'
  E64E+                  jr      z,amb2
  E64E+                  inc     hl              ; Pt to next
  E64E+                  djnz    amb1
  E64E+                  dec     b               ; Set nz flag
  E64E+                  pop     de
  E64E+                  ret
  E64E+          amb2:
  E64E+                  pop     hl              ; Pt to file name
  E64E+                  call    prfn
  E64E+                  call    print
  E64E+                  db      ' is AF','N'+80h
  E64E+                  jp      exit
  E64E+          
  E64E+                   endif                  ; Renon or cpon
  E64E+          
  E64E+          ; TEST FILE PTED TO BY HL FOR R/O
  E64E+          ;       NZ IF R/O
  E64E+          
  E64E+                   if     renon or cpon or eraon
  E64E+          
  E64E+          rotest:
  E64E+E5                push    hl              ; Advance to r/o byte
  E64F+010800            ld      bc,8            ; Pt to 9th byte
  E652+09                add     hl,bc
  E653+7E                ld      a,(hl)          ; Get it
  E654+E680              and     80h             ; Mask bit
  E656+F5                push    af
  E657+2160E6            ld      hl,romsg
  E65A+C415E6            call    nz,printhl      ; Print if nz
  E65D+F1                pop     af              ; Get flag
  E65E+E1                pop     hl              ; Get ptr
ZAS Relocating Macro Assembler (v3.05                             page   81
                                                            
                                                            

  E65F+C9                ret
  E660+          romsg:
  E660+2069732052        db      ' is R/','O'+80h
  E667+          
  E667+          ;  CHECK USER TO SEE IF HE APPROVES ERASE OF FILE
  E667+          ;       RETURN WITH Z IF YES
  E667+          
  E667+          eraq:
  E667+CD0FE6            call    print
  E66A+202D204572        db      ' - Eras','e'+80h
  E672+                   endif                  ; Renon or cpon or eraon
  E672+          
  E672+                   if     renon or cpon or eraon or proton
  E672+          eraq1:
  E672+CD0FE6            call    print
  E675+2028592F4E        db      ' (Y/N/Q)?',' '+80h
  E67F+CD25E6            call    conin           ; Get response
  E682+FE51              cp      'Q'             ; Quit command?
  E684+CA43E6            jp      z,exit
  E687+FE59              cp      'Y'             ; Key on yes
  E689+C9                ret
  E68A+          
  E68A+                   endif                  ; Renon or cpon or eraon or proton
  E68A+          
  E68A+          ; INIT FCB1, RETURN WITH DE PTING TO FCB1
  E68A+          
  E68A+                   if     eraon or lton or cpon
  E68A+          initfcb1:
  E68A+215C00            ld      hl,fcb1         ; Pt to fcb
  E68D+          initfcb2:
  E68D+E5                push    hl              ; Save ptr
  E68E+010C00            ld      bc,12           ; Pt to first byte
  E691+09                add     hl,bc
  E692+0618              ld      b,24            ; Zero 24 bytes
  E694+AF                xor     a               ; Zero fill
  E695+CD9AE6            call    fillp           ; Fill memory
  E698+D1                pop     de              ; Pt to fcb
  E699+C9                ret
  E69A+          
  E69A+                   endif                  ; Eraon or lton or cpon
  E69A+          
  E69A+                   if     eraon or lton or cpon or diron
  E69A+          
  E69A+          fillp:
  E69A+77                ld      (hl),a          ; Store byte
  E69B+23                inc     hl              ; Pt to next
  E69C+10FC              djnz    fillp           ; Count down
  E69E+C9                ret
  E69F+          
  E69F+                   endif                  ; Eraon or lton or cpon or diron
  E69F+          
  E69F+          
  E69F+          ;  CHECK FOR USER INPUT; IF ^C, RETURN WITH Z
  E69F+          
  E69F+                   if     diron or lton or eraon or proton or peekon
  E69F+          
ZAS Relocating Macro Assembler (v3.05                             page   82
                                                            
                                                            

  E69F+          break:
  E69F+E5                push    hl              ; Save regs
  E6A0+D5                push    de
  E6A1+C5                push    bc
  E6A2+0E0B              ld      c,11            ; Console status check
  E6A4+CD06CA            call    bdos
  E6A7+B7                or      a
  E6A8+0E01              ld      c,1             ; Get char if any
  E6AA+C406CA            call    nz,bdos
  E6AD+C1                pop     bc              ; Restore regs
  E6AE+D1                pop     de
  E6AF+E1                pop     hl
  E6B0+FE03      break1: cp      ctrlc           ; Check for abort
  E6B2+CA43E6            jp      z,exit          ; Exit
  E6B5+FE18              cp      ctrlx           ; Skip?
  E6B7+C9                ret
  E6B8+                   endif                  ; Diron or lton or eraon or proton or peekon
  E6B8+          
  E6B8+          ; AFTER A SEARCH, RETURN NZ SET IF DESIRED TYPE OF FILE FOUND, Z IF NOT
  E6B8+          ;   THIS ALGORITHM LOOKS AT THE SYSTEM BIT OF THE LOCATED FILE; THIS
  E6B8+          ;   BIT IS SET TO 1 IF THE FILE IS A SYSTEM FILE AND 0 IF NOT A SYSTEM
  E6B8+          ;   FILE.  THE FOLLOWING EXCLUSIVE OR MASKS ARE APPLIED TO RETURN Z OR NZ
  E6B8+          ;   AS REQUIRED BY THE CALLING PROGRAM:
  E6B8+          ;
  E6B8+          ;       SYSTEM BYTE: X 0 0 0  0 0 0 0   (AFTER 80H MASK, X=1 IF SYS, 0 IF DIR)
  E6B8+          ;
  E6B8+          ;       SYS-ONLY   : 0 0 0 0  0 0 0 0   (XOR 0 = 0 if X=0, = 80H if X=1)
  E6B8+          ;       DIR-ONLY   : 1 0 0 0  0 0 0 0   (XOR 80H = 80h if X=0, = 0 if X=1)
  E6B8+          ;       BOTH       : 0 0 0 0  0 0 0 1   (XOR 1 = 81H or 1H, NZ in both cases)
  E6B8+          
  E6B8+                   if     diron or eraon or lton or proton or cpon or renon
  E6B8+          
  E6B8+          getsbit:
  E6B8+3D                dec     a               ; Adjust to returned value
  E6B9+0F                rrca                    ; Convert number to offset into tbuff
  E6BA+0F                rrca
  E6BB+0F                rrca
  E6BC+E660              and     60h
  E6BE+118000            ld      de,tbuff        ; Pt to buffer
  E6C1+83                add     a,e             ; Add entry offset to base addr
  E6C2+5F                ld      e,a             ; Result in e
  E6C3+D5                push    de              ; Save ptr in de
  E6C4+C60A              add     10              ; Add offset of 10 to pt to system byte
  E6C6+5F                ld      e,a             ; Set address
  E6C7+1A                ld      a,(de)          ; Get byte
  E6C8+D1                pop     de              ; Get ptr in de
  E6C9+E680              and     80h             ; Look at only system bit
  E6CC+=         systst  equ     $+1             ; In-the-code variable
  E6CB+EE00              xor     0               ; If systst=0, sys only; if systst=80h, dir
  E6CD+                                          ; Only; if systst=1, both sys and dir
  E6CD+C9                ret                     ; Nz if ok, z if not ok
  E6CE+          
  E6CE+          
  E6CE+          ; COPY HL TO DE FOR B BYTES
  E6CE+          
  E6CE+          blkmov:
ZAS Relocating Macro Assembler (v3.05                             page   83
                                                            
                                                            

  E6CE+7E                ld      a,(hl)          ; Get
  E6CF+12                ld      (de),a          ; Put
  E6D0+23                inc     hl              ; Pt to next
  E6D1+13                inc     de
  E6D2+10FA              djnz    blkmov          ; Loop
  E6D4+C9                ret
  E6D5+          
  E6D5+          
  E6D5+          ;  PRINT FILE NOT FOUND MESSAGE
  E6D5+          
  E6D5+          prfnf:
  E6D5+CD0FE6            call    print
  E6D8+204E6F2046        db      ' No File','s'+80h
  E6E1+C343E6            jp      exit
  E6E4+          
  E6E4+          ; LOG INTO USER AREA CONTAINED IN FCB1
  E6E4+          
  E6E4+          logusr:
  E6E4+3A6900            ld      a,(fcb1+13)     ; Get user number
  E6E7+          setusr:
  E6E7+5F                ld      e,a
  E6E8+0E20              ld      c,32            ; Use bdos fct
  E6EA+C306CA            jp      bdos
  E6ED+          
  E6ED+          
  E6ED+          ;  PRINT FILE NAME PTED TO BY HL
  E6ED+          
  E6ED+          prfn:
  E6ED+CD0FE6            call    print           ; Leading space
  E6F0+A0                db      ' '+80h
  E6F1+0608              ld      b,8             ; 8 chars
  E6F3+CDFCE6            call    prfn1
  E6F6+CD0FE6            call    print
  E6F9+AE                db      '.'+80h         ; Dot
  E6FA+0603              ld      b,3             ; 3 chars
  E6FC+          prfn1:
  E6FC+7E                ld      a,(hl)          ; Get char
  E6FD+23                inc     hl              ; Pt to next
  E6FE+CDFEE5            call    conout          ; Print char
  E701+10F9              djnz    prfn1           ; Count down
  E703+C9                ret
  E704+          
  E704+          
  E704+          ; SEARCH FOR FIRST
  E704+          
  E704+          searf:
  E704+C5                push    bc              ; Save counter
  E705+E5                push    hl              ; Save hl
  E706+0E11              ld      c,17            ; Search for first function
  E708+          searf1:
  E708+115C00            ld      de,fcb1         ; Pt to fcb
  E70B+CD06CA            call    bdos
  E70E+3C                inc     a               ; Set zero flag for error return
  E70F+E1                pop     hl              ; Get hl
  E710+C1                pop     bc              ; Get counter
  E711+C9                ret
ZAS Relocating Macro Assembler (v3.05                             page   84
                                                            
                                                            

  E712+          
  E712+                   endif                  ; Diron or eraon or lton or proton or cpon or renon
  E712+          
  E712+          ;-----------------------------------------------------------------------------
  E712+          
  E712+          ; Define buffers as high as possible in TPA for the following groups
  E712+          ; of commands:
  E712+          ;       COPY                            needs SRCFCB and CBUFF
  E712+          ;       LIST/TYPE                       needs PAGCNT and DIRBUF
  E712+          ;       ERA, PROT, and DIR commands.    needs DIRBUF
  E712+          ; If DIRBUF is defined, its value is in HL on return from this code.  The DE
  E712+          ; register pair is not changed by the code, but the BC pair is affected.
  E712+          
  FFFF+=         dirbufon equ    lton or diron or eraon or proton
  E712+          
  E712+                   if     dirbufon
  E712+0000      dirbuf: ds      2               ; Address for directory buffer
  E714+                   endif  ;dirbufon
  E714+          
  E714+                   if     cpon
  E714+          srcfcb: ds      2               ; Address of source file FCB (CBUFF address
  E714+                                          ; ..is in the code)
  E714+                   endif  ;cpon
  E714+          
  E714+                   if     lton
  E714+0000      pagcnt: ds      2               ; Address for page counter
  E716+                   endif  ;lton
  E716+          
  E716+          
  E716+                   if     cpon or lton or eraon or proton or diron
  E716+          
  E716+          define:
  E716+D5                push    de
  E717+2A07CA            ld      hl,(bdos+1)     ; Get bottom of BDOS
  E71A+EB                ex      de,hl           ; ..into DE
  E71B+2A0100            ld      hl,(1)          ; Get BIOS warmboot address into HL
  E71E+01FDE9            ld      bc,-[0e00h+800h+3] ; Offset to command processor address
  E721+09                add     hl,bc
  E722+          
  E722+          ; Now we have to compare and pick the lower address as the top of TPA
  E722+          
  E722+E5                push    hl              ; Save CPR address while comparing
  E723+AF                xor     a               ; Clear the carry flag
  E724+ED52              sbc     hl,de           ; Compute (CPR-BDOS)
  E726+E1                pop     hl              ; Restore CPR address
  E727+3801              jr      c,define1       ; Branch if BDOS address is higher (use CPR)
  E729+EB                ex      de,hl           ; Otherwise use BDOS address
  E72A+          define1:
  E72A+          
  E72A+                   if     lton
  E72A+2B                dec     hl              ; Put PAGCNT in first free byte at top of TPA
  E72B+2214E7            ld      (pagcnt),hl
  E72E+                   endif  ;lton
  E72E+          
  E72E+                   if     cpon
  E72E+                  ld      de,-36          ; Calculate place for SRCFCB for copy command
ZAS Relocating Macro Assembler (v3.05                             page   85
                                                            
                                                            

  E72E+                  add     hl,de
  E72E+                  ld      (srcfcb),hl
  E72E+                    if    dirbufon
  E72E+                  push    hl              ; Save if needed below
  E72E+                    endif ;dirbufon
  E72E+                  ld      de,-[cpblocks*128] ; CBUFF can use same space as DIRBUF
  E72E+                  add     hl,de
  E72E+                  ld      (cbuff),hl
  E72E+                    if    dirbufon
  E72E+                  pop     hl
  E72E+                    endif ;dirbufon
  E72E+                   endif  ;cpon
  E72E+          
  E72E+                   if     dirbufon
  E72E+1100F5            ld      de,-[maxdirs*11] ; Space for directory buffer
  E731+19                add     hl,de
  E732+2212E7            ld      (dirbuf),hl
  E735+                   endif
  E735+          
  E735+D1                pop     de
  E736+C9                ret
  E737+          
  E737+                   endif  ;cpon or dirbufon
  E737+          
  E737+          ;-----------------------------------------------------------------------------
  E737+          
  E737+          ; SEARCH FOR NEXT
  E737+          
  E737+                   if     diron or eraon or lton or proton
  E737+          
  E737+          searn:
  E737+C5                push    bc              ; Save counter
  E738+E5                push    hl              ; Save hl
  E739+0E12              ld      c,18            ; Search for next function
  E73B+18CB              jr      searf1
  E73D+          
  E73D+          ; LOAD DIRECTORY AND SORT IT
  E73D+          ;   ON INPUT, A=SYSTST FLAG (0=SYS, 1=DIR, 80H=BOTH)
  E73D+          ;   DIRECTORY IS LOADED INTO BUFFER AT TOP OF TPA
  E73D+          ;   RETURN WITH ZERO SET IF NO MATCH AND HL PTS TO 1ST ENTRY IF MATCH
  E73D+          
  E73D+          direrr:
  E73D+CD0FE6            call    print
  E740+444952204F        db      'DIR Ovf','l'+80h
  E748+C343E6            jp      exit
  E74B+          
  E74B+          getdir:
  E74B+32CCE6            ld      (systst),a      ; Set system test flag
  E74E+CDE4E6            call    logusr          ; Log into user area of fcb1
  E751+          
  E751+CD16E7            call    define          ; Define buffer addresses
  E754+3600              ld      (hl),0          ; Set empty
  E756+010000            ld      bc,0            ; Set counter
  E759+CD04E7            call    searf           ; Look for match
  E75C+C8                ret     z               ; Return if not found
  E75D+          
ZAS Relocating Macro Assembler (v3.05                             page   86
                                                            
                                                            

  E75D+          ;  STEP 1:  LOAD DIRECTORY
  E75D+          
  E75D+          gd1:
  E75D+C5                push    bc              ; Save counter
  E75E+CDB8E6            call    getsbit         ; Check for system ok
  E761+C1                pop     bc
  E762+2816              jr      z,gd2           ; Not ok, so skip
  E764+C5                push    bc              ; Save counter
  E765+13                inc     de              ; Pt to file name
  E766+EB                ex      de,hl           ; Hl pts to file name, de pts to buffer
  E767+060B              ld      b,11            ; Copy 11 bytes
  E769+CDCEE6            call    blkmov          ; Do copy
  E76C+C1                pop     bc              ; Get counter
  E76D+03                inc     bc              ; Increment counter
  E76E+21FF00            ld      hl,maxdirs-1    ; See if count equals or exceeds MAXDIRS
  E771+78                ld      a,b             ; Check high bytes
  E772+94                sub     a,h
  E773+3804              jr      c,gd1a          ; If carry set, we are OK
  E775+79                ld      a,c             ; Check low bytes
  E776+95                sub     a,l
  E777+30C4              jr      nc,direrr       ; If no carry, jump to error message
  E779+          gd1a:
  E779+EB                ex      de,hl           ; Hl pts to next buffer location
  E77A+          gd2:
  E77A+CD37E7            call    searn           ; Look for next
  E77D+20DE              jr      nz,gd1
  E77F+3600              ld      (hl),0          ; Store ending 0
  E781+2A12E7            ld      hl,(dirbuf)     ; Pt to dir buffer
  E784+7E                ld      a,(hl)          ; Check for empty
  E785+B7                or      a
  E786+C8                ret     z
  E787+          
  E787+          ;  STEP 2:  SORT DIRECTORY
  E787+          
  E787+E5                push    hl              ; Save ptr to dirbuf for return
  E788+CD8FE7            call    diralpha        ; Sort
  E78B+E1                pop     hl
  E78C+AF                xor     a               ; Set nz flag for ok
  E78D+3D                dec     a
  E78E+C9                ret
  E78F+          
  E78F+          
  E78F+          ;  DIRALPHA -- ALPHABETIZES DIRECTORY IN DIRBUF; BC CONTAINS
  E78F+          ;       THE NUMBER OF FILES IN THE DIRECTORY
  E78F+          
  E78F+          diralpha:
  E78F+          
  E78F+          ;  SHELL SORT --
  E78F+          ;    THIS SORT ROUTINE IS ADAPTED FROM "SOFTWARE TOOLS"
  E78F+          ;    BY KERNIGAN AND PLAUGHER, PAGE 106.  COPYRIGHT, 1976, ADDISON-WESLEY.
  E78F+          
  E78F+60                ld      h,b             ; Hl=bc=file count
  E790+69                ld      l,c
  E791+22B2E7            ld      (n),hl          ; Set "N"
  E794+2299E7            ld      (gap),hl        ; Set initial gap to n for first division by 2
  E797+          
ZAS Relocating Macro Assembler (v3.05                             page   87
                                                            
                                                            

  E797+          ;  FOR (GAP = N/2; GAP > 0; GAP = GAP/2)
  E797+          srtl0:
  E797+B7                or      a               ; Clear carry
  E799+=         gap     equ     $+1             ; Pointer for in-the-code modification
  E798+210000            ld      hl,0            ; Get previous gap
  E79B+7C                ld      a,h             ; Rotate right to divide by 2
  E79C+1F                rra
  E79D+67                ld      h,a
  E79E+7D                ld      a,l
  E79F+1F                rra
  E7A0+6F                ld      l,a
  E7A1+          
  E7A1+          ;  TEST FOR ZERO
  E7A1+B4                or      h
  E7A2+C8                ret     z               ; Done with sort if gap = 0
  E7A3+          
  E7A3+2299E7            ld      (gap),hl        ; Set value of gap
  E7A6+22AAE7            ld      (ii),hl         ; Set ii=gap for following loop
  E7A9+          
  E7A9+          ;  FOR (II = GAP + 1; II <= N; II = II + 1)
  E7A9+          srtl1:
  E7AA+=         ii      equ     $+1             ; Pointer for in-the-code modification
  E7A9+210000            ld      hl,0            ; Add 1 to ii
  E7AC+23                inc     hl
  E7AD+22AAE7            ld      (ii),hl
  E7B0+          
  E7B0+          ;  TEST FOR II <= N
  E7B0+EB                ex      de,hl           ; Ii is in de
  E7B2+=         n       equ     $+1             ; Pointer for in-the-code modification
  E7B1+210000            ld      hl,0            ; Number of items to sort
  E7B4+7D                ld      a,l             ; Compare by subtraction
  E7B5+93                sub     a,e
  E7B6+7C                ld      a,h
  E7B7+9A                sbc     a,d             ; Carry set means ii > n
  E7B8+38DD              jr      c,srtl0         ; Don't do for loop if ii > n
  E7BA+          
  E7BA+EB                ex      de,hl           ; Set jj = ii initially for first subtraction of gap
  E7BB+22C3E7            ld      (jj),hl
  E7BE+          
  E7BE+          ;  FOR (JJ = II - GAP; JJ > 0; JJ = JJ - GAP)
  E7BE+          srtl2:
  E7BE+2A99E7            ld      hl,(gap)        ; Get gap
  E7C1+EB                ex      de,hl           ; In de
  E7C3+=         jj      equ     $+1             ; Pointer for in-the-code modification
  E7C2+210000            ld      hl,0            ; Get jj
  E7C5+7D                ld      a,l             ; Compute jj - gap
  E7C6+93                sub     a,e
  E7C7+6F                ld      l,a
  E7C8+7C                ld      a,h
  E7C9+9A                sbc     a,d
  E7CA+67                ld      h,a
  E7CB+22C3E7            ld      (jj),hl         ; Jj = jj - gap
  E7CE+38D9              jr      c,srtl1         ; If carry from subtractions, jj < 0 and abort
  E7D0+B5                or      l               ; Jj=0?
  E7D1+          
  E7D1+28D6              jr      z,srtl1         ; If zero, jj=0 and abort
ZAS Relocating Macro Assembler (v3.05                             page   88
                                                            
                                                            

  E7D3+          
  E7D3+          ;  SET JG = JJ + GAP
  E7D3+EB                ex      de,hl           ; Jj in de
  E7D4+2A99E7            ld      hl,(gap)        ; Get gap
  E7D7+19                add     hl,de           ; Jj + gap
  E7D8+22E5E7            ld      (jg),hl         ; Jg = jj + gap
  E7DB+          
  E7DB+          ;  IF (V(JJ) <= V(JG))
  E7DB+CDFFE7            call    icompare        ; J in de, jg in hl
  E7DE+          
  E7DE+          ;  ... THEN BREAK
  E7DE+38C9              jr      c,srtl1
  E7E0+          
  E7E0+          ;  ... ELSE EXCHANGE
  E7E0+2AC3E7            ld      hl,(jj)         ; Swap jj, jg
  E7E3+EB                ex      de,hl
  E7E5+=         jg      equ     $+1             ; Pointer for in-the-code modification
  E7E4+210000            ld      hl,0
  E7E7+CDECE7            call    iswap           ; Jj in de, jg in hl
  E7EA+          
  E7EA+          ;  END OF INNER-MOST FOR LOOP
  E7EA+18D2              jr      srtl2
  E7EC+          
  E7EC+          
  E7EC+          ;  SWAP (Exchange) the elements whose indexes are in HL and DE
  E7EC+          
  E7EC+          iswap:
  E7EC+CD17E8            call    ipos            ; Compute position from index
  E7EF+EB                ex      de,hl
  E7F0+CD17E8            call    ipos            ; Compute 2nd element position from index
  E7F3+060B              ld      b,11            ; 11 bytes to flip
  E7F5+                   endif                  ; Diron or eraon or lton or proton
  E7F5+          
  E7F5+                   if     diron or eraon or lton or proton or renon
  E7F5+          iswap1:
  E7F5+1A                ld      a,(de)          ; Get bytes
  E7F6+4E                ld      c,(hl)
  E7F7+77                ld      (hl),a          ; Put bytes
  E7F8+79                ld      a,c
  E7F9+12                ld      (de),a
  E7FA+23                inc     hl              ; Pt to next
  E7FB+13                inc     de
  E7FC+10F7              djnz    iswap1
  E7FE+C9                ret
  E7FF+                   endif                  ; Diron or eraon or lton or proton or renon
  E7FF+          
  E7FF+                   if     diron or eraon or lton or proton
  E7FF+          
  E7FF+          ;  ICOMPARE compares the entry pointed to by the pointer pointed to by HL
  E7FF+          ;    with that pointed to by DE (1st level indirect addressing); on entry,
  E7FF+          ;    HL and DE contain the numbers of the elements to compare (1, 2, ...);
  E7FF+          ;    on exit, Carry Set means ((DE)) < ((HL)), Zero Set means ((HL)) = ((DE)),
  E7FF+          ;    and Non-Zero and No-Carry means ((DE)) > ((HL))
  E7FF+          
  E7FF+          icompare:
  E7FF+CD17E8            call    ipos            ; Get position of first element
ZAS Relocating Macro Assembler (v3.05                             page   89
                                                            
                                                            

  E802+EB                ex      de,hl
  E803+CD17E8            call    ipos            ; Get position of 2nd element
  E806+EB                ex      de,hl
  E807+          
  E807+          ;  COMPARE DIR ENTRY PTED TO BY HL WITH THAT PTED TO BY DE;
  E807+          ;       NO NET EFFECT ON HL, DE; RET W/CARRY SET MEANS DE<HL
  E807+          ;       RET W/ZERO SET MEANS DE=HL
  E807+          
  E807+                   if     not sortnt      ; Type and name?
  E807+          
  E807+          ;  COMPARE BY FILE TYPE AND FILE NAME
  E807+          
  E807+                  push    hl
  E807+                  push    de
  E807+                  ld      bc,8            ; Pt to ft (8 bytes)
  E807+                  add     hl,bc
  E807+                  ex      de,hl
  E807+                  add     hl,bc
  E807+                  ex      de,hl           ; De, hl now pt to their ft's
  E807+                  ld      b,3             ; 3 bytes
  E807+                  call    comp            ; Compare ft's
  E807+                  pop     de
  E807+                  pop     hl
  E807+                  ret     nz              ; Continue if complete match
  E807+                  ld      b,8             ; 8 bytes
  E807+          ; FALL THROUGH TO COMP
  E807+          
  E807+                   else                   ; Name and type
  E807+          
  E807+          ;  COMPARE BY FILE NAME AND FILE TYPE
  E807+          
  E807+060B              ld      b,11            ; Compare fn, ft and fall thru to comp
  E809+          
  E809+                   endif                  ; Not sortnt
  E809+                   endif                  ; Diron or eraon or lton or proton
  E809+          
  E809+                   if     diron or eraon or lton or proton or cpon or whlon
  E809+          
  E809+          ;  COMP COMPARES DE W/HL FOR B BYTES; RET W/CARRY IF DE<HL
  E809+          ;       MSB IS DISREGARDED
  E809+          
  E809+          comp:
  E809+7E                ld      a,(hl)          ; Get (hl)
  E80A+E67F              and     7fh             ; Mask msb
  E80C+4F                ld      c,a             ; In c
  E80D+1A                ld      a,(de)          ; Compare
  E80E+E67F              and     7fh             ; Mask msb
  E810+B9                cp      c
  E811+C0                ret     nz
  E812+23                inc     hl              ; Pt to next
  E813+13                inc     de
  E814+10F3              djnz    comp            ; Count down
  E816+C9                ret
  E817+          
  E817+                   endif                  ; Diron or eraon or lton or proton or cpon or
  E817+                                          ; whlon
ZAS Relocating Macro Assembler (v3.05                             page   90
                                                            
                                                            

  E817+          
  E817+                   if     diron or eraon or lton or proton
  E817+          
  E817+          ;  Compute physical position of element whose index is in HL; on exit, HL
  E817+          ; is the physical address of this element; Indexes are 1..N
  E817+          
  E817+          ipos:
  E817+2B                dec     hl              ; We want HL=(HL-1)*11+(DIRBUF)
  E818+44                ld      b,h             ; Bc=hl
  E819+4D                ld      c,l
  E81A+29                add     hl,hl           ; Hl=hl*2
  E81B+29                add     hl,hl           ; Hl=hl*4
  E81C+09                add     hl,bc           ; Hl=hl*5
  E81D+29                add     hl,hl           ; Hl=hl*10
  E81E+09                add     hl,bc           ; Hl=hl*11
  E81F+44                ld      b,h             ; Move offset into BC
  E820+4D                ld      c,l
  E821+2A12E7            ld      hl,(dirbuf)
  E824+09                add     hl,bc
  E825+C9                ret
  E826+          
  E826+                   endif                  ; Diron or eraon or lton or proton
  E826+          
  E826+          ; End RCPSUBS.Z80
  E826+          
  E826           
  E826           ;
  E826           ; Date Buffers
  E826           ;
  E826                    if     eraon or lton or proton
  E826           
  E826           nxtfile:
  E826 0000              ds      2               ; Ptr to next file in list
  E828           
  E828                    endif                  ; Eraon or lton or proton
  E828           
  E828                   if      zdsson          ; p2dos datestamper
  E828                    if     STMPP2
  E828                     include p2d
  E828                    endif
  E828                    if     STMPZS
  E828+                    include zds
  E828+          ;       TITLE   "DateStamper (tm) Stamp Module for ZSDOS"
  E828+          ;***************************************************************************
  E828+          ;  Z D S                                                                   *
  E828+          ;--------------------------------------------------------------------------*
  E828+          ; Copyright (C) 1988  by Cameron W. Cotrill and Harold F. Bower            *
  E828+          ;--------------------------------------------------------------------------*
  E828+          ; This module replaces DateStamper V2.30 in ZSDOS systems.  It provides    *
  E828+          ; support for ZSDOS Functions 102 thru 105.  To simplify the tie-ins with  *
  E828+          ; ZSDOS, this module is "Dirty" - It assumes addresses inside of ZSDOS.    *
  E828+          ;                                                                          *
  E828+          ; The loader for this routine needs to place the address of ZSDOS (Page    *
  E828+          ; Boundary) in the offset entry in JTABLE.  All ZSDOS addresses are dynami-*
  E828+          ; cally calculated from this address.  BIOS is assumed to be 0E00H above   *
  E828+          ; ZSDOS, but this may be changed by using the EQUate.                      *
ZAS Relocating Macro Assembler (v3.05                             page   91
                                                            
                                                            

  E828+          ;                                                                          *
  E828+          ; This program may be used only by licensed Plu*Perfect DateStamper Users! *
  E828+          ;       Agreement pending with Plu*Perfect Systems                         *
  E828+          ;                                                                          *
  E828+          ; The author wishes to acknowledge the numerous suggestions and helpful    *
  E828+          ; hints from Bridger Mitchell of Plu*Perfect Systems.                      *
  E828+          ;                                                                          *
  E828+          ; Revision:                                                                *
  E828+          ;       1.0 - Initial Release                                              *
  E828+          ;***************************************************************************
  E828+          
  E828+          ; rsym zsdos.sym
  E828+          
  E828+          ; VER   EQU     12              ; Release Version
  E828+          
  0016+=         TIMOFF  EQU     0016H           ; Time Vector group offset
  0018+=         LSTOFF  EQU     0018H           ; Stamp Last Accessed routine addr
  001A+=         CREOFF  EQU     001AH           ; Stamp Create Time routine addr
  001C+=         MODOFF  EQU     001CH           ; Stamp Modify Time routine addr
  001E+=         GSTOFF  EQU     001EH           ; Get Stamp routine addr
  0020+=         SSTOFF  EQU     0020H           ; Set Stamp routine addr
  E828+          
  003C+=         DPBOF   EQU     003CH           ; Offset to DPB copy inside ZSDOS
  0647+=         GETCDM  EQU     0647H           ; Offset to return current drive bit
  0327+=         MBERR   EQU     0327H           ; Offset to DOS Error Message
  0052+=         RECDIR  EQU     0052H           ; Offset to current DIR record number
  064A+=         SDRVB   EQU     064AH           ; Offset to set drive bit routine
  0677+=         STDIR1  EQU     0677H           ; Offset to ZSDOS set track and sector
  0DF8+=         TDFVCT  EQU     0DF8H           ; Offset to time/date vector in DOS
  04CF+=         ZDPCH1  EQU     04CFH           ; Offset to return version patch
  061D+=         ZDPCH2  EQU     061DH           ; Offset to first INITDR intercept
  0637+=         ZDPCH3  EQU     0637H           ; Offset to second INITDR intercept
  0DEF+=         STMPZO  EQU     0DEFH           ; Offset to patch flag
  E828+          ;----------------------------------------------------------------------
  0E00+=         OFBIOS  EQU     0E00H           ; Offset of BIOS from ZSDOS
  0027+=         RDSECT  EQU     27H             ; Offset in BIOS jump table to Read
  002A+=         WRSECT  EQU     2AH             ; Offset in BIOS jump table to Write
  0024+=         SDMOFF  EQU     24H             ; Offset in BIOS jump table to set DMA
  0091+=         TDVAL   EQU     91H             ; Checksum of !!!TIME&.DAT less attributes
  0022+=         DUMMY   EQU     22H             ; Offset of Disable Vector in ZSDOS
  0024+=         UNLOAD  EQU     24H             ; Offset of UNLOAD address in ZDS from ZSDOS
  0016+=         TBLOFF  EQU     16H             ; Offset of ZSDOS time routine vector table
  D7EF+=         STMPZP  EQU     BDOSB+STMPZO    ; patch flag address
  E828+          
  E838+=         ZDSSBAS EQU     (FCP-ZDSSTSZ)   ; where i am
  E828+          
  E838+                  ORG     ZDSSBAS         ; We are at the top of the RCP area
  E838+          
  E838+C34AE8            JP      STCR            ; jump table to make stuffs easy in zsdos...
  E83B+C34EE8            JP      STUP
  E83E+C36CE8            JP      RSTAMP
  E841+C371E8            JP      WSTAMP
  E844+C352E8            JP      STLA
U E847+                  JP      ZSPTCH
  E847+          
  E847+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ZAS Relocating Macro Assembler (v3.05                             page   92
                                                            
                                                            

  E847+          ;               S t a m p     C r e a t e
  E847+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E847+          
  E847+0600      STCR:   LD      B,00            ; Offset into stamp in B
  E849+1809              JR      STT
  E84B+          
  E84B+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E84B+          ;               S t a m p     U p d a t e
  E84B+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E84B+          
  E84B+060A      STUP:   LD      B,10            ; Offset into stamp in B
  E84D+1805              JR      STT
  E84F+          
  E84F+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E84F+          ;               S t a m p     A c c e s s
  E84F+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E84F+          
  E84F+0605      STLA:   LD      B,05            ; Offset into stamp in B
  E851+CDE3E9    STT:    CALL    CKPTCH          ; check for first call
  E854+32DBE8            LD      (INDEX),A       ; Save index into DIR entry
  E857+2208E9            LD      (STPDMA),HL     ; Save user DMA pointer
  E85A+0E02              LD      C,2             ; Show as stamp
  E85C+2600              LD      H,0
  E85E+C603              ADD     A,3             ; Point to no date attribute
  E860+6F                LD      L,A
  E861+19                ADD     HL,DE           ; Point to DIR entry
  E862+CB7E              BIT     7,(HL)
  E864+3EFF              LD      A,0FFH          ; Prepare error status in case
  E866+          ;       RET     NZ              ; Don't update if no date attrib
  E866+C9                RET                     ; a do nothing return
  E867+1814              JR      STPSV0
  E869+          
  E869+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E869+          ;     G E T / P U T    S t a m p    R o u t i n e s
  E869+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E869+          
  E869+010000    RSTAMP: LD      BC,0            ; Flag as read
  E86C+1806              JR      STPSVC
  E86E+          
  E86E+010100    WSTAMP: LD      BC,1            ; Flag as write
  E871+                                  ; And fall thru...
  E871+          
  E871+          ; Stamp Service Routine (Combined Get Stamp and Put Stamp)
  E871+          ; Calling Parameters:
  E871+          ;       A = Index to DIR Entry [00H,20H,40H,60H]
  E871+          ;       B = Offset in Stamp [0,5,10]
  E871+          ;       C = Function [0 = Read, 1=Write, 2=Update]
  E871+          ;       DE= Pointer to DIR Buffer
  E871+          ;       HL= User DMA Address
  E871+          
  E871+CDE3E9    STPSVC: CALL    CKPTCH          ; check for first call
  E874+32DBE8            LD      (INDEX),A       ; Save index into DIR entry
  E877+2208E9            LD      (STPDMA),HL     ; Save user DMA pointer
  E87A+ED43F8E9  STPSV0: LD      (RWCODE),BC     ; Save read/write code and Sector offset
  E87E+ED5399E8          LD      (SECBUF),DE     ; Check if !!!TIME&.DAT Exists on the drive
  E882+CD55E9            CALL    GETTDV          ; Return current time/date vector in BC
ZAS Relocating Macro Assembler (v3.05                             page   93
                                                            
                                                            

  E885+C5                PUSH    BC              ; Save it
  E886+114706            LD      DE,GETCDM
  E889+CDB3E9            CALL    VECTOR          ; Return vector for current drive in hl
  E88C+          ;==     POP     HL
  E88C+C1                pop     bc              ; [1.1]
  E88D+7C                LD      A,H
  E88E+A0                AND     B
  E88F+67                LD      H,A
  E890+7D                LD      A,L
  E891+A1                AND     C
  E892+B4                OR      H               ; Test if current drive has !!!TIME&.DAT
  E893+286F              JR      Z,SERRO         ; ..jump if it doesn't
  E895+          
  E896+=         SECBUF  EQU     $+1
  E895+010000            LD      BC,0000         ; Store Sector Buffer adr inline
  E898+CDAFE9            CALL    DODMA           ; Set DMA to address sector buffer
  E89B+          
  E89B+          ; It exists, so find first alloc for it (First after DIR)
  E89B+          
  E89B+115200            LD      DE,RECDIR
  E89E+CD58E9            CALL    INDFET          ; Get current dir record
  E8A1+                                          ; Calculate Buffer Offset
  E8A1+AF                XOR     A
  E8A2+CB38              SRL     B
  E8A4+CB19              RR      C               ; Divide record by two, lsb to carry
  E8A6+1F                RRA                     ; Place in msb of a
  E8A7+21DBE8            LD      HL,INDEX
  E8AA+86                ADD     A,(HL)          ; Get offset to stamp in buffer
  E8AB+1F                RRA                     ; Divide by 2 (8 stamps/rec)
  E8AC+77                LD      (HL),A          ; Save index for later
  E8AD+                                          ; Now calculate record number needed
  E8AD+C5                PUSH    BC              ; Save relative record number
  E8AE+114500            LD      DE,DPBOF+9      ; Get dir alloc bitmap from DPB
  E8B1+CD58E9            CALL    INDFET
  E8B4+C5                PUSH    BC              ; Save bitmap
  E8B5+113F00            LD      DE,DPBOF+3      ; Point to block mask in DPB
  E8B8+CD58E9            CALL    INDFET          ; Get into C reg
  E8BB+0C                INC     C               ; Now is number of records per block
  E8BC+AF                XOR     A               ; Cheap zero
  E8BD+59                LD      E,C             ; Records/block to E
  E8BE+57                LD      D,A             ; Sign extend
  E8BF+0610              LD      B,16            ; Check all bits
  E8C1+E1                POP     HL              ; Restore bitmap, rel rec on tos
  E8C2+29        STPSV1: ADD     HL,HL           ; Shift MSB into Carry
  E8C3+3006              JR      NC,STPSV2       ; If bit was a zero
  E8C5+E3                EX      (SP),HL         ; Else get relative record
  E8C6+19                ADD     HL,DE           ; Add records for this dir block
  E8C7+E3                EX      (SP),HL         ; Back to tos
  E8C8+10FB      STPSV2: DJNZ    STPSV1          ; Loop until done
  E8CA+E1                POP     HL              ; now has actual record number
  E8CB+                                          ; Call DSSTS (Set BIOS Track and Sector)
  E8CB+CD40E9            CALL    RDSEC           ; Set Track/Sector and Read
  E8CE+CD35E9            CALL    CKSUM           ; Checksum first 127 bytes of local buffer
  E8D1+BE                CP      (HL)            ; Test against DS's checksum
  E8D2+2030              JR      NZ,SERRO        ; Abort if error
  E8D4+                                          ; Set Pointers for Block Move
ZAS Relocating Macro Assembler (v3.05                             page   94
                                                            
                                                            

  E8D4+AF                XOR     A               ; Clear acc
  E8D5+57                LD      D,A             ; Word value for D
  E8D6+47                LD      B,A             ; And B
  E8D7+          
  E8D8+=         INDEX   EQU     $+1
  E8D7+1E00              LD      E,00            ; INDEX value stored here inline
  E8D9+2A96E8            LD      HL,(SECBUF)
  E8DC+19                ADD     HL,DE           ; Now pointing to correct stamp
  E8DD+0E0F              LD      C,15            ; Size of stamp
  E8DF+ED5B08E9          LD      DE,(STPDMA)     ; Get user stamp pointer
  E8E3+                                          ; Test for Why we're here
  E8E3+3AF8E9            LD      A,(RWCODE)      ; Get Read/Write Code
  E8E6+A7                AND     A               ; Is it get stamp?
  E8E7+2007              JR      NZ,PUTSTP       ; If we're supposed to write
  E8E9+                                          ; Copy Stamp from Local Buff to User DMA
  E8E9+EDB0              LDIR                    ; Move to user DMA
  E8EB+1814              JR      STPSVX          ; ..and exit
  E8ED+          
  E8ED+          ; Copy Stamp from User DMA to Local Buff
  E8ED+          
  E8ED+D602      PUTSTP: SUB     2               ; Is this a simple put?
  E8EF+281E              JR      Z,UPSTMP        ; No, read the clock
  E8F1+EB                EX      DE,HL           ; Swap pointers
  E8F2+EDB0      PUTS1:  LDIR                    ; Move new stamp into place
  E8F4+CD35E9            CALL    CKSUM           ; Checksum first 127 bytes of local buffer
  E8F7+77                LD      (HL),A          ; ..and save checksum in last byte of record
  E8F8+          
  E8F8+1E2A              LD      E,WRSECT        ; Do BIOS Write Sector
  E8FA+0C                INC     C               ; ..Flag as non-deferred (0 from ldir -> 01)
  E8FB+CD4DE9            CALL    DOBIOSE         ; Write sector to disk
  E8FE+          
  E8FE+3E01      STPSVX: LD      A,1             ; Indicate all is well (OK return)
  E900+01                DEFB    01H             ; ..fall thru the LD  A,FF with a LD  BC,FF3E
  E901+          
  E901+          ; Set Return to Error
  E901+          
  E901+3EFF      SERRO:  LD      A,0FFH          ; Set Error condition and restore User DMA
  E903+F5        SEXIT:  PUSH    AF              ; Save return code
  E904+          
  E905+=         STPDMA  EQU     $+1
  E904+010000            LD      BC,0000         ; Get User's DMA addr (stored here inline)
  E907+CDAFE9            CALL    DODMA           ; ..and restore it
  E90A+F1                POP     AF              ; Restore return code
  E90B+C9                RET                     ; ..and return to ZSDOS
  E90C+          
  E90C+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E90C+          ;    Read the Clock and place in proper Stamp Field
  E90C+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E90C+          
  E90C+57        UPSTMP: LD      D,A             ; A reg contains 0
  E90D+3AF9E9            LD      A,(STOFF)       ; Get offset in stamp
  E910+5F                LD      E,A             ; Make word length in DE
  E911+19                ADD     HL,DE           ; Point to where to put stamp
  E912+E5                PUSH    HL              ; Save target address
  E913+B7                OR      A               ; Is it CREATE time?
  E914+200A              JR      NZ,UPSTM0       ; ..jump if Not
ZAS Relocating Macro Assembler (v3.05                             page   95
                                                            
                                                            

  E916+060F              LD      B,15            ; Else zero entire stamp record
  E918+3600      UPSL:   LD      (HL),0
  E91A+23                INC     HL
  E91B+10FE              DJNZ    UPSL
  E91D+4A        UPSTM0: LD      C,D             ; Flag as clock read
  E91E+11FAE9            LD      DE,TDBUF        ; Point to TD buffer
  E921+D5                PUSH    DE
  E922+                                          ; Load Clock driver address
  E922+2A16CA            LD      HL,(BDOSB+TIMOFF)
  E925+CDBAE9            CALL    CALLHL          ; Fetch the time (may be BIOS)
  E928+E1                POP     HL              ; Get buffer start
  E929+D1                POP     DE              ; Get stamp address
  E92A+3D                DEC     A               ; Was it a good clock read?
  E92B+20D7              JR      NZ,SERRO        ; ..Take error exit if not
  E92D+010500            LD      BC,5            ; Else move 5 bytes
  E930+18C3              JR      PUTS1           ; ..and finish up
  E932+          
  E932+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E932+          ;    Checksum the first 127 bytes of the Local Buffer
  E932+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E932+          
  E932+067F      CKSUM:  LD      B,127
  E934+2A96E8            LD      HL,(SECBUF)     ; Point to buffer start
  E937+AF                XOR     A               ; Init checksum to 0
  E938+86        CKSUM1: ADD     A,(HL)          ; Add to checksum
  E939+23                INC     HL
  E93A+10FF              DJNZ    CKSUM1          ; Loop until done
  E93C+C9                RET
  E93D+          
  E93D+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E93D+          ; Read Sector Number in HL Using BIOS to Current DMA
  E93D+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E93D+          
  E93D+EB        RDSEC:  EX      DE,HL           ; Move desired logical record to DE
  E93E+017706            LD      BC,STDIR1       ; DOS logical record -> track/sector
  E941+2AB5E9            LD      HL,(OFFSET)
  E944+09                ADD     HL,BC           ; ZSDOS Stdir1 address now in HL
  E945+CDBAE9            CALL    CALLHL          ; Set Track/Sector
  E948+1E27              LD      E,RDSECT        ; Do BIOS Read of Sector
  E94A+                                          ;..fall thru to READ
  E94A+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E94A+          ;  C a l l   B I O S   w i t h   E r r o r   T e s t i n g
  E94A+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E94A+          
  E94A+          DOBIOSE:
  E94A+CDB1E9            CALL    DOBIOS          ; Do the function
  E94D+A7                AND     A               ; Was there an error?
  E94E+C8                RET     Z               ; ..return if no error
  E94F+F1                POP     AF              ; Else clear return address from stack
  E950+18B2              JR      SERRO           ; Flag error and return
  E952+          
  E952+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E952+          ; Indexed Fetch of BC from ZSDOS RAM
  E952+          ;  Called w/ DE=Offset in ZSDOS, Returns BC=Value at Index
  E952+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E952+          
ZAS Relocating Macro Assembler (v3.05                             page   96
                                                            
                                                            

  E952+11F80D    GETTDV: LD      DE,TDFVCT       ; Time and date vector - commonly used
  E955+2AB5E9    INDFET: LD      HL,(OFFSET)
  E958+19                ADD     HL,DE           ; Point to LSB
  E959+4E                LD      C,(HL)
  E95A+23                INC     HL
  E95B+46                LD      B,(HL)          ; Get value from RAM
  E95C+C9                RET
  E95D+          
  E95D+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E95D+          ;     R e p l a c e m e n t   F u n c t i o n   12
  E95D+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E95D+          
  E95D+7B        NEWF12: LD      A,E             ; See if arg passed
  E95E+FE44              CP      'D'
  E960+CD60E9    ZDPC1T: CALL    NEWF12          ; Gets swapped with DOS code
  E963+          ;--     LD      HL,22H          ;   (DOS code swapped)
  E963+C0                RET     NZ              ; If DS inquery not used
  E964+63                LD      H,E             ; Set return value
  E965+E5                PUSH    HL
  E966+                                          ; Load clock driver address
  E966+2A16CA            LD      HL,(BDOSB+TIMOFF)
  E969+2271E9            LD      (CLKADR),HL     ; set clock addr
  E96C+E1                POP     HL
  E96E+=         CLKADR  EQU     $+1             ; where to place clock driver address
  E96D+110000            LD      DE,0            ; Address of clock routine
  E970+          ;       LD      DE,CLK          ; Address of clock routine
  E970+C9                RET
  E971+          
  E971+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E971+          ;     C h e c k    f o r    ! ! ! T I M & . D A T
  E971+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E971+          
  E971+3EFF      SETCHK: LD      A,0FFH
  E973+327EE9            LD      (CKDSF),A       ; Set flag to check DS
  E976+CD74E9    ZDPC2T: CALL    SETCHK          ; This gets swapped with DOS
  E979+          ;--     CALL    SETFCT          ;   (DOS code swapped)
  E979+C9                RET
  E97A+          
  E97B+=         CKDSF   EQU     $+1
  E97A+3E00      CKTDF:  LD      A,00            ;   <CKDSF flag stored inline>
  E97C+B7                OR      A               ; Have we passed this way before?
  E97D+282C              JR      Z,ZDPC3T        ; ..exit if we have
  E97F+3C                INC     A
  E980+327BE9            LD      (CKDSF),A       ; Else clear flag
  E983+01000C            LD      BC,0C00H        ; Init loop count and checksum
  E986+E5                PUSH    HL              ; Get DIR pointer back
  E987+7E        CKTDF1: LD      A,(HL)          ; Get char from directory
  E988+E67F              AND     7FH             ; Mask attributes
  E98A+81                ADD     A,C
  E98B+4F                LD      C,A             ; Update Checksum
  E98C+23                INC     HL              ; bump pointers
  E98D+10FB              DJNZ    CKTDF1          ; And loop
  E98F+FE91              CP      TDVAL           ; Check against !!!TIME&.DAT checksum
  E991+2017              JR      NZ,CKTDFX       ; ..exit if no match
  E993+11F80D            LD      DE,TDFVCT
  E996+CD55E9            CALL    GETTDV          ; Get time/date login vector in BC
ZAS Relocating Macro Assembler (v3.05                             page   97
                                                            
                                                            

  E999+E5                PUSH    HL              ; Save pointer to MSB of vector
  E99A+114A06            LD      DE,SDRVB        ; Prepare to add this drive to vector
  E99D+60                LD      H,B
  E99E+69                LD      L,C             ; Xfer time/date login mask to HL
  E99F+CDB3E9            CALL    VECTOR          ; HL=new time/date vector on return
  E9A2+D1                POP     DE              ; Restore pointer to Vector storage
  E9A3+EB                EX      DE,HL           ; New T/D vector in DE
  E9A4+72                LD      (HL),D
  E9A5+2B                DEC     HL
  E9A6+73                LD      (HL),E          ; Update the vector in DOS
  E9A7+E1        CKTDFX: POP     HL
  E9A8+CD7DE9    ZDPC3T: CALL    CKTDF           ; Gets swapped with DOS code
  E9AB+          ;--     CALL    CKSUB           ;   (DOS code swapped)
  E9AB+C9                RET
  E9AC+          
  E9AC+          ;.....
  E9AC+          ; Set DMA address.
  E9AC+          
  E9AC+1E24      DODMA:  LD      E,SDMOFF        ; Set offset for BIOS call
  E9AE+                                          ;..and fall thru
  E9AE+          ;.....
  E9AE+          ; Do BIOS Call.  Enter with BIOS offset in E, parameter in BC
  E9AE+          
  E9AE+160E      DOBIOS: LD      D,OFBIOS/256    ; Set BIOS Page address in MSB
  E9B0+E5        VECTOR: PUSH    HL              ; Save caller's HL
  E9B1+          
  E9B2+=         OFFSET  EQU     $+1
  E9B1+2100CA            LD      HL,BDOSB        ; Get ZSDOS base address (stored inline)
  E9B4+19                ADD     HL,DE           ; Now pointing to BIOS base
  E9B5+E3                EX      (SP),HL         ; Restore HL, vector to TOS
  E9B6+C9                RET                     ; ..and execute BIOS function
  E9B7+          
  E9B7+E9        CALLHL: JP      (HL)            ; And exit to CCP
  E9B8+          
  E9B8+          ;Patch ZDS into/out of DOS
  E9B8+          
  E9B8+01CF04    INSTA3: LD      BC,ZDPCH1
  E9BB+1163E9            LD      DE,ZDPC1T
  E9BE+CDD3E9            CALL    PATCH
  E9C1+011D06            LD      BC,ZDPCH2
  E9C4+1179E9            LD      DE,ZDPC2T
  E9C7+CDD3E9            CALL    PATCH
  E9CA+013706            LD      BC,ZDPCH3
  E9CD+11ABE9            LD      DE,ZDPC3T
  E9D0+2AB2E9    PATCH:  LD      HL,(OFFSET)
  E9D3+09                ADD     HL,BC           ; Point to DOS patch point
  E9D4+0603              LD      B,3             ; Every patch is 3 bytes
  E9D6+4E        PATCH1: LD      C,(HL)          ; Fetch first byte from DOS
  E9D7+1A                LD      A,(DE)
  E9D8+77                LD      (HL),A          ; Install patch in DOS
  E9D9+79                LD      A,C
  E9DA+12                LD      (DE),A          ; And into ZDS
  E9DB+23                INC     HL
  E9DC+13                INC     DE              ; Bump pointers
  E9DD+10FA              DJNZ    PATCH1          ; ..and loop
  E9DF+C9                RET
ZAS Relocating Macro Assembler (v3.05                             page   98
                                                            
                                                            

  E9E0+          
  E9E0+          ; check for ZSDOS patch, first call will always return with an error
  E9E0+          
  E9E0+F5        CKPTCH: PUSH    AF
  E9E1+3AEFD7            LD      A,(STMPZP)      ; patch flag in zsdos
  E9E4+FE00              CP      0               ; patched ?
  E9E6+200E              JR      NZ,NOPTCH       ; ok
  E9E8+F1                POP     AF              ; unload stack from our calls
  E9E9+F1                POP     AF              ; ...done
  E9EA+CDBBE9            CALL    INSTA3          ; do patch, will become a RET after...
  E9ED+3EFF              LD      A,0FFH          ; RET code
  E9EF+32EFD7            LD      (STMPZP),A      ; disable this
  E9F2+C9                RET                     ; and ret standard error code
  E9F3+F1        NOPTCH: POP     AF              ; nothing to do
  E9F4+C9                RET
  E9F5+          
  E9F5+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E9F5+          ;               R A M    A r e a
  E9F5+          ;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E9F5+          
  E9F5+00        RWCODE: DEFB    0               ; 0 for read stamp, 1 for write stamp
  E9F6+00        STOFF:  DEFB    0               ; Offset in stamp
  E9F7+0000000000TDBUF:  DEFS    6               ; Temp storage for date
  E9FD+          
  E9FD+          ;       END
  E9FD                    endif
  E9FD                   endif   ; zdsson
  E9FD           
  E9FD           ; SIZE ERROR TEST
  E9FD           
  E9FD                    if     [ $ gt [ rcp + rcps*128 ] ]
  E9FD                   ***  RCP is too large  ***
  E9FD                    endif
  E9FD           
  E9FD           
  E9FD           ; End of Z33RCP.Z80
  E9FD           
  E9FD                   end

**** Symbol table ****
ALLFLAG         0041 ATT             E4E1 ATT1            E4F0
ATT2            E4FE ATT3            E50F ATT4            E51C
ATT5            E527 ATT6            E549 ATT7            E55C
ATT8            E567 ATTI            E502 ATTR            E507
ATTRF           001E ATTS            E50B ATTSET          E587
ATTST1          E58F BACCPTDIR       0001 BACCPTDU        0000
BADUENV         0001 BASE            0000 BATTCHK         0004
BATTDIR         0005 BATTSYS         0006 BBADDUECP       0007
BDOS            CA06 BDOSB           CA00 BDRVPREFIX      0006
BDUENV          0000 BDUFIRST        0002 BFASTECP        0001
BFCPENV         0004 BHIGHUSER       0007 BIAS            8E00
BINCLDIR        0004 BINCLDU         0003 BINCLENV        0002
BIOREAS         0A00 BIOS            D800 BIOSTDS         0600
BLKMOV          E6CE BLKSHF          E326 BNDRENV         0005
BPWCHECK        0006 BPWNOECHO       0005 BRCPENV         0003
BREAK           E69F BREAK1          E6B0 BRIGHT          0002
ZAS Relocating Macro Assembler (v3.05                             page   99
                                                            
                                                            

BROOTONLY       0006 BS              0008 BSCANCUR        0005
BSHELLIF        0007 BSKIPPATH       0000 BSUBCLUE        0001
BSUBECHO        0003 BSUBON          0000 BSUBQUIET       0002
BWDU            0004 BWPASS          0003 BWPREFIX        0002
CALLHL          E9BA CAN             0018 CCP             C200
CCPLEN          0800 CKDSF           E97B CKPTCH          E9E3
CKSUM           E935 CKSUM1          E93B CKTDF           E97D
CKTDF1          E98A CKTDFO          013C CKTDFX          E9AA
CL              001A CLIST           E241 CLKADR          E96E
CLOSEF          0010 CLS             E2AE CLS1            E2C1
CLSON           FFFF CLSTCAP         FFFF CMDCHAR         0025
CMDLIST         E26F CMDLIST1        E278 CMDLIST1A       E283
CMDLIST2        E28F CMDLIST3        E295 CMDLIST4        E29B
CMDLIST5        E2AA CMDSIZE         0004 CMDSLINE        0005
CMDSPACE        0008 CMDTBL          FD11 COMMAND         F727
COMP            E809 COMPSZF         0023 CONIN           E625
CONOUT          E5FE CONSTF          000B COUNT           0001
CPBLOCKS        0080 CPON            0000 CPSP            FFFF
CR              000D CRDN            0018 CREOFF          001A
CRLF            E61F CRSPACE         E2D5 CRTCHAR         0043
CRUP            0005 CTRLA           0001 CTRLC           0003
CTRLD           0004 CTRLE           0005 CTRLF           0006
CTRLK           000B CTRLR           0012 CTRLS           0013
CTRLX           0018 CTRLZ           001A CURSL           0013
CURSR           0004 DASH            E647 DECDSP          E5E9
DECDSP1         E5EC DECDSP2         E5FC DECDSP3         E5D9
DEFINE          E716 DEFINE1         E72A DFREE           E302
DIM             0001 DIR             E355 DIR01           E368
DIR3            E390 DIR3A           E39F DIR4            E3AA
DIRALPHA        E78F DIRBUF          E712 DIRBUFON        FFFF
DIRCONF         0006 DIRERR          E73D DIRNLY          E385
DIRON           FFFF DIRPR           E387 DIRSP           FFFF
DOBIOS          E9B1 DOBIOSE         E94D DODMA           E9AF
DPARAMS         E2F0 DPBOF           003C DUMMY           0022
ECHOLST         0000 ECHOON          0000 EOF             001A
EOFCHAR         001A ERA             E3B3 ERA1            E3C4
ERA2            E3DF ERA3            E3EF ERAFLG          E3D5
ERAON           FFFF ERAQ            E667 ERAQ1           E672
ERASEF          0013 ERASP           FFFF ESC             001B
EXIT            E643 EXPATH          EDF4 EXPATHS         0005
EXTFCB          EDD0 EXTRABIAS       1200 EXTSTK          EFD0
FALSE           0000 FATT            E570 FCB             005C
FCB1            005C FCB2            006C FCBEXT          0068
FCBRNO          007C FCP             EA00 FCPS            0004
FENCE           007C FF              000C FILLP           E69A
FREE1           E30E FREE2           E312 FREE3           E316
FREE4           E323 FREE5           E32B FREE6           E32F
GAP             E799 GD1             E75D GD1A            E779
GD2             E77A GETCDM          0647 GETDIR          E74B
GETF            00FF GETPARMF        001F GETREG          FA2F
GETSBIT         E6B8 GETTDV          E955 GSTOFF          001E
HASEDS          FFFF ICOMPARE        E7FF IDISK1          0024
IDISK2          0024 IDISK3          0001 IDISK4          0001
IDSTRING        FE05 II              E7AA INCLUDE         F4BA
INDEX           E8D8 INDFET          E958 INITFCB1        E68A
INITFCB2        E68D INQALCF         001B INQDISKF        0019
ZAS Relocating Macro Assembler (v3.05                             page  100
                                                            
                                                            

INSPECT         E55D INSTA3          E9BB INTRON          0000
IOBYTE          0003 IOP             0000 IOPS            0000
IPOS            E817 ISWAP           E7EC ISWAP1          E7F5
IUSER1          0024 IUSER2          000F IUSER3          0024
IUSER4          000F JG              E7E5 JJ              E7C3
LC1             E49D LC2             E4BB LCASECHAR       003E
LCOUT           E498 LF              000A LISTCPR         FFFF
LISTF           0005 LISTFCP         FFFF LISTON          0000
LOGINF          000E LOGUSR          E6E4 LSTOFF          0018
LTON            FFFF M80F            3CED M80W            3CEF
MAKEF           0016 MAXDIRS         0100 MBERR           0327
MODOFF          001C MSIZE           003C N               E7B2
NCHARS          0004 NEWF12          E960 NLINES          0018
NO              0000 NOFCP           E256 NOPTCH          E9F6
NOSHOW          FFFF NOSYS           FFFF NOTE            E60E
NOTEON          0000 NWF12O          011F NXTFILE         E826
OACCPTDIR       0001 OACCPTDU        0001 OADUENV         0000
OATTCHK         0003 OATTDIR         0003 OATTSYS         0003
OBADDUECP       0000 ODRVPREFIX      0001 ODUENV          0000
ODUFIRST        0001 OFASTECP        0002 OFBIOS          0E00
OFCPENV         0000 OFFCDRV         002F OFFCMD          0019
OFFCUSR         002E OFFM            E5C9 OFFOPT          0006
OFFPARSE        0010 OFFSCAN         0016 OFFSET          E9B2
OFFSRUN         002D OFFVERS         0005 OFFXSUB         002C
OHIGHUSER       0001 OINCLDIR        0001 OINCLDU         0001
OINCLENV        0000 ONDRENV         0000 OPENF           000F
OPTFLAG         F9BA OPWCHECK        0002 OPWNOECHO       0002
ORCPENV         0000 OROOTONLY       0000 OS$BASE         0000
OSCANCUR        0001 OSHELLIF        0003 OSKIPPATH       0002
OSUBCLUE        0003 OSUBECHO        0003 OSUBON          0003
OSUBQUIET       0003 OWDU            0002 OWPASS          0002
OWPREFIX        0002 PAGCNT          E714 PAGEBREAK       E4BE
PATCH           E9D3 PATCH1          E9D9 PEEKBDR         FFFF
PEEKCHK         FFFF PEEKHDR         FFFF PEEKON          0000
PGDFLG          0050 PGDFLT          FFFF PGFLG           E4B0
POKEON          0000 POKEQ           FFFF PORTON          0000
PRBUFF          0009 PRFN            E6ED PRFN1           E6FC
PRFNF           E6D5 PRINT           E60F PRINTHL         E615
PROTON          FFFF PRTCHAR         0050 PUNCHF          0004
PUTREG          FA6E PUTS1           E8F5 PUTSTP          E8F0
RCP             E200 RCPID           0041 RCPNAME         E23D
RCPS            0010 RDBUFF          000A RDCONF          0001
RDRF            0003 RDSEC           E940 RDSECT          0027
READF           0014 RECDIR          0052 REGON           0000
RENF            0017 RENON           0000 RESET           E2C7
RESETDKF        000D RESMSG          FFFF RESOLVE         F8F9
RESON           FFFF RESROOM         0400 RETSAVE         E638
ROMSG           E660 ROTEST          E64E RSTAMP          E86C
RWCODE          E9F8 SDMOFF          0024 SDRVB           064A
SEARF           E704 SEARF1          E708 SEARN           E737
SECBUF          E896 SEG1            E200 SEG10           EC00
SEG11           EF00 SEG12           EFD0 SEG2            EA00
SEG3            EA00 SEG4            ED00 SEG5            ED80
SEG6            EDD0 SEG7            EDF4 SEG8            EDFF
SEG9            EE00 SELDRV          E33C SERRO           E904
SETCHK          E974 SETCHO          0133 SETDMAF         001A
ZAS Relocating Macro Assembler (v3.05                             page  101
                                                            
                                                            

SETERR          FFFF SETRRF          0024 SETUSR          E6E7
SEXIT           E906 SGUSERF         0020 SHSIZE          0020
SHSTK           ED00 SHSTKS          0004 SLASHCHK        FFFF
SORTNT          FFFF SPACE           E2D8 SPACE1          E2E4
SPACEON         FFFF SPAEXIT         E640 SPC             0020
SRCHFF          0011 SRCHNF          0012 SRTL0           E797
SRTL1           E7A9 SRTL2           E7BE SSTOFF          0020
STCR            E84A STDIR1          0677 STLA            E852
STMPP2          0000 STMPZO          0DEF STMPZP          D7EF
STMPZS          FFFF STOFF           E9F9 STPDMA          E905
STPSV0          E87D STPSV1          E8C5 STPSV2          E8CB
STPSVC          E874 STPSVX          E901 STT             E854
STUP            E84E SUBVER          0001 SWAP            F9F0
SYSFLAG         0053 SYSTST          E6CC TAB             0009
TBLOFF          0016 TBUF            0080 TBUFF           0080
TDBUF           E9FA TDFVCT          0DF8 TDVAL           0091
TESTF80         0000 TESTM80         FFFF TFCB            005C
TIMOFF          0016 TPA             0100 TRUE            FFFF
TSTON           0000 TYPE            E3FC TYPE0           E400
TYPE2           E44C TYPE3           E463 TYPE4           E47C
TYPE5           E483 TYPE6           E48E TYPEX           E410
TYPEX1          E418 TYPEX2          E423 UCASECHAR       003C
UDFLAG          0004 UNLOAD          0024 UPCASE          FFFF
UPSL            E91B UPSTM0          E920 UPSTMP          E90F
VECTOR          E9B3 VERNOF          000C VERS            0016
VERSION         0002 WBOOT           0000 WCP             FFFF
WDIR            0000 WERA            FFFF WHEEL           FFFF
WHL             E594 WHLMASK         0000 WHLMSG          E5AE
WHLMSG1         E5AE WHLOFF          E5AA WHLON           FFFF
WHLPASS         E5D1 WHLQON          0000 WHLQUIET        0000
WHLSET          E5AB WHRC            0000 WIDE            FFFF
WLIST           FFFF WPASS           FD2A WPEEK           FFFF
WPOKE           FFFF WPORT           FFFF WPROT           FFFF
WRCONF          0002 WREG            FFFF WREN            FFFF
WRITEF          0015 WRSECT          002A WSTAMP          E871
WTYPE           FFFF WWHLQ           0000 YES             FFFF
Z3CL            EF00 Z3CLS           00D0 Z3ENV           EC00
Z3ENVS          0002 Z3MSG           ED80 Z3NDIR          EE00
Z3NDIRS         001C Z3RET           E644 Z3REV           0021
Z3WHL           EDFF ZBUFBAS         E200 ZDPC1T          E963
ZDPC2T          E979 ZDPC3T          E9AB ZDPCH1          04CF
ZDPCH2          061D ZDPCH3          0637 ZDSSBAS         E838
ZDSSON          FFFF ZDSSTPR         E838 ZDSSTSZ         01C8
ZFLOPKG         0200 ZIOPKG          0000 ZRESPKG         0800
ZSTDOVR         0400
RET           E644 Z3REV   