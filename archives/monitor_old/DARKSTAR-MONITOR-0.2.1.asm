;
;
; Z80 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
;
; Disassemblato e ricostruito da Piergiorgio Betti <pbetti@lpconsul.net>
; 2005 01 26
;
; ---[20051030]--------------------------------------------------------
; Avviate modifiche per inserimento routine di download parallelo
; ---[20051109]--------------------------------------------------------
; Versionata come 0.2.0. Da questa release iniziano modifiche di
; struttura
; - rinominati entry point
; - cancellata UKROUT
; - cancellata DISPGR . ATTENZIONE: TUTTI GLI INDIRIZZI SONO CAMBIATI!!
; - DISPGR2 rinominata DISPGR
; - rilocati tutti i buffer nell'area $003b-$004f non usata dal CP/M
; - numero versione 1.0
; - removed code from $f97c to $f9f1....
; - removed code from $fa2f to $fa37....
; ---------------------------------------------------------------------


; Defines for the i/o ports
;
; *** LX529 VIDEO BOARD:
CRTBASE		equ	$80
	; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
CRTRAM0DAT	equ	CRTBASE		; RAM0 access: PIO0 port A data register
CRTRAM0CNT	equ	CRTBASE+2	; RAM0 access: PIO0 port A control register
	; Printer port
CRTPRNTDAT	equ	CRTBASE+1	; PRINTER (output): PIO0 port B data register
CRTPRNTCNT	equ	CRTBASE+3	; PRINTER (output): PIO0 port B control register
					; STROBE is generated by hardware
	; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
CRTRAM1DAT	equ	CRTBASE+4	; RAM1 access: PIO1 port A data register
CRTRAM1CNT	equ	CRTBASE+6	; RAM1 access: PIO1 port A control register
	; Keyboard port (negated). Bit 7 is for strobe
CRTKEYBDAT	equ	CRTBASE+5	; KEYBOARD (input): PIO1 port B data register
CRTKEYBCNT	equ	CRTBASE+7	; KEYBOARD (input): PIO1 port B control register
KEYBSTRBBIT	equ	7		; Strobe bit
	; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
CRTRAM2DAT	equ	CRTBASE+8	; RAM2 access: PIO2 port A data register
CRTRAM2CNT	equ	CRTBASE+10	; RAM2 access: PIO2 port A control register
	; Service/User port
CRTSERVDAT	equ	CRTBASE+9	; Service (i/o): PIO2 port B data register
CRTSERVCNT	equ	CRTBASE+11	; Service (i/o): PIO2 port B control register
PRNTBUSYBIT	equ	0		; Printer BUSY bit
CRTWIDTHBIT	equ	1		; Set 40/80 chars per line
					; Other bits available to user
	; RAM3 control chars/graphics attributes
CRTRAM3PORT	equ	CRTBASE+14	; RAM3 port
CRTBLINKBIT	equ	0		; Blink
CRTREVRSBIT	equ	1		; Reverse
CRTUNDERBIT	equ	2		; Underline
CRTHILITBIT	equ	3		; Highlight
CRTMODEBIT	equ	4		; ASCII/GRAPHIC mode
	; Beeper port
CRTBEEPPORT	equ	CRTBASE+15	; Beeper port
	; 6545 CRT controller ports
CRT6545ADST	equ	CRTBASE+12	; Address & Status register
CRT6545DATA	equ	CRTBASE+13	; Data register
;
; *** LX390 FDC CONTROLLER:
FDCBASE	equ	$d0
FDCCMDSTATR	equ	FDCBASE		; Command and status register
FDCTRAKREG	equ	FDCBASE+1	; Track register
FDCSECTREG	equ	FDCBASE+2	; Sector register
FDCDATAREG	equ	FDCBASE+7	; Data register *** Verificare che sia $d7
FDCDRVRCNT	equ	FDCBASE+6	; Driver select/control register
FSECLEN		equ	$80		; 128 bytes sector
FRWWORD		equ	((FSECLEN * $100) + FDCDATAREG) ; $80d7 in other words
FDCRESTC	equ	$07		; 1771 restore (seek to trak 0) cmd
FDCSEEKC	equ	$17		; seek cmd
FDCREADC	equ	$88		; read cmd
FDCWRITC	equ	$a8		; write cmd
;
; alternate printer port
ALTPRNPRT	equ	$03
;
; parallel port PC link
PPDATAP		equ	$3		; Data port
PPCNTRP		equ	$2		; Control port
PPSTROB		equ	0		; Strobe bit
PPAKSTB		equ	1		; Acknowledge/Stop bit
;
PPDINI		equ	$0		; 00000000 Dnl Init byte
PPDRDY		equ	$4		; 00000100 Dnl Ready
PPDSTP		equ	$6		; 00000110 Dnl Stop
PPDOKG		equ	$2		; 00000010 Dnl Ok Go
PPUINI		equ	$1		; 00000001 Upl Init byte
PPURDY		equ	$5		; 00000101 Upl Ready
PPUACK		equ	$7		; 00000111 Upl Acknowledge
PPUOKG		equ	$3		; 00000011 Upl Ok Go
;
; virtual disks (PC-linked over parallel port)
VDSECLN		equ	128		; sector length
VDRDSEC		equ	0		; read sector command
VDWRSEC		equ	1		; write sector command
VDBUFSZ		equ	10		; 9 bytes block
;
; Ram addresses labels
IOBYTE		equ	$0003		; Intel IOBYTE (CP/M 2.2 only)
CDISK		equ	$0004		; Last logged drive (CP/M 2.2 only)
BTPASIZ		equ	$0006		; word size of tpa + 1
CRTTABUF	equ	$0010		; table: 20 bytes
APPBUF		equ	$002d		; byte
VDSKBUF		equ	$002e		; table: 8 bytes command structure buffer
RAM0BUF		equ	$003b		; byte	WARNING: RST38 must contain a jump
RAM1BUF		equ	$003c		; byte
RAM2BUF		equ	$003d		; byte
RAM3BUF		equ	$003e		; byte
FCMDBUF		equ	$003f		; byte 1771 command buf
FSTABUF		equ	$0040		; byte 1771 status buf
FSEKBUF		equ	$0041		; word current track number for drive A/B
FRDPBUF		equ	$0043		; word dma address for i/o
FSECBUF		equ	$0045		; word sector # for i/o (1 .. 65535)
FDRVBUF		equ	$0047		; byte drive number for i/0 (0 - 15)
FTRKBUF		equ	$0048		; word track # fot i/o (0 - 65535)
CURPBUF		equ	$004a		; word
MIOBYTE		equ	$004c		; byte
KBDBYTE		equ	$004d		; byte
CIOBYTE		equ	$004e		; byte
COLBUF		equ	$004f		; byte

; GRAM0BUF	equ	$3040
; GRAM1BUF	equ	$3041
; GRAM2BUF	equ	$3042
; GRAM3BUF	equ	$3043

;
; aliases
IOCACK		equ	INICRTCUR
IOCVT		equ	CHOME
IOCFF		equ	CLRSCR
IOCSI		equ	CLREOL
IOCDC1		equ	RESATTR
IOCDC4		equ	LINDN

;	org $f000	; THIS IS MONITOR EPROM BASE, (de)comment when you need to test
	org $e000	; THIS FOR TESTING PURPOSES, (de)comment when you need it

JBOOT:	jp     BOOT		; BOOT - Bring up system
JCONIN:	jp     BCONIN		; Char input
JCONOU:	jp     BCONOUT		; Char output
JHOME:	jp     BHOME		; move head to trak 0 (cp/m home like)
JSELDS:	jp     BSELDSK		; Drive select
JSETTR:	jp     BSETTRK		; Track Select
JSETSE:	jp     BSETSEC		; Sector select
JSETDM:	jp     BSETDMA		; DMA (io address) select
JREAD:	jp     BREAD		; read floppy sector
JWRITE:	jp     BWRITE		; write floppy sector
JFSTAT:	jp     GFDCSTAT		; get 1771 status
JFDCMD:	jp     SFDCCMD		; send cmd to 1717
JCURTR:	jp     GCURTRK		; get current track for current drive
JFSEEK:	jp     FSEEK		; floppy seek
JDRVSL:	jp     DRVSEL		; do drive selection
JDISPG:	jp     DISPNORTR	; graphic output (VERIFY NEED OF JUMP ENTRY)
JUSRCM:	jp     UCREJ		; negative monitor prompt
JCPMBT:	jp     CPMBOOT		; floppy bootstrap of CP/M
JGETHN:	jp     GETHNUM		; get hexadecimal number
JCONST:	jp     BCONST		; console status
JPRNCH:	jp     PRNCHR           ; printer output

;;
;; DISPGR - Display a full graphic char frpm GRAMBUF
;
; TODO: RIMUOVERE
; DISPGR:
; 	in     a,(CRT6545ADST)
; 	bit    7,a
; 	jr     z,DISPGR
; 	ld     hl,GRAM0BUF
; 	ld     a,(hl)
; 	out    (CRTRAM0DAT),a
; 	inc    hl
; 	ld     a,(hl)
; 	out    (CRTRAM1DAT),a
; 	inc    hl
; 	ld     a,(hl)
; 	out    (CRTRAM2DAT),a
; 	inc    hl
; 	ld     a,(hl)
; 	out    (CRTRAM3PORT),a
; 	xor    a
; 	out    (CRT6545DATA),a
; 	ret
;;

;; SET DISPLAY CURSOR ADDRESS EXTENDED
;; I'm unable to map 6545 (nor 6845) register $12 and $13
;; since register range is R0-R17 ($0-$11)
;
SDCUAE:
	ld     a,$0e           ; was 00F060 3E 0E
	out    (CRT6545ADST),a
	ld     a,h
	out    (CRT6545DATA),a
	ld     a,$0f
	out    (CRT6545ADST),a
	ld     a,l
	out    (CRT6545DATA),a
SDCUAE1:
	ld     a,$12
	out    (CRT6545ADST),a
	ld     a,h
	out    (CRT6545DATA),a
	ld     a,$13
	out    (CRT6545ADST),a
	ld     a,l
	out    (CRT6545DATA),a
	jr     CRTPRGEND
;;
;; SCUROF - turn off cursor
;
SCUROF:	
	ld     a,$0a           ; was 00F07E 3E 0A
	out    (CRT6545ADST),a
	ld     a,$20
	out    (CRT6545DATA),a
;;
;; CRTPRGEND
;; resets 6545 register pointer
;
CRTPRGEND:	
	ld     a,$1f           ; was 00F086 3E 1F
	out    (CRT6545ADST),a
	ret
;;
;; SCURON - turn on cursor
;
SCURON:
	ld     a,$0a           ; was 00F08B 3E 0A
	out    (CRT6545ADST),a
	xor    a
	out    (CRT6545DATA),a
	jr     CRTPRGEND
;;
;; GETKBD - wait for a key and return in A
;
GETKBD:
		; wait for strobe clean
	in     a,(CRTKEYBDAT)         ; was 00F094 DB 85
	cpl
	bit    7,a
	jr     nz,GETKBD
		; wait for keypress
GKLP0:	in     a,(CRTKEYBDAT)
	cpl
	bit    7,a
	jr     z,GKLP0
	and    $7f
	ret
;;
;; INICRT - should be 
;
INICRT:
	in     a,(CRTSERVDAT)         ; was 00F0A5 DB 89
	res    1,a             ; Modo 40/80 colonne (80)
	ld     hl,CRTTAB
	out    (CRTSERVDAT),a
	ld     a,$8f
	out    (CRTRAM0CNT),a
	out    (CRTRAM1CNT),a
	out    (CRTRAM2CNT),a
	ld     a,$cf
	out    (CRTPRNTCNT),a
	ex     af,af'
	xor    a
	out    (CRTPRNTCNT),a
	ex     af,af'
	out    (CRTKEYBCNT),a
	ex     af,af'
	dec    a
	out    (CRTKEYBCNT),a
	ex     af,af'
	out    (CRTSERVCNT),a
	ld     a,$f1
	out    (CRTSERVCNT),a
SDRR11R0:
	ld     b,$0c
ICLP0:	ld     a,b
	dec    a
	out    (CRT6545ADST),a
	ld     a,(hl)
	out    (CRT6545DATA),a
	inc    hl
	djnz   ICLP0
RDRR19R12:
	ld     b,$08
ICLP1:	ld     a,b
	add    a,$0b
	out    (CRT6545ADST),a
	xor    a
	out    (CRT6545DATA),a
	djnz   ICLP1
	jp     CRTPRGEND
;;
;; CLRSCRGR - Clear screen (80x24)
;
CLRSCRGR:
	call   SCUROF           ; was 00F0E7 CD 7E F0
	ld     hl,$0020
	ld     (RAM0BUF),hl
	ld     hl,$ff00
	ld     (RAM2BUF),hl
	call   RDRR19R12
	ld     hl,$0000
CSGLP0:	ld     a,(RAM0BUF)
	call   DISPGRCH
	inc    hl
	ld     a,h
	cp     $07
	jr     nz,CSGLP0
	ld     a,l
	cp     $80
	jr     nz,CSGLP0
	call   RDRR19R12
	jp     SCURON
;;
;; DISPGRCH - Display a char (from A reg.) atrributed from RAM3BUF 
;
DISPGRCH:
	push   af              ; was 00F113 F5
DGCLP0:	in     a,(CRT6545ADST)
	bit    7,a
	jr     z,DGCLP0
	pop    af
	out    (CRTRAM0DAT),a
	ld     a,(RAM3BUF)
	out    (CRTRAM3PORT),a
	xor    a
	out    (CRT6545DATA),a
	ret
;;
;; FILVRAMG - Fill the video ram in graphic mode (from RAMBUF)	
;
FILVRAMG:
	ld     hl,$0000        ; was 00F126 21 00 00
	call   RDRR19R12
FVLP0:	push   hl
	call   DISPGR
	pop    hl
	inc    hl
	ld     a,h
	cp     $07
	jr     nz,FVLP0
	ld     a,l
	cp     $80
	jr     nz,FVLP0
	ret
;;
;; DELAY
;;
;; This routine generate a delay from 1 to 65535 milliseconds.
;;

MSCNT	equ	116

DELAY:				; was F13D
	push	bc		; 11 c.
	push	af		; 11 c.
DLY2:
	ld	c, MSCNT	; 7 c.	(assume de = 1 = 1msec.)
DLY1:
	dec	c		; 4 c. * MSCNT
	jr	nz, DLY1	; 7/12 c. * MSCNT
	dec	de		; 6 c.
	ld	a, d		; 4 c.
	or	e		; 4 c.
	jr	nz, DLY2	; 7/12 c.

	pop	af		; 10 c.
	pop	bc		; 10 c.
	ret			; 10.c

;; MSEC evaluation (ret ignored):
;
; 42 + (de) * (7 + 16 * MSCNT - 5 + 26) - 5
;
; 65 + 16 * MSCNT = ClockSpeed   (ClockSpeed is 1920 for Z80 DarkStar)
; (ClockSpeed - 65) / 16 = MSCNT = 116
;

;;
;; UPLOAD wait for remote to upload code/data through
;; parallel link board
;;
;; UPLCHR get a single byte from remote
;;

;;
;; get a byte from remote
;;
;; use:
;;	none
;; return:
;;	D  - received byte
;; unclean register usage: A, E
UPLCHR:
	in	a, (PPCNTRP)		; wait for remote ready to tx
	bit	PPAKSTB, a
	ret	nz
	bit	PPSTROB, a
	jr	nz, UPLCHR

	ld	a, PPURDY		; signal ready to receivce
	out	(PPCNTRP), a
UPWSTRB:
	in	a, (PPCNTRP)		; wait for data
	bit	PPSTROB, a
	jr	z, UPWSTRB

	in	a,(PPDATAP)
	ld	d, a			; copy on c (return value)
	ld	a,PPUACK		; send aknowledge
	out	(PPCNTRP),a
	ld	a, d
	ld	de, 1			; 1 msec wait
	call	DELAY
	ld	d, a

	ld	a, PPUOKG		; let's remote run...
	out	(PPCNTRP), a
	in	a, (PPCNTRP)		; in remote answer
	ret
;
;; PRCVBLK - upload a block through parallel link
;;
;; use:
;;	HL - offset of storage area
;;	BC - block size
;; unclean register usage: A
PRCVBLK:
	push	af
	push	de
	ld	 a, PPUINI		; init parallel port for rx
	out 	(PPCNTRP), a
PRBLOO:	call	UPLCHR			; begin real transfer
	bit	PPAKSTB, a		; check for stop requests
	jr 	nz, PRBEND
	ld 	(hl), d			; store data
	inc	hl
	dec	bc			; check for upload end
	ld	a, b
	or	c
	jr 	nz, PRBLOO		; next
PRBEND:	ld	 a, PPUINI		; clean handshake
	out 	(PPCNTRP), a
	pop	de
	pop	af
	ret

;;
;; upload data through parallel link
;;
;; use:
;;	none
;; unclean register usage: ALL
UPLOAD:
	call	OUTCRLF
	ld	hl, STRWAIT
	call	CONSTR

	call	UPLCHR			; in hi byte of upload offset
	ld	h,d
	call	UPLCHR			; in lo byte of upload offset
	ld	l,d
	call	UPLCHR			; in hi byte of data size
	ld	b,d
	call	UPLCHR			; in lo byte of data size
	ld	c,d
	push	hl
	call	OUTCRLF
	ld	hl, STRLOAD
	call	CONSTR
	pop 	hl

	call	PRCVBLK			; upload data block
	call	OUTCRLF
	ret
;--------------------
;; Routines to manage data send (download) over parallel port
;;
;; PSNDCH - send a byte over parallel
;;
;; use:
;; HL - point to byte to transfer (updated after exec)
;; unclean register usage: A, C, DE
PSNDCH:
	in 	a, (PPCNTRP)		; wait synchro strobe from remote
	bit 	PPSTROB, a
	jr 	nz, PSNDCH

	ld 	a, (hl)
	out	(PPDATAP), a		; out data and then emit ready signal
	inc	hl
	ld 	a, PPDRDY
	out 	(PPCNTRP), a
					;; remote should reset strobe when PPDRDY is get...
PWACKB:
	in	a, (PPCNTRP)		; wait ack from remote
	bit 	PPAKSTB, a
	jr 	z, PWACKB

	ld	a, PPDOKG		; reset ready bit and let remote run waiting 1 msec.
	out 	(PPCNTRP), a
					;; remote should reset ack when PPDOKG is get...
	push	de
	ld	de, 1
	call	DELAY
	pop 	de
	ret

;;
;; PSNDBLK - send a block over parallel link
;;
;; use:
;; HL - point to the base of block to transfer
;; DE - block size
;; unclean register usage: none

PSNDBLK:
	push	af
	push	de
	ld 	a, PPDINI
	out 	(PPCNTRP), a

PSNXTC:
	call	PSNDCH			; send byte
	dec 	bc			; check for transfer end
	ld 	a, b
	or 	c
	jr 	nz, PSNXTC

	ld 	a, PPDSTP
	out 	(PPCNTRP), a
	ld	de, 50			; 50 msec. to stop remote
	call	DELAY
	ld 	a, PPUINI
	out 	(PPCNTRP), a		; leave parallel clean

	pop	de
	pop	af
	ret
;;
;; PDNLOAD- prompt user for parallel download
;;
PDNLOAD:
	call 	OUTCRLF
	ld	hl, S_DLPR
	call	CONSTR
	ld	b, 2			; get params (offset, size)
	call	GETHNUM
	pop	bc
	call 	OUTCRLF
	ld	hl, STRWAIT
	call	CONSTR
	call 	OUTCRLF
	pop	hl
	call	PSNDBLK			; send data
	ret
;----------------------------------------------------------
; PC-LINKED VIRTUAL DISK HANDLE ROUTINES
; ---------------------------------------------------------
;;
;; VDSKRD - read a sector form remote
;;
;; use:
;;	none
;; unclean register usage: none

VDSKRD:
	push	bc
	push	hl
	push	iy

	ld	iy, VDSKBUF
	ld	hl, S_VHDR
	ld	b, 4
VDRSL1: ld	c, (hl)
	ld	(iy + 0), c
	inc	iy
	inc	hl
	djnz	VDRSL1

	ld	c, VDRDSEC		; read command
	ld	(iy + 0), c
	ld	hl, FDRVBUF
	ld	c, (hl)			; drive
	ld	(iy + 1), c
	ld	bc, (FSECBUF)		; sector
	dec	bc			; base sector # is zero...
	ld	(iy + 2), c
	ld	(iy + 3), b
	ld	bc, (FTRKBUF)		; track
	ld	(iy + 4), c
	ld	(iy + 5), b

	ld	hl, VDSKBUF		; command offset
	ld	bc, VDBUFSZ		; block size
	call	PSNDBLK			; send command block
					; receive sector now
	ld	hl, (FRDPBUF)		; set dma address
	ld	bc, VDSECLN		; vdisk sector length
	call	PRCVBLK			; upload sector
	pop	iy
	pop 	hl
	pop 	bc
	ret

;;
;; VDSKWR - read a sector form remote
;;
;; use:
;;	none
;; unclean register usage: none

VDSKWR:
	push	bc
	push	hl
	push	ix

	ld	ix, VDSKBUF
	ld	hl, S_VHDR
	ld	b, 4
VDWSL1: ld	c, (hl)
	ld	(ix + 0), c
	inc	ix
	inc	hl
	djnz	VDWSL1

	ld	c, VDWRSEC		; read command
	ld	(ix + 0), c
	ld	hl, FDRVBUF
	ld	c, (hl)			; drive
	ld	(ix + 1), c
	ld	bc, (FSECBUF)		; sector
	dec	bc			; base sector # is zero...
	ld	(ix + 2), c
	ld	(ix + 3), b
	ld	bc, (FTRKBUF)		; track
	ld	(ix + 4), c
	ld	(ix + 5), b

	ld	hl, VDSKBUF		; command offset
	ld	bc, VDBUFSZ		; block size
	call	PSNDBLK			; send command block

					; receive sector now
	ld	hl, (FRDPBUF)		; set dma address
	ld	bc, VDSECLN		; vdisk sector length
	call	PSNDBLK			; upload sector
	pop	ix
	pop 	hl
	pop 	bc
	ret

S_DLPR	defb	'D', 'L'+$80
S_VHDR:	defb	"@IO@"
STRWAIT:
	defb 'Waiting..', '.'+$80
STRLOAD:
	defb 'Loadin', 'g'+$80

;;
;; NEDOSCR - NEDOS boot screen (wiped out)
;
;NEDOSCR:


	;; ALIGNMENT trick:
	;; NEDOSCR was the odl entry point. NEDOS related functions
	;; (except general routines like video management) are commented
	;; out and replaced by the new code.
	;; Here we keep in sync with old addresses. This should not be really
	;; necessary, but in a first try i prefer not to change entry points....
;	defs  DISPSTR - NEDOSCR
	;; -------------------
; 	call   CLRSCRGR
; 	ld     hl,STR005
; 	call   DISPSTR
; 	ld     hl,STR006
; 	call   DISPSTR
; 	ld     hl,STR007
; 	call   DISPSTR
; NDSLP3:	ld     a,$ff
; 	ld     (GRAM3BUF),a
; 	ld     hl,STR009
; 	call   DISPSTR
; 	ld     hl,$0526
; 	call   SDCUAE
; 	call   GETKBD
; 	ld     hl,(STR008)
; 	push   hl
; 	call   SDCUAE
; 	pop    hl
; 	; blank str008 space
; 	ld     b,$1a
; NDSLP0:	ld     a,$20
; 	call   DISPGRCH
; 	djnz   NDSLP0
; 	ld     hl,$0526
; 	call   SDCUAE
; 	xor    a
; 	out    (FDCDRVRCNT),a
; 	out    (FDCCMDSTATR),a
; NDSLP2:
; 	ex     (sp),hl
; 	ex     (sp),hl
; 	in     a,(FDCCMDSTATR)
; 	bit    1,a
; 	jr     z,NDSLP1
; 	ld     a,FDCCMDSTATR
; 	out    (FDCCMDSTATR),a
; 	jr     NDSLP2
; NDSLP1:
; 	ld     hl,$0000
; 	ld     ($9000),hl
; 	ld     hl,$1500
; 	ld     ($9002),hl
; 	ld     a,$01
; 	out    (FDCDRVRCNT),a
; 	ld     b,$05
; NDSJ1:	ld     a,$0b
; 	out    (FDCCMDSTATR),a
; 	ex     (sp),hl
; 	ex     (sp),hl
; 	djnz   NDSJ1
; NDSJ2:	in     a,(FDCCMDSTATR)
; 	bit    0,a
; 	jr     nz,NDSJ2
; NDSJ5:	ld     de,($9002)
; 	ld     hl,($9000)
; 	call   NDSRDSEC
; 	ld     a,($9002)
; 	inc    a
; 	cp     $0a
; 	jr     nz,NDSJ3
; 	ld     a,($9003)
; 	inc    a
; 	ld     ($9003),a
; 	xor    a
; NDSJ3:	ld     ($9002),a
; 	dec    hl
; 	ld     a,(hl)
; 	ld     ($9001),a
; 	dec    hl
; 	ld     a,(hl)
; 	ld     ($9000),a
; 	dec    hl
; 	ld     a,(hl)
; 	cp     $01
; 	jr     nz,NDSJ4
; 	dec    hl
; 	ld     a,(hl)
; 	cp     $01
; 	jr     z,NDSJ5
; 	rst    00h
; NDSJ4:	ld     hl,STR008
; 	xor    a
; 	out    (FDCDRVRCNT),a
; 	ld     a,$f0
; 	ld     (GRAM3BUF),a
; 	call   DISPSTR
; 	jp     NDSLP3
; ;;
; NDSRDSEC:	
; 	ld     a,e
; 	out    (FDCSECTREG),a
; 	ld     a,d
; 	out    (FDCDATAREG),a
; 	ld     a,$1a
; 	out    (FDCCMDSTATR),a
; 	ex     (sp),hl
; 	ex     (sp),hl
; NRD1:	in     a,(FDCCMDSTATR)
; 	rrca
; 	jr     c,NRD1
; 	ld     a,$88
; 	out    (FDCCMDSTATR),a
; 	push   bc
; 	pop    bc
; 	jr     NRD2
; NRD4:	rrca
; 	jr     nc,NRD3
; NRD2:	in     a,(FDCCMDSTATR)
; 	bit    1,a
; 	jr     z,NRD4
; 	in     a,(FDCDATAREG)
; 	ld     (hl),a
; 	inc    hl
; 	jr     NRD2
; NRD3:	in     a,(FDCCMDSTATR)
; 	and    $5c
; 	ret    z
; 	ld     a,FDCCMDSTATR
; 	out    (FDCCMDSTATR),a
; 	ret
; ;;
; ;; NDSHW - test video hardware for nedos
; NDSHW:
; 	ld     hl,$7f00
; 	ld     ($9006),hl
; 	xor    a
; 	ex     af,af'
; 	ld     hl,$ffff
; 	ld     (GRAM0BUF),hl
; 	ld     hl,$efff
; 	ld     (GRAM2BUF),hl
; 	call   FILVRAMG
; 	call   RDRR19R12
; 	ld     hl,$0780
; NDH1:	in     a,(CRT6545ADST)
; 	bit    7,a
; 	jr     z,NDH1
; 	in     a,(CRTRAM0DAT)
; 	inc    a
; 	jr     nz,NDH2
; 	in     a,(CRTRAM1DAT)
; 	inc    a
; 	jr     nz,NDH2
; 	in     a,(CRTRAM2DAT)
; 	inc    a
; 	jr     z,NDH3
; NDH2:	ld     ($9004),sp
; 	ld     sp,($9006)
; 	push   hl
; 	ld     ($9006),sp
; 	ld     sp,($9004)
; 	ex     af,af'
; 	ld     a,$01
; 	ex     af,af'
; NDH3:	dec    hl
; 	xor    a
; 	out    (CRT6545DATA),a
; 	ld     a,h
; 	or     l
; 	jr     nz,NDH1
; 	call   RDRR19R12
; 	ex     af,af'
; 	or     a
; 	jr     z,NDH4
; 	call   CLRSCRGR
; 	ld     hl,STR010
; 	call   DISPSTR
; 	ld     hl,$0140
; 	call   SDCUAE
; 	ld     ($9004),sp
; NDH7:	ld     a,$20
; 	call   DISPGRCH
; 	ld     sp,($9006)
; 	pop    hl
; 	ld     ($9006),sp
; 	ld     a,h
; 	add    a,$30
; 	call   DISPGRCH
; 	ld     h,$00
; 	add    hl,hl
; 	add    hl,hl
; 	add    hl,hl
; 	add    hl,hl
; 	ld     a,h
; 	cp     $0a
; 	jr     c,NDH5
; 	add    a,$07
; NDH5:	add    a,$30
; 	call   DISPGRCH
; 	or     a
; 	ld     a,l
; 	rra
; 	rra
; 	rra
; 	rra
; 	cp     $0a
; 	jr     c,NDH6
; 	add    a,$07
; NDH6:	add    a,$30
; 	call   DISPGRCH
; 	ld     a,($9007)
; 	cp     $7f
; 	jr     nz,NDH7
; 	ld     sp,($9004)
; 	ld     hl,STR011
; 	call   DISPSTR
; 	call   SCUROF
; 	call   GETKBD
; NDH4:	jp     CLRSCRGR

;	org    $f2e1		;; old label alignment
;;
;; DISPSTR - Display a string of format:
;; R,C,"STRING",$00
;	
DISPSTR:
	ld     c,(hl)          ; was 00F2E1 4E
	inc    hl
	ld     b,(hl)
	push   hl
	push   bc
	pop    hl
	call   SDCUAE1
	pop    hl
DSLP0:	inc    hl
	ld     a,(hl)
	cp     $00
	ret    z
	call   DISPGRCH
	jr     DSLP0
;; CRTTAB - 6545 Register setup values
CRTTAB:                        ; was 00F2F5
	db    $0b,$00,$0b,$48
	db    $18,$18,$00,$1a
	db    $28,$57,$50,$6f
;;
;STR001:                        ; was 00F301
	;; ALIGNMENT trick:
	;; STR001 was the odl entry point. NEDOS related functions
	;; (except general routines like video management) are commented
	;; out and replaced by the new code.
	;; Here we keep in sync with old addresses. This should not be really
	;; necessary, but in a first try i prefer not to change entry points....
;	defs  DRVSEL - STR001
	;; -------------------
; 	db    $0b,$01
; 	db    "GRAFIC - MONITOR 1.0",$00
; STR002:
; 	db    $04,$02
; 	db    "type",$00
; STR003:
; 	db    $3a,$03
; 	db    $22,"ESC",$22," for BOOTSTRAPPING",$00
; STR004:
;         db    $d9,$03
; 	db    $22,"RETURN",$22," for testing VIDEO",$00
; STR005:
; 	db    $08,$01
; 	db    "BOOTSTRAP Version GRAFIC 1.0",$00
; STR006:
; 	db    $9f,$01
; 	db    "Insert NE-DOS-DISK Version GRAFIC in drive 0",$00
; STR007:
; 	db    $4e,$02
; 	db    "then type a key",$00
; STR008:
; 	db    $89,$03
; 	db    " No NE-DOS Version GRAFIC ",$00
; STR009:
; 	db    $25,$05
; 	db    "> <",$00
; STR010:
; 	db    $0e,$00
; 	db    "Errorpoints :",$00
; STR011:
; 	db    $28,$00
; 	db    "Please type a key",$00
; ;;	
; ;;
; JNDSTA:	jp     NDOSSTA
; JJNDST:	jp     JNDSTA
; NDOSSTA:
; 	in     a,(CRT6545ADST)
; 	xor    a
; 	out    (FDCDRVRCNT),a
; 	di
; 	ld     sp,$7000
; 	call   INICRT
; NDST1:	call   NDSHW
; 	ld     hl,STR001
; 	call   DISPSTR
; 	ld     hl,STR002
; 	call   DISPSTR
; 	ld     hl,STR003
; 	call   DISPSTR
; 	ld     hl,STR004
; 	call   DISPSTR
; 	ld     hl,STR009
; 	call   DISPSTR
; 	ld     hl,$0526
; 	call   SDCUAE
; KBLP0:
; 	call   GETKBD
; 	cp     $1b
; 	jp     z,NEDOSCR
; 	cp     $0d
; 	jr     z,NDST1
; 	jr     KBLP0
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;---------------------------------------------------

;	org   $f450
;;
;; DRVSEL - select drive for r/w ops
;
DRVSEL:
	push   af              ; was 00F450 F5
	push   bc
	ld     a,(FDRVBUF)
	inc    a
	ld     b,a
	xor    a
	scf
DSHFT:	rla
	djnz   DSHFT
	out    (FDCDRVRCNT),a
	pop    bc
	pop    af
	ret
;;
;; CPMBOOT - boostrap cp/m
;
CPMBOOT:
	ld     sp,$0080        ; was 00F461 31 80 00
	ld     bc,$00
	call   BSETTRK
	call   BSELDSK
	inc    a
	out    (FDCDRVRCNT),a
	call   BHOME
	jp     nz,UCREJ
	ld     bc,$0080        ; read in loader at $0080
	call   BSETDMA
	ld     bc,$01
	call   BSETSEC
	call   BREAD
	jp     nz,UCREJ
	jp     $0080           ; jump to the loader if all ok
BSETTRK:
;	ld     a,c             ; was 00F489 79
	ld     (FTRKBUF),bc
	ret
BSETSEC:
; 	ld     a,c             ; was 00F48E 79
	ld     (FSECBUF),bc
	ret
BSETDMA:
	ld     (FRDPBUF),bc      ; was 00F493 ED 43 45 00
	ret
BSELDSK:
	ld     a,c             ; was 00F498 79
	ld     (FDRVBUF),a
	ret
;;
;; SFDCCMD - send 1771 a command
;
SFDCCMD:
	push   af              ; was 00F49D F5
SNDCL:
	in     a,(FDCCMDSTATR)
	bit    0,a             ; check busy
	jr     nz,SNDCL
	pop    af
	ld     (FCMDBUF),a
	out    (FDCCMDSTATR),a
	ex     (sp),hl
	ex     (sp),hl
	ex     (sp),hl
	ex     (sp),hl
	ret
;;
;; GFDCSTAT - get 1771 status and copy on buffer
;
GFDCSTAT:
	in     a,(FDCCMDSTATR)         ; was 00F4AF DB D0
	bit    0,a
	jr     nz,GFDCSTAT
	ld     (FSTABUF),a
	ret
;
GCURTRK:
	ld     hl,FSEKBUF        ; was 00F4B9 21 4A 00
	ld     a,(FDRVBUF)
	add    a,l
	ld     l,a
	ret
;;
;; BHOME - move head to trak 0 (cp/m home like)
;;
BHOME:
	push   bc              ; was 00F4C2 C5
	ld     b,$03           ; number of retries
FRETR0:	ld     a,FDCRESTC      ; move to trak 0 cmd
	call   SFDCCMD
	call   GFDCSTAT
	and    $18             ; check for errors
	jr     z,FOK0         ; go no
	djnz   FRETR0           ; retry
	ld     a,$82
	jr     FTERR           ; error handle
FOK0:	call   GCURTRK           ; proceed
	jr     FGTRK
;;
;; FSEEK - seek to specific track/sector
;
FSEEK:
	push   bc              ; was 00F4DC C5
	ld     b,$03
	call   GCURTRK
	ld     a,(hl)
	out    (FDCTRAKREG),a
FRETR1:	ld     a,(FSECBUF)
	out    (FDCSECTREG),a
	ld     a,(FTRKBUF)
	out    (FDCDATAREG),a
	ld     a,FDCSEEKC           ; seek cmd
	call   SFDCCMD
	call   GFDCSTAT
	and    $18
	jr     z,FGTRK
	call   BHOME
	jr     nz,FTERR
	djnz   FRETR1
	ld     a,$83
	jr     FTERR
FGTRK:	in     a,(FDCTRAKREG)
	ld     (hl),a
FTERR:	pop    bc
	bit    7,a             ; test if drive not ready
	ret
;;
;; BREAD - read a sector
;
BREAD:
	ld     a,(MIOBYTE)       ; was 00F50D 3A 47 00
	set    0,a
	jr     BWAITIO
;;
;; BWRITE - write a sector
;
BWRITE:
	ld     a,(MIOBYTE)       ; was 00F514 3A 47 00
	res    0,a
;;
;; BWAITIO - read or write a sector depending on MIOBYTE
;
BWAITIO:
	ld     (MIOBYTE),a       ; was 00F519 32 47 00
FRWLP:	call   FSEEK
	jr     nz,FSHTM
	ld     b,$0a           ; 10 retries
FRWNXT:	ld     hl,(FRDPBUF)
	push   bc
	ld     bc,FRWWORD
	ld     a,(MIOBYTE)
	bit    0,a
	jr     z,FRWWRO
	ld     a,FDCREADC           ; read command
	call   SFDCCMD
FRRDY:	in     a,(FDCCMDSTATR)
	bit    1,a             ; sec found
	jr     z,FRRDY
	ini
	jr     nz,FRRDY
	jr     FWEND
FRWWRO:	ld     a,FDCWRITC
	call   SFDCCMD
FWRDY:	in     a,(FDCCMDSTATR)
	bit    1,a
	jr     z,FWRDY
	outi
	jr     nz,FWRDY
FWEND:	call   GFDCSTAT
	pop    bc
	and    $1f             ; test fo errors
	jr     z,FSHTM
	djnz   FRWNXT
	ld     a,(MIOBYTE)
	bit    7,a
	jr     nz,FSHTM
	set    7,a
	ld     (MIOBYTE),a
	call   BHOME
	jr     nz,FSHTM
	jr     FRWLP
FSHTM:	push   af
	xor    a
	out    (FDCDRVRCNT),a
	pop    af
	ret
;;
;; FLOPPYREAD - read from given drv,track,sector,ram address
;
FLOPPYREAD:
	ld     a,(MIOBYTE)       ; was 00F574 3A 47 00
	set    0,a
	jr     FLOPIO
;;
;; FLOPPYWRIT - write to give ram address, sector, track, drive
;
FLOPPYWRIT:
	ld     a,(MIOBYTE)       ; was 00F57B 3A 47 00
	res    0,a
FLOPIO:	ld     (MIOBYTE),a
	ld     b,$04
	call   GETHNUM
	pop    bc
	call   BSETDMA
	pop    bc
	call   BSETSEC
	pop    bc
	call   BSETTRK
	pop    bc
	call   BSELDSK
	call   DRVSEL
	call   FRWLP
	jp     USRCMD
;; Image to initalize location 0010H
CRTTAB1:
	db    $6f,$50,$57,$28,$1a,0,$19,$19,$48,$0b
	db    0,$0b,0,0,0,0,0,0,0,0
;	org $f5b5
;;
;;
;NEDOSINI:
	;; ALIGNMENT trick:
	;; NEDOSINI was the odl entry point. NEDOS related functions
	;; (except general routines like video management) are commented
	;; out and replaced by the new code.
	;; Here we keep in sync with old addresses. This should not be really
	;; necessary, but in a first try i prefer not to change entry points....
;	defs  INIT0 - NEDOSINI
	;; -------------------

; 	ld     c,$00
; 	call   JNXTTR
; 	inc    a
; 	out    (FDCDRVRCNT),a
; 	call   JHOME
; 	jp     nz,UCREJ
; 	jp     JJNDST
; 	nop
; 	nop
;;---------------------------------------------------------------------
;	org    $f5c8
;;
; INIT0 - init buffers,6545,test vram,clear,leave cursor at home
;
INIT0:
	call   INICRT           ; was 00F5C8 CD A5 F0
	call   INICRTREG
	call   DLIGHT
	call   DBLANK
	ld     a,$ff
	ld     (RAM3BUF),a
	ld     hl,$0000
	ld     (CURPBUF),hl
	jp     INICRTCUR
;;
STR100:                        ; was 00F5E2
	db    "Z80 DarkStar - Monitor - rel 1.0"

;;
CRLFTAB:
	db $0d,$8a,$00,$01

;;
;; INICRTREG
;;
INICRTREG:
	call   GDCUA           ; was 00F606 CD B0 F7
	push   hl
	ld     hl,CRTTABUF
	ld     b,$00
	ld     a,b
ICTLP0:	out    (CRT6545ADST),a
	ld     a,(hl)
	out    (CRT6545DATA),a
	inc    hl
	inc    b
	ld     a,b
	cp     $14
	jr     nz,ICTLP0
	ld     hl,(CURPBUF)
	call   SDSTA
	pop    hl
	dec    hl
	jp     SDCUAE
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; BOOT - Bring up system
;;
BOOT:
	; Reset bios position after reset
	in     a,(FDCDRVRCNT)  ; was 00F630 DB D6
	ld     sp,$0080
	ld     hl,CRTTAB1	; copy CRT init tab @ CRTTABUF
	ld     de,CRTTABUF
	ld     bc,$0014
	; TODO: why this copy? verify remotion
	ldir
	ld     hl,$0000
	ld     (CURPBUF),hl
	xor    a
	ld     (CIOBYTE),a
	ld     (COLBUF),a
	ld     (MIOBYTE),a
	cpl
	ld     (RAM3BUF),a
	call   INIT0
	ld     hl,$ffff
	ld     (FSEKBUF),hl
;	ld     ($004c),hl
	xor    a
	out    (CRTPRNTDAT),a
	out    (ALTPRNPRT),a
	cpl
	out    (CRTPRNTDAT),a
	out    (ALTPRNPRT),a
	ld     a,$c3
	ld     ($0008),a
	ld     ($0066),a
	ld     hl,JBOOT
	ld     ($0067),hl
	ld     sp,BJMP5
	db	$3e
;;
;; FMEMSIZ - cerca l'ultima pagina di memoria disponibile
;
FMEMSIZ:
	push   bc              ; was 00F67C C5 !!! NOT EXECUTED IF HERE FROM BOOT
	ld     bc,$ff00
	ld     hl,$ffff
BJMP2:
	inc    h
	ld     a,(hl)
	cpl
	ld     (hl),a
	cp     (hl)
	cpl
	ld     (hl),a
	jr     nz,BJMP1
	ld     a,h
	cp     b
	jr     nz,BJMP2
BJMP1:	
	dec    h
	ld     bc,$ffde
	add    hl,bc
	pop    bc
	ret
;;
;; LPAGE - Find ram last page and return in B
LPAGE:
	push   hl              ; was 00F697 E5
	call   FMEMSIZ
	ld     a,l
	sub    $3d
	jr     nc,BJMP6
	dec    h
BJMP6:
	ld     b,h
BJMP5:	
	pop    hl
	ret
;
BJTAB:                         ; was 00F6A4
	dw    BJTAB+2         ; ovvero f6a6
;
BJMP3:
	;; copy 29 bytes of bios code from RAMBLK to last page of available ram
	ld     sp,hl           ; was 00F6A6 F9	
	ld     de,RAMBLK
	ex     de,hl
	ld     bc,$001d
	ldir
	ld     bc,BTPASIZ
	push   de
	pop    hl
	dec    hl
	ldir
	ld     hl,$ffe8        ; should be a number in 2 compl.
	add    hl,sp
	push   hl
	inc    hl
	inc    hl
	ld     (BTPASIZ),hl
	ld     d,$0a
BJMP4:
	push   bc
	dec    d
	jr     nz,BJMP4
	nop
	nop
	nop
	;; print bios greetings
	ld     hl,STR100        ; was 00F6CB 21 E2 F5
	call   GREET
	jr     USRCMD
;;
GET1HNUM:
	ld     b,$01           ; was 00F6D3 06 01
	ld     hl,$0000
	jr     GENTR
HEHEX:	jr     nz,UCREJ
POP1PRM:
	dec    b
	ret    z
;;
;; GETHNUM - get an hexadecimal string
;
GETHNUM:
	ld     hl,$0000        ; was 00F6DE 21 00 00
GNXTC:	call   DOGETCHR
GENTR:	ld     c,a
	call   CHKHEX
	jr     c,HNHEX         ; if not hex digit
	add    hl,hl
	add    hl,hl
	add    hl,hl
	add    hl,hl
	or     l
	ld     l,a
	jr     GNXTC
HNHEX:	ex     (sp),hl
	push   hl
	ld     a,c
	call   CHKCTR
	jr     nc,HEHEX
	djnz   UCREJ
	ret
;;	
;; USRCMD - display prompt and process user commands
;;
UCREJ:
	ld     hl,URESTR        ; was 00F6FD 21 0F FA
	call   CONSTR
USRCMD:
	ld     hl,(BTPASIZ)      ; was 00F703 2A 06 00
	ld     sp,hl
	ld     hl,USRCMD
	push   hl
	ld     ($0001),hl
	ld     a,$c3
	ld     ($0000),a
	call   OUTCRLF
	call   DOPROMPT
	sub    $41             ; convert to number
	jr     c,UCREJ         ; minor 0
	cp     $1a
	jr     nc,UCREJ        ; greater than jump table
	add    a,a
	ld     e,a
	ld     d,$00
	ld     b,$02
	ld     hl,UCMDTAB
	add    hl,de
	ld     a,(hl)
	inc    hl
	ld     h,(hl)
	ld     l,a
	jp     (hl)
;;
;; FILLMEM - fill memory with a given values
;
FILLMEM:
	call   POP3NUM           ; was 00F730 CD 33 F9
FLME1:	ld     (hl),c
	call   CHKEOR
	jr     nc,FLME1
	pop    de
	jr     USRCMD
;;
;; MEMCOMP - compare two ram regions
MEMCOMP:
	call   POP3NUM           ; was 00F73C CD 33 F9
MCONX:	ld     a,(bc)
	push   bc
	ld     b,(hl)
	cp     b
	jr     z,MCO1
	push   af
	call   HL2ASCB
	ld     a,b
	call   H2AJ3
	pop    af
	call   H2AJ1
MCO1:	pop    bc
	call   IPTRCKBD
	jr     MCONX
;;
;; MEMDUMP - prompt user and dump memory area
;
MEMDUMP:
	call   POP2PRM           ; was 00F757 CD AB FA
MDP6:	call   HL2ASCB
	ld     a,l
	call   DMPALIB
	push   hl
MDP2:	ld     a,(hl)
	call   H2AJ1
	call   CHKEOR
	jr     c,MDP1
	call   SPACER
	ld     a,l
	and    $0f
	jr     nz,MDP2
MDP7:	pop    hl
	ld     a,l
	and    $0f
	call   DMPALIA
MDP5:	ld     a,(hl)
	nop
	nop
	ld     c,a
	cp     $20
	jr     c,MDP3
	nop
	nop
	jr     MDP4
MDP3:	ld     c,$2e
MDP4:	call   OUTCHR
	call   CHKBRK
	ld     a,l
	and    $0f
	jr     nz,MDP5
	jr     MDP6
MDP1:	sub    e
	call   DMPALIB
	jr     MDP7
;;
;; DMPALIB - beginning align (spacing) for a memdump
DMPALIB:
	and    $0f             ; was 00F79B E6 0F
	ld     b,a
	add    a,a
	add    a,b
;;
;; DMPALIB - ascii align (spacing) for a memdump
DMPALIA:
	ld     b,a             ; was 00F7A0 47
	inc    b
ALIBN:	call   SPACER
	djnz   ALIBN
	ret
;;
;; GOEXEC - execute from user address
;
GOEXEC:
	call   POP1PRM           ; was 00F7A8 CD DC F6
	pop    hl
	jp     (hl)
;
; 	nop
; 	nop
; 	nop
;;
;; GET DISPLAY CURSOR POSITION and return in HL
;
GDCUA:
	ld     a,$0e           ; was 00F7B0 3E 0E
	out    (CRT6545ADST),a
	in     a,(CRT6545DATA)
	ld     h,a
	ld     a,$0f
	out    (CRT6545ADST),a
	in     a,(CRT6545DATA)
	ld     l,a
	inc    hl
	ld     a,$1f
	out    (CRT6545ADST),a
	ret
;;
CIJP2:
	out    (CRT6545ADST),a         ; was 00F7C4 D3 8C
	in     a,(CRT6545DATA)
	ld     l,a
	call   SDCUAE
	ex     de,hl
	jp     CIJP3
;;
;; DISPCH - Display a char on CRT at current position
;
DISPCH:
	push   af              ; was 00F7D0 F5
	ld     a,$1f
	out    (CRT6545ADST),a
	ld     a,(RAM3BUF)
	out    (CRTRAM3PORT),a
	pop    af
	out    (CRTRAM0DAT),a
DCLP0:
	in     a,(CRT6545ADST)
	bit    7,a
	jr     z,DCLP0
	xor    a
	out    (CRT6545DATA),a
	ret

CIJP1:
	in     a,(CRT6545ADST)
	bit    6,a
	ret    z
	ld     a,$10
	out    (CRT6545ADST),a
	in     a,(CRT6545DATA)
	ld     h,a
	ld     a,$11
	jp     CIJP2
;;
;; PORTIN - input a byte from given port (display it in binary)
;
PORTIN:
	call   POP1PRM           ; was 00F7F8 CD DC F6
	pop    bc
	in     e,(c)
	jr     BINDISP
;;
;; PORTOUT - output a byte to a give port
PORTOUT:
	call   GETHNUM           ; was 00F800 CD DE F6
	pop    de
	pop    bc
	out    (c),e
	ret
;;
;; MEMMOVE - move data in memory
;
MEMMOVE:
	call   POP3NUM           ; was 00F808 CD 33 F9
MMNXT:	ld     a,(hl)
	ld     (bc),a
	call   IPTRCKBD
	jr     MMNXT
;;
;; RWMEM - lets user alter memory content
;
RWMEM:
	call   POP1PRM         ; was 00F812 CD DC F6
	pop    hl
RWM3:	ld     a,(hl)
	call   H2AJ3
	call   VALGETCHR
	ret    c
	jr     z,RWM1
	cp     $0a
	jr     z,RWM2
	push   hl
	call   GET1HNUM
	pop    de
	pop    hl
	ld     (hl),e
	ld     a,c
	cp     $0d
	ret    z
RWM1:	inc    hl
	inc    hl
RWM2:	dec    hl
	ld     a,l
	and    $07
	call   z,HL2ASCB
	jr     RWM3
;;
;; MEMTEST - test ram region
MEMTEST:
	call   POP2PRM           ; was 00F83A CD AB FA
MTNXT:	ld     a,(hl)
	push   af
	cpl
	ld     (hl),a
	xor    (hl)
	call   nz,MTERR
	pop    af
	ld     (hl),a
	call   CHKBRK
	jr     MTNXT
MTERR:	push   de
	ld     e,a
	call   HL2ASCB
;;
;; BINDISP - display E in binary form
;
BINDISP:
	ld     b,$08           ; was 00F851 06 08
BDNXT:	ld     a,e
	rlca
	ld     e,a
	ld     a,$18
	rla
	ld     c,a
	call   OUTCHR
	djnz   BDNXT
	pop    de
	ret
;;
;; BCONIN - main keyboard input handle
;
CIRBF:	ld     a,$00           ; was 00F861 3E 00
	ld     (KBDBYTE),a
BCONIN:	
	in     a,(CRTKEYBDAT)
	cpl
	bit    7,a
	jr     z,CIRBF
	push   hl
	ld     hl,KBDBYTE
	cp     (hl)
	jr     z,CIEQB
	ld     hl,$a0ff
	jr     CIPRC
CIEQB:	ld     hl,$0400
CIPRC:	push   af
CISTI:	in     a,(CRTKEYBDAT)
	cpl
	bit    7,a             ; is still pressed?
	jr     z,CIGON         ; no, go on
	dec    hl
	ld     a,l
	or     h
	jr     nz,CISTI
CIGON:	pop    af
	ld     (KBDBYTE),a
	res    7,a
	ld     hl,CIOBYTE
	bit    1,(hl)
	ld     hl,MIOBYTE
	jr     nz,CIBT1
CILOP:	bit    3,(hl)
	pop    hl
	ret    z
	cp     $61
	ret    m
	cp     $7b
	ret    p
	res    5,a
	ret
CIBT1:	ld     hl,CIREN
	push   hl
	ld     hl,MIOBYTE
	cp     $5e             ; test == ^
	jr     nz,CITC1
	set    3,(hl)
	ret
CITC1:	cp     $5c             ; test == \
	jr     nz,CITC2
	res    3,(hl)
	ret
CITC2:	cp     $07             ; test == CTRL+G
	jp     z,CIGRTOG
	cp     $05             ; test ==CTRL+E
	jp     z,LINDN
	cp     $13             ; test == CTRL+S
	jp     z,CIHCR
	cp     $04             ; test == CTRL+D
	jp     z,CURRGT
	cp     $18             ; test == CTRL+X
	jp     z,IOCSY2
	pop    hl
	ld     hl,MIOBYTE
	jp     CISTP
CIREN:	pop    hl
	jp     BCONIN
CIHCR:	ld     hl,CIOBYTE
	ld     a,(hl)
	push   af
	push   hl
	set    4,(hl)
	call   IOCBS
	pop    hl
	pop    af
	ld     (hl),a
	ret
CIJP3:
	ld     hl,(CURPBUF)
	ex     de,hl
	xor    a
	sbc    hl,de
	ld     de,$0050
CIJP4:	xor    a
	sbc    hl,de
	jr     nc,CIJP4
	add    hl,de
	ld     a,l
	ld     (COLBUF),a
	ret
;
CISTP:	push   af
	push   de
	call   CIJP1
	pop    de
	pop    af
	jp     CILOP
; 	nop
;;
;; SET DISPLAY START ADDRESS
;	
SDSTA:
	ld     a,$0c           ; was 00F90E 3E 0C
	out    (CRT6545ADST),a
	ld     a,h
	out    (CRT6545DATA),a
	ld     a,$0d
	out    (CRT6545ADST),a
	ld     a,l
	out    (CRT6545DATA),a
	ld     a,$1f
	out    (CRT6545ADST),a
	ret
;;
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; DOPROMPT - display prompt and wait for first key (uppercase)
;
DOPROMPT:
	call   MPROMPT           ; was 00F925 CD 5F FA
DOGETCHR:
	call   COIUPC           ; was 00F928 CD 89 FA
COUTCH:	push   bc
	ld     c,a
	call   OUTCHR
	ld     a,c
	pop    bc
	ret
;
POP3NUM:
	inc    b               ; was 00F933 04
	call   GETHNUM
	pop    bc
	pop    de
	jp     OCRLF1
;;	
CHKEOR:
	inc    hl              ; was 00F93C 23
	ld     a,h
	or     l
	scf
	ret    z
	ld     a,e
	sub    l
	ld     a,d
	sbc    a,h
	ret
;;
CBKEND:	pop    de
	ret
;;
;; inc pointer BC and check kbd
IPTRCKBD:
	inc    bc
;;	
CHKBRK:
	call   CHKEOR           ; was 00F949 CD 3C F9
	jr     c,CBKEND
	call   BCONST
	or     a
	ret    z
	call   COIUPC
	cp     $13
	jr     nz,CBKEND
	jp     COIUPC
;;
;; CHKHEX - check for hex ascii char in A
;
CHKHEX:
	sub    $30             ; was 00F95D D6 30
	ret    c
	cp     $17
	ccf
	ret    c
	cp     $0a
	ccf
	ret    nc
	sub    $07
	cp     $0a
	ret
;; get chr and validate
VALGETCHR:
	call   DOGETCHR           ; was 00F96D CD 28 F9
;; 
;; CHKCTR: check for valid char in string (space,comma,<CR>)
;
CHKCTR:
	cp     $20             ; was 00F970 FE 20
	ret    z
	cp     $2c
	ret    z
	cp     $0d
	scf
	ret    z
	ccf
	ret
;;
;; This seem an unreferenced piece of code
;;
; 	push   hl              ; was 00F97C E5
; 	push   de
; 	push   bc
; 	push   af
; 	call   FMEMSIZ
; 	ex     de,hl
; 	ld     hl,$000a
; 	add    hl,sp
; 	ld     b,$04
; 	ex     de,hl
; CCJP1:	dec    hl
; 	ld     (hl),d
; 	dec    hl
; 	ld     (hl),e
; 	pop    de
; 	djnz   CCJP1
; 	pop    bc
; 	dec    bc
; 	ld     sp,hl
; 	ld     hl,APPBUF
; 	add    hl,sp
; 	push   de
; 	ld     d,$02
; CCJP3:	ld     a,(hl)
; 	sub    c
; 	inc    hl
; 	ld     a,(hl)
; 	sbc    a,b
; 	jr     z,CCJP2
; 	inc    hl
; 	inc    hl
; 	dec    d
; 	jr     nz,CCJP3
; 	inc    bc
; CCJP2:	ld     hl,$0020
; 	pop    de
; 	add    hl,sp
; 	ld     (hl),e
; 	inc    hl
; 	ld     (hl),d
; 	push   bc
; 	ld     c,$2a
; 	call   OUTCHR
; 	pop    de
; 	ld     a,$e5
; 	cp     d
; 	jr     z,CCJP4
; 	inc    hl
; 	inc    hl
; 	ld     (hl),e
; 	inc    hl
; 	ld     (hl),d
; 	ex     de,hl
; 	call   H2AEN1
; CCJP4:	ld     hl,APPBUF
; 	add    hl,sp
; 	ld     bc,$0200
; CCJP6:	ld     e,(hl)
; 	ld     (hl),c
; 	inc    hl
; 	ld     d,(hl)
; 	ld     (hl),c
; 	inc    hl
; 	ld     a,e
; 	or     d
; 	jr     z,CCJP5
; 	ld     a,(hl)
; 	ld     (de),a
; CCJP5:	inc    hl
; 	djnz   CCJP6
; 	ex     af,af'
; 	exx
; 	push   hl
; 	push   de
; 	push   bc
; 	push   af
; 	push   ix
; 	push   iy
; 	ld     a,i
; 	ld     b,a
; 	ld     a,r
; 	ld     c,a
; 	push   bc
; 	jp     $f307
; 	push   hl
; 	rst    08h
;;
;; Questo blocco di istruzioni viene copiato nell'ultima pagina di memoria ram
;; nei suoi ultimi byte (dfdd della pagina df00-dfff)
;; ... perche'???
;
RAMBLK:
	pop    bc              ; was 00F9F2 C1
	ld     a,c
	ld     r,a
	ld     a,b
	ld     i,a
	pop    ix
	pop    iy
	pop    af
	pop    bc
	pop    de
	pop    hl
	ex     af,af'
	exx
	pop    de
	pop    bc
	pop    af
	pop    hl
	ld     sp,hl
	nop
	ld     hl,$0000
	jp     $0000
;
;; User command reject string
URESTR:
	db     $aa               ; was 00FA0F AA
;
;; TOGPRNIO - toggle i/o on prn/crt
TOGPRNIO:
	ld     hl,MIOBYTE        ; was 00FA10 21 47 00
	bit    4,(hl)
	jr     z,TOGPR
	res    4,(hl)
	jr     TOGJU
TOGPR:	set    4,(hl)
TOGJU:	jp     USRCMD
;;
;; SCRTST - Verify if we need video scroll
;
SCRTST:	
	ld     de,(CURPBUF)      ; was 00FA20 ED 5B 48 00
	xor    a
	sbc    hl,de
	ld     a,h
	cp     $07
	ret    c
	ld     a,l
	cp     $cf
	ret
;;
;; unreferenced piece of code
;;
	nop
	or     a
	ld     a,h
	rra
	ld     h,a
	ld     a,l
	rra
	ld     l,a
	ret
;;
;; CALCHLDE - perform 16 bit add & sub between HL and DE
;
CALCHLDE:
	call   POP2PRM           ; was 00FA38 CD AB FA
	push   hl
	add    hl,de
	call   HL2ASCB
	pop    hl
	or     a
	sbc    hl,de
	jr     H2AEN1
;;	
;; HL2ASC - convert & display HL 2 ascii
HL2ASC:
	call   OUTCRLF           ; was 00FA46 CD B0 FA
H2AEN1:	ld     a,h
	call   H2AJ1
	ld     a,l
H2AJ1:	push   af
	rrca
	rrca
	rrca
	rrca
	call   H2AJ2
	pop    af
H2AJ2:	call   NIB2ASC
	jr     OUTCHR
H2AJ3:	call   H2AJ1           ; entry point to display HEX and a "-"
MPROMPT:
	ld     c,$2d
	jr     OUTCHR
;;	
;; HL2ASCB - convert & display HL 2 ascii leave a blank after
HL2ASCB:
	call   HL2ASC           ; was 00FA63 CD 46 FA
SPACER:	ld     c,$20
;;
;; OUTCHR - send a char to the output
;; switch CRT/PRINTER depending of bit 4 of MIOBYTE
;
OUTCHR:
	ld     a,(MIOBYTE)       ; was 00FA68 3A 47 00
	bit    4,a
	jr     z,OCJPV
	call   JPRNCH
OCJPV:
	jp     JCONOU
;;
;; PRNCHR - send a char to printer port (from C)
;
PRNCHR:
	in     a,(CRTSERVDAT)         ; was 00FA75 DB 89
	bit    PRNTBUSYBIT,a
	jr     nz,PRNCHR
	ld     a,c
	out    (CRTPRNTDAT),a
	ret
;;
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; COIUPC- convert reg A uppercase
COIUPC:
	call   JCONIN           ; was 00FA89 CD 03 F0
	cp     $60
	jp     m,COIRE
	cp     $7b
	jp     p,COIRE
	res    5,a
COIRE:	ret
;;
;; 
;; GREET - ...comes here from boot...
;
GREET:
	call   OUTCRLF           ; was 00FA99 CD B0 FA
;;
;; CONSTR print a string using OUTCHR -> BCONOUT
CONSTR:
	push   bc              ; was 00FA9C C5
CSLP0:	ld     c,(hl)
	ld     b,(hl)
	res    7,c
	call   OUTCHR
	inc    hl
	ld     a,b
	rlca
	jr     nc,CSLP0
	pop    bc
	ret
;;
POP2PRM:
	call   GETHNUM           ; was 00FAAB CD DE F6
	pop    de
	pop    hl
;;
;; OUTCRLF - CR/LF through BCONOUT
;
OUTCRLF:
	push   hl              ; was 00FAB0 E5
OCRLF1:	ld     hl,CRLFTAB
	call   CONSTR
	pop    hl
	ret
;;
BCONST:
	in     a,(CRTKEYBDAT)         ; was 00FAB9 DB 85
	cpl
	bit    7,a
	ld     a,$00
	jr     BCONSTJ
;;
;; ???
;; called by monitor with key command "Z"
;; loop until you press two times CTRL+G
;; ???   8-?
BLOOP:
	ld     b,$02           ; was 00FAC2 06 02
BLP1:	call   COIUPC
	cp     $07
	jr     nz,BLOOP
	call   COUTCH
	djnz   BLP1
	ret
;
;	nop
UCMDTAB:
	dw     UCREJ           ; (A) n/a
	dw     JCPMBT          ; (B) cp/m boot
	dw     UCREJ           ; (C) n/a
	dw     MEMDUMP         ; (D) dump memory
	dw     UCREJ           ; (E) n/a
	dw     FILLMEM         ; (F) fill memory
	dw     GOEXEC          ; (G) go exec a sub
	dw     CALCHLDE        ; (H) sum & subtract HL, DE
	dw     PORTIN          ; (I) port input
	dw     INIT0           ; (J) init, clear screen
	dw     JBOOT           ; (K) restart system
	dw     FLOPPYREAD      ; (L) read floppy,track,sec to ram
	dw     MEMMOVE         ; (M) move memory block
;	dw     NEDOSINI        ; (N) NEDOS boot page
	dw     UCREJ           ; (N) n/a
	dw     PORTOUT         ; (O) output to a port
	dw     TOGPRNIO        ; (P) toggle prn/crt i/o
	dw     UCREJ           ; (Q) n/a
	dw     FLOPPYWRIT      ; (R) write floppy,track,sec to ram
	dw     RWMEM           ; (S) alter memory
	dw     MEMTEST         ; (T) test ram region
;	dw     UCREJ           ; (U) n/a
	dw     UPLOAD          ; (U) Parallel Upload
	dw     MEMCOMP         ; (V) compare mem blocks
	dw     PDNLOAD         ; (W) Parallel DoWnload
	dw     UCREJ           ; (X) n/a
	dw     INICRTREG       ; (Y) reinit 6545
	dw     BLOOP           ; (Z) bloop - crazy routine
;;
;	nop
;
BCONSTJ:
	ret z                  ; was 00FB07 C8
	cpl
	ret
;	
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; BCONOUT print out the char in reg C
;
BCONOUT:
	push   af              ; was 00FB10 F5
	push   bc
	push   de
	push   hl
	; force jump to register restore and exit in stack
	ld     hl,VCRESREG
	push   hl
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
	ld     a,c
	ld     hl,CIOBYTE
;; bit 7 ??
	bit    7,(hl)
	ex     de,hl
	jp     nz,CONOU2
	cp     $20             ; is less then 0x20 (space)
	jr     nc,COJP1        ; no..
	ld     hl,IOCVEC
	add    a,l
	ld     l,a
	ld     c,(hl)
	ld     b,$00
	or     a
	ld     hl,IOCBASE
	add    hl,bc
	jp     (hl)            ; jump to IOCVEC handler
COJP1:	ex     de,hl
	bit    6,(hl)
	jr     z,COJP2
	cp     $40
	jr     c,COJP2
	cp     $60
	jr     nc,COJP2
	sub    $40
COJP2:	call   DISPCH
	; move cursor right
CURRGT:
	call   GDCUA
	call   SDCUAE
	ld     a,(COLBUF)
	inc    a
	cp     $50
	jr     z,MOVDN
;;	
SAVCOLB:
	ld     (COLBUF),a
	ret
;;
;; MOVDN: down one line, scroll, home, clreol
;
MOVDN:
	xor    a               ; was 00FB60 AF
	ld     (COLBUF),a
MOVDN1:	call   SCRTST
	ret    c
	ld     hl,CIOBYTE
	bit    2,(hl)
	ld     de,$f830
	call   GDCUA
	dec    hl
	jr     z,MDJMP0
	add    hl,de
	jp     SDCUAE
MDJMP0:	push   hl
	call   CLRLIN
	ld     hl,(CURPBUF)
	ld     de,$0050
	add    hl,de
	ld     de,$0820
	push   hl
	sbc    hl,de
	pop    hl
	jr     c,MDJMP1
	res    3,h
MDJMP1:	ld     (CURPBUF),hl
	call   SDSTA
	jr     MOVEND
CONOU2:
	cp     $20             ; was 00FB98 FE 20
	jr     nc,C2JP1
	ld     hl,IOCVEC2
	add    a,l
	ld     l,a
	ld     c,(hl)
	ld     b,$00
	or     a
	ld     hl,IOCBAS2
	add    hl,bc
	nop
	jp     (hl)
C2JP1:	ex     de,hl
	bit    0,(hl)
	jr     nz,C2JP2
	cp     $70
	ret    nc
	sub    $20
	ld     (APPBUF),a
	set    0,(hl)
	ret
C2JP2:	cp     $39
	ret    nc
	sub    $1f
	res    7,(hl)
	res    0,(hl)
	ld     b,a
UKR14:	ld     hl,$ffb0
	ld     de,$0050
C2JP3:	add    hl,de
	djnz   C2JP3
	ld     a,(APPBUF)
	ld     (COLBUF),a
	ld     e,a
	add    hl,de
	ex     de,hl
	ld     hl,(CURPBUF)
	add    hl,de
	jp     SDCUAE
VCRESREG:
	pop    hl
	pop    de
	pop    bc
	pop    af
	ret
;; MOVEND
;
MOVEND:
	pop    hl              ; was 00FBE3 E1
	jr     c,MEJP
	res    3,h
MEJP:	jp     SDCUAE
;
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
CURBLB:
	ld     l,$40           ; (0 10 00000) 1/16 blink scan 0
	jr     CURSETMODE
CURBLL:
	ld     l,$4a           ; (0 10 01010) 1/16 blink scan 10
	jr     CURSETMODE
CURBFB:
	ld     l,$60           ; (0 11 00000) 1/32 blink scan 0
	jr     CURSETMODE
CURBFL:
	ld     l,$6a           ; (0 11 01010) 1/32 blink scan 10
	jr     CURSETMODE
CUROFB:
	ld     l,$20           ; (0 01 00000) no cursor scan 0
	jr     CURSETMODE
CURFXB:
	ld     l,$00           ; (0 00 00000) fixed scan 0
	jr     CURSETMODE
CURFXL:
	ld     l,$0a           ; (0 00 01010) fixed scan 10
CURSETMODE:
	ld     a,$0a           ; was 00FC0A 3E 0A
	out    (CRT6545ADST),a
	ld     a,l
	out    (CRT6545DATA),a
	ld     a,$1f
	out    (CRT6545ADST),a
	ret
;;
;; DLIGHT
;; fill video ram (2k) with ff's
;
DLIGHT:
	ld     hl,$ffff        ; was 00FC16 21 FF FF
	ld     (RAM0BUF),hl
	ld     a,$ff
	ld     (RAM2BUF),a
	jp     CRTFIL
;;
;; DISMVC display char and move cursor
;
DISMVC:
	call   DISPCH           ; was 00FC24 CD D0 F7
	jp     SDCUAE
;;	
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; IOCBASE (a void routine) from here a list of routines to handle
;; console char output
;
IOCBASE:	
	ret                    ; was 00FC30 C9
;
IOCSOH:
	ex     de,hl
	set    3,(hl)
	ret
IOCSTX:
	ex     de,hl
	res    3,(hl)
	ret
;;	
;; INICRTCUR - init CRT cursor at CURPBUF
;
INICRTCUR:
	ld     hl,(CURPBUF)
	call   SDCUAE
	xor    a
	jp     SAVCOLB
;;	
;; IOCBEL - sound beep
IOCBEL:
	out    (CRTBEEPPORT),a
	ret
;;
;;
;
IOCBS:
	call   GDCUA
	dec    hl
	ld     de,(CURPBUF)
	xor    a
	sbc    hl,de
	cp     h
	jr     nz,IOCBS1
	cp     l
	ret    z
IOCBS1:	dec    hl
	add    hl,de
	call   SDCUAE
	push   hl
	ld     a,(COLBUF)
	dec    a
	cp     $ff
	jr     nz,IOCBS2
	ld     a,$4f
IOCBS2:	ld     (COLBUF),a
	ld     hl,CIOBYTE
	bit    4,(hl)
	pop    hl
	ret    nz
	ld     a,$20
	jp     DISMVC
;;
;; CHOME - move cursor at col 0
;
CHOME:
	ld     hl,COLBUF
	ld     e,(hl)
	xor    a
	ld     (hl),a
	ld     d,a
	call   GDCUA
	dec    hl
	sbc    hl,de
	call   SDCUAE
	ret
;;
;; CLRSCR - clear screen (ASCII mode)
;
CLRSCR:
	ld     hl,$0000
	xor    a
	ld     (COLBUF),a
	cpl
	ld     (RAM3BUF),a
	ld     (CURPBUF),hl
	call   SDCUAE
	call   SDSTA
	push   hl
CLSNC:	ld     a,$20
	call   DISPCH
	inc    hl
	ld     a,h
	cp     $08
	jr     nz,CLSNC
	pop    hl
	jp     SDCUAE
;; IOCCR - handle carriage return (0x0d)
;; should position the cursor at col 0
;
IOCCR:
	ex     de,hl
	bit    3,(hl)
	jr     z,IOCCR1
	call   CLREOL
IOCCR1:	jp     CHOME
;;
IOCSO:
	xor    a
	ld     hl,(CURPBUF)
	ld     de,$07d0
	add    hl,de
	ex     de,hl
	call   GDCUA
	dec    hl
	ex     de,hl
	sbc    hl,de
	push   hl
	pop    bc
CLRJ0:	call   CLRLIN1
	ex     de,hl
	jp     SDCUAE
IOCENQ:
	jp     CURBFL
IOCUS:	
	jp     SET3MIOB
;
; 	nop
; 	nop
;;
;; CLREOL - clear to end of line
;
CLREOL:
	ld     a,(COLBUF)
	ld     b,a
	ld     a,$50
	sub    b
	ld     b,$00
	ld     c,a
	call   GDCUA
	dec    hl
	ex     de,hl
	jp     CLRJ0
;;
IOCSYN:
	ex     de,hl
	set    2,(hl)
	ret
IOCETB:
	ex     de,hl
	res    2,(hl)
	ret
IOCFS:
	ex     de,hl
	res    1,(hl)
	ret
IOCGS:
	ex     de,hl
	set    1,(hl)
	ret
IOCESC:
	ex     de,hl
	set    7,(hl)
	ret
;;
;; IOCLF - line feed handle
IOCLF:
	jp     LINDN
;;
;; RESATTR - reset all attributes
;
RESATTR:
	ld     a,$ff
	ld     (RAM3BUF),a
	ret
;;	
IOCCAN:
	jp     INIT0
IOCRS:
	jp     OUTGRBUF
IOCEOT:
	jp     CURBFB
	
; 	nop
;;
;; IOCBASE2 (a void routine) from here a list of routines to handle
;; console char output
;; This is the same as IOCBASE but when bit 7 of CIOBYTE is set
;
IOCBAS2:
	ret                    ; was 00FD0F C9
IOCNAK:
	jp     CURRGT
IOCSY2:	
	call   GDCUA
	ld     de,$ffaf
	add    hl,de
	ex     de,hl
	ld     hl,(CURPBUF)
	ex     de,hl
	xor    a
	sbc    hl,de
	cpl
	cp     h
	add    hl,de
	ret    z
	jp     SDCUAE
IOCUS2:
	jp     RES3MIOB
; 	nop
; 	nop
; 	nop
IOCCA2:
	ex     de,hl
	res    6,(hl)
	ret
IOCEM:
	ex     de,hl
	set    4,(hl)
	ret
IOCSUB:
	ex     de,hl
	res    4,(hl)
	ret
IOCSO2:
	ld     hl,RAM3BUF
	set    0,(hl)
	ret
IOCFS2:
	ld     hl,RAM3BUF
	set    1,(hl)
	ret
IOCETX:
	ld     hl,RAM3BUF
	set    2,(hl)
	ret
IOCEN2:
	ld     hl,RAM3BUF
	set    3,(hl)
	ret
IOCBE2:
	ld     hl,RAM3BUF
	set    4,(hl)
	ret
IOCS2:
	ld     hl,RAM3BUF
	set    5,(hl)
	ret
IOCDLE:
	ld     hl,RAM3BUF
	set    6,(hl)
	ret
IOCGS2:
	ld     hl,RAM3BUF
	set    7,(hl)
	ret
IOCST2:
	ld     hl,RAM3BUF
	res    0,(hl)
	ret
IOCES2:
	ld     hl,RAM3BUF
	res    1,(hl)
	ret
IOCEO2:
	ld     hl,RAM3BUF
	res    2,(hl)
	ret
IOCAC2:
	ld     hl,RAM3BUF
	res    3,(hl)
	ret
IOCHT:
	ld     hl,RAM3BUF
	res    4,(hl)
	ret
IOCSI2:
	ld     hl,RAM3BUF
	res    5,(hl)
	ret
IOCD12:
	ld     hl,RAM3BUF
	res    6,(hl)
	ret
IOCRS2:
	ld     hl,RAM3BUF
	res    7,(hl)
	ret
;;
;; LINDN - cursor down one line
;
LINDN:
	call   GDCUA
	dec    hl
	ld     de,$0050
	add    hl,de
	call   SDCUAE
	jp     MOVDN1
;;
IOCNUL:
	ex     de,hl
	res    7,(hl)
	ret
;
IOCDC2:
	jp     CURBLB
IOCDC3:
	jp     CURBLL
IOCET2:	
	ex     de,hl
	set    6,(hl)
	ret
	
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; CLRLIN - clear current line
;
CLRLIN:
	ld     bc,$0050        ; was 00FDC0 01 50 00
CLRLIN1:
	ld     a,(RAM3BUF)
	push   af
	ld     a,$ff
	ld     (RAM3BUF),a
CLRLP1:	ld     a,$20
	call   DISPCH
	dec    bc
	ld     a,b
	or     c
	jr     nz,CLRLP1
	pop    af
	ld     (RAM3BUF),a
	ret
;;
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;;
;; NIB2ASC convert lower nibble in reg A to ascii in reg C
;
NIB2ASC:
	and    $0f             ; was 00FDE0 E6 0F
	add    a,$90
	daa
	adc    a,$40
	daa
	ld     c,a
	ret
IOCVT2:
	jp     CURFXL
; 	nop
; 	nop
; 	nop
IOCFF2:
	jp     DBLANK
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;; This table define the offsets to jump from
;; IOCBASE (IOCBASE+IOCVEC) to a set fo routines that
;; handles cntrl char < 0x20 when we are in BCONOUT 
IOCVEC:
	db    IOCBASE-IOCBASE          ; NUL 0x00 (00)  no-op
	db    IOCSOH-IOCBASE           ; SOH 0x01 (01)  set bit 3 (de)
	db    IOCSTX-IOCBASE           ; STX 0x02 (05)  res bit 3 (de)
	db    IOCBASE-IOCBASE          ; ETX 0x03 (00)  no-op
	db    IOCEOT-IOCBASE           ; EOT 0x04 (db)  cursor blink fast block
	db    IOCENQ-IOCBASE           ; ENQ 0x05 (9e)  cursor blink fast line
	db    IOCACK-IOCBASE           ; ACK 0x06 (09)  locate cursor at CURPBUF
	db    IOCBEL-IOCBASE           ; BEL 0x07 (13)  beep
	db    IOCBS-IOCBASE            ; BS  0x08 (16)  cursor back
	db    IOCBASE-IOCBASE          ; HT  0x09 (00)  no-op
	db    IOCLF-IOCBASE            ; LF  0x0a (cc)  cursor down one line
	db    IOCVT-IOCBASE            ; VT  0x0b (45)  cursor home
	db    IOCFF-IOCBASE            ; FF  0x0c (56)  page down (clear screen)
	db    IOCCR-IOCBASE            ; CR  0x0d (7a)  cursor home
	db    IOCSO-IOCBASE            ; SO  0x0e (85)  to end of page clear line
	db    IOCSI-IOCBASE            ; SI  0x0f (a6)  clear to EOL
	db    IOCBASE-IOCBASE          ; DLE 0x10 (00)  no-op
	db    IOCDC1-IOCBASE           ; DC1 0x11 (cf)  reset all attributes
	db    IOCBASE-IOCBASE          ; DC2 0x12 (00)  no-op
	db    IOCBASE-IOCBASE          ; DC3 0x13 (00)  no-op
	db    IOCBASE-IOCBASE          ; DC4 0x14 (00)  no-op
	db    IOCBASE-IOCBASE          ; NAK 0x15 (00)  no-op
	db    IOCSYN-IOCBASE           ; SYN 0x16 (b8) set bit 2 of (de)
	db    IOCETB-IOCBASE           ; ETB 0x17 (bc) res bit 2 of (de)
	db    IOCCAN-IOCBASE           ; CAN 0x18 (d5) hard crt reset and clear
	db    IOCBASE-IOCBASE          ; EM  0x19 (00)  no-op
	db    IOCBASE-IOCBASE          ; SUB 0x1a (00)  no-op
	db    IOCESC-IOCBASE           ; ESC 0x1b (c8) set bit 7 of (de)
	db    IOCFS-IOCBASE            ; FS  0x1c (c0) res bit 1 of (de)
	db    IOCGS-IOCBASE            ; GS  0x1d (c4) set bit 1 of (de)
	db    IOCRS-IOCBASE            ; RS  0x1e (d8) display graphic buffer (ram[012]buf)
	db    IOCUS-IOCBASE            ; US  0x1f (a1) set bit 1 of (de)
;; This table define the offsets to jump from
;; IOCBAS2 (IOCBAS2+IOCVEC2) to a set fo routines that
;; handles cntrl char < 0x20 when we are in BCONOUT 
IOCVEC2:
	db    IOCNUL-IOCBAS2           ; NUL 0x00 (9a)  res bit 7 (de)
	db    IOCSO2-IOCBAS2           ; SOH 0x01 (2c)  set bit 0 RAM3BUF
	db    IOCST2-IOCBAS2           ; STX 0x02 (5c)  res bit 0 RAM3BUF
	db    IOCETX-IOCBAS2           ; ETX 0x03 (38)  set bit 2 RAM3BUF
	db    IOCEO2-IOCBAS2           ; EOT 0x04 (68)  res bit 2 RAM3BUF
	db    IOCEN2-IOCBAS2           ; ENQ 0x05 (3e)  set bit 3 RAM3BUF
	db    IOCAC2-IOCBAS2           ; ACK 0x06 (6e)  res bit 3 RAM3BUF
	db    IOCBE2-IOCBAS2           ; BEL 0x07 (44)  set bit 4 RAM3BUF
	db    IOCBAS2-IOCBAS2          ; BS  0x08 (00)  no-op
	db    IOCHT-IOCBAS2            ; HT  0x09 (74)  res bit 4 RAM3BUF
	db    IOCBAS2-IOCBAS2          ; LF  0x0a (00)  no-op
	db    IOCVT2-IOCBAS2           ; VT  0x0b (db)  cursor fixed line
	db    IOCFF2-IOCBAS2           ; FF  0x0c (e1)  clear screen
	db    IOCBAS2-IOCBAS2          ; CR  0x0d (00)  cursor home
	db    IOCS2-IOCBAS2            ; SO  0x0e (4a)  set bit 4 RAM3BUF
	db    IOCSI2-IOCBAS2           ; SI  0x0f (7a)  res bit 4 RAM3BUF
	db    IOCDLE-IOCBAS2           ; DLE 0x10 (50)  set bit 6 RAM3BUF
	db    IOCD12-IOCBAS2           ; DC1 0x11 (80)  res bit 6 RAM3BUF
	db    IOCDC2-IOCBAS2           ; DC2 0x12 (9e)  cursor blink slow block
	db    IOCDC3-IOCBAS2           ; DC3 0x13 (a1)  cursor blink slow line
	db    IOCDC4-IOCBAS2           ; DC4 0x14 (8c)  cursor down one line
	db    IOCNAK-IOCBAS2           ; NAK 0x15 (01)  cursor right
	db    IOCSY2-IOCBAS2           ; SYN 0x16 (04)  cursor up one line
	db    IOCET2-IOCBAS2           ; ETB 0x17 (a4)  set bit 6 of (de)
	db    IOCCA2-IOCBAS2           ; CAN 0x18 (20)  res bit 6 of (de)
	db    IOCEM-IOCBAS2            ; EM  0x19 (24)  set bit 4 of (de)
	db    IOCSUB-IOCBAS2           ; SUB 0x1a (28)  res bit 4 of (de)
	db    IOCES2-IOCBAS2           ; ESC 0x1b (62)  res bit 1 RAM3BUF
	db    IOCFS2-IOCBAS2           ; FS  0x1c (32)  set bit 1 RAM3BUF
	db    IOCGS2-IOCBAS2           ; GS  0x1d (56)  set bit 7 RAM3BUF
	db    IOCRS2-IOCBAS2           ; RS  0x1e (86)  res bit 7 RAM3BUF
	db    IOCUS2-IOCBAS2           ; US  0x1f (1a)  res bit 3 of MIOBYTE
;;
;; DBLANK
;; fill video ram (2k) with 0's
;	
DBLANK:
	ld     hl,$0000        ; was 00FE40 21 00 00
	ld     (RAM0BUF),hl
	xor    a
	ld     (RAM2BUF),a
;;
;; CRTFIL - Fill video ram with ram buffer chrs
;
CRTFIL:
	ld     a,$ef           ; was 00FE4A 3E EF
	ld     (RAM3BUF),a
	ld     hl,$0000
	ld     (CURPBUF),hl
	call   RDRR19R12
CFIL1:	push   hl
	call   DISPGR
	pop    hl
	inc    hl
	ld     a,h
	cp     $08
	jr     nz,CFIL1
	jp     RDRR19R12
;;
;; DISPGR - absolutely the same of DISPGR but takes chars from locs
;; 002a/b/c WHY THIS???
;	
DISPGR:
	in     a,(CRT6545ADST)         ; was 00FE66 DB 8C
	bit    7,a
	jr     z,DISPGR
DISPNORTR:
	ld     hl,RAM0BUF
	ld     a,(hl)
	out    (CRTRAM0DAT),a
	inc    hl
	ld     a,(hl)
	out    (CRTRAM1DAT),a
	inc    hl
	ld     a,(hl)
	out    (CRTRAM2DAT),a
	ld     a,(RAM3BUF)
	out    (CRTRAM3PORT),a
	xor    a
	out    (CRT6545DATA),a
	ret

;;	
; 	nop
; UKR13:	call   GDCUA
; 	push   hl
; 	ld     a,(COLBUF)
; 	push   af
; 	jp     UKR04
; 	nop
; UKR03:	ld     a,($002d)
; 	cp     $a0
; 	ret    nc
; 	ld     b,a
; 	xor    a
; 	bit    7,b
; 	jr     z,UKR05
; 	ld     a,$20
; UKR05:	bit    6,b
; 	jr     z,UKR06
; 	add    a,$10
; UKR06:	bit    5,b
; 	jr     z,UKR07
; 	add    a,$08
; UKR07:	bit    4,b
; 	jr     z,UKR08
; 	add    a,$04
; UKR08:	bit    3,b
; 	jr     z,UKR09
; 	add    a,$02
; UKR09:	bit    2,b
; 	jr     z,UKR10
; 	add    a,$01
; UKR10:	ld     hl,$002f
; 	bit    0,(hl)
; 	jr     z,UKR11
; 	add    a,$28
; UKR11:	ld     (APPBUF),a
; 	ld     a,b
; 	and    $03
; 	ld     e,a
; 	ld     a,($002e)
; 	cp     $95
; 	ret    nc
; 	ld     b,$01
; UKR12:	sub    $06
; 	jr     c,UKR20
; 	inc    b
; 	jr     UKR12
; UKR20:	add    a,$06
; 	ld     d,a
; 	jp     UKR13
; UKR04:	nop
; 	push   de
; 	call   UKR14
; 	pop    de
; 	ld     hl,RAM0BUF
; UKR15:	in     a,(CRT6545ADST)
; 	bit    7,a
; 	jr     z,UKR15
; 	in     a,(CRTRAM0DAT)
; 	ld     (hl),a
; 	inc    hl
; 	in     a,(CRTRAM1DAT)
; 	ld     (hl),a
; 	inc    hl
; 	in     a,(CRTRAM2DAT)
; 	ld     (hl),a
; 	ld     a,(RAM3BUF)
; 	res    4,a
; 	ld     (RAM3BUF),a
; 	ld     hl,RAM0BUF
; 	bit    1,d
; 	jr     z,UKR16
; 	inc    hl
; 	jr     UKR17
; UKR16:	bit    2,d
; 	jr     z,UKR17
; 	inc    hl
; 	inc    hl
; UKR17:	ld     a,e
; 	bit    0,d
; 	jr     z,UKR18
; 	add    a,$04
; UKR18:	rlca
; 	rlca
; 	rlca
; 	ex     de,hl
; 	ld     hl,$002f
; 	bit    1,(hl)
; 	jr     z,UKR21
; 	set    6,a
; UKR21:	or     $86
; 	ld     hl,UR200
; 	push   hl
; 	ld     ($002d),sp
; 	ld     hl,($002d)
; 	dec    hl
; 	ld     (hl),$c9
; 	dec    hl
; 	ld     (hl),a
; 	dec    hl
; 	ld     (hl),$cb
; 	dec    hl
; 	ld     (hl),$eb
; 	jp     (hl)
;;
;; CIGRTOG - toggle graphic mode on
;
CIGRTOG:	
	in     a,(CRT6545ADST)         ; was 00FF40 DB 8C
	bit    7,a
	jr     z,CIGRTOG
	in     a,(CRTRAM3PORT)
	set    4,a
	ld     (RAM3BUF),a
	in     a,(CRTRAM0DAT)
	pop    hl
	pop    hl
	ret
;
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
; 	nop
;; 
;; OUTGRBUF - set graphic mode, display RAM[012]BUF and revert to ascii
;
OUTGRBUF:
	call   GDCUA           ; was 00FF59 CD B0 F7
	dec    hl
	ld     a,(RAM3BUF)
	push   af
	push   hl
	res    4,a
	ld     (RAM3BUF),a
	call   DISPGR
	pop    hl
	pop    af
	ld     (RAM3BUF),a
	jp     SDCUAE
;
; 	nop
; 	nop
; UR200:
; 	call   DISPGR
; 	pop    af
; 	ld     (COLBUF),a
; 	pop    hl
; 	dec    hl
; 	jp     SDCUAE
; 	call   GDCUA
; 	dec    hl
; 	push   hl
; 	ld     hl,$0000
; UR206:	ld     b,$19
; 	push   bc
; 	ld     b,$50
; UR205:	call   SDCUAE
; UR201:	in     a,(CRT6545ADST)
; 	bit    7,a
; 	jr     z,UR201
; 	in     a,(CRTRAM3PORT)
; 	bit    4,a
; 	jr     nz,UR202
; UR204:	ld     a,$20
; 	jr     UR203
; UR202:	in     a,(CRTRAM0DAT)
; 	cp     $20
; 	jr     c,UR204
; UR203:	call   PRNCHR
; 	call   GDCUA
; 	djnz   UR205
; 	ld     a,$0d
; 	call   PRNCHR
; 	ld     a,$0a
; 	call   PRNCHR
; 	pop    bc
; 	djnz   UR206
; 	pop    hl
; 	jp     SDCUAE
; 	nop
;;
;; UKROUT - unknow routine probably related to graphic output
;; wiped out for now....
;
; UKROUT:
; 	push   de
; 	ld     e,(hl)
; 	inc    hl
; 	ld     d,(hl)
; 	ld     hl,$00a0
; 	ex     de,hl
; 	xor    a
; 	ld     a,$01
; 	sbc    hl,de
; 	jr     nc,UKR01
; 	add    hl,de
; 	dec    a
; UKR01:	ld     ($002f),a
; 	ld     a,l
; 	ld     ($002d),a
; 	pop    de
; 	ld     a,(de)
; 	ld     ($002e),a
; 	ld     a,(bc)
; 	bit    0,a
; 	ld     hl,$002f
; 	jr     nz,UKR02
; 	set    1,(hl)
; 	jr     UKR19
; UKR02:	res    1,(hl)
; UKR19:	jp     UKR03
; 	nop
; 	nop

SET3MIOB:
	ld     hl,MIOBYTE        ; was 00FFF0 21 47 00
	set    3,(hl)
	ret
RES3MIOB:	
	ld     hl,MIOBYTE        ; was 00FFF6 21 47 00
	res    3,(hl)
	ret

EPFILL:
	defs	JBOOT + $0fff - EPFILL + 1
;; 
;; end of monitor code - this will fill with zeroes to the end of
;; the eprom

;
wsym darkstar.sym
;
