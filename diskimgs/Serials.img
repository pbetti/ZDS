ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее 16C550  TXT 2 Ђ     	 
   COMMON  INC   Ђ         COMMON  INCH                 CRTC    INC @ g          DARKSTAREQU                 GENIO   INC g                 SERT    ASM &                 SERT    BIN                   SERT    LST   Ђ! " # $ % & ' (  SERT    LST  Ђ) * + , - . / 0  SERT    LST  Ђ1 2 3 4 5 6 7 8  SERT    LST  Ђ9 : ; < = > ? @  SERT    LST  ЂA B C D E F G H  SERT    LSTj *I J K            SIO     Z80 { L M              SRLR0   ASM # N               ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее SRLR0   BIN                     SRLR0   LST  O                SRLR1   ASM 4 P                SRLR1   BIN  Q                SRLR1   LST   ЂR S T U V W X Y  SRLR1   LST  ЂZ [ \ ] ^ _ ` a  SRLR1   LST  Ђb c d e f g h i  SRLR1   LST  Ђj k l m n o p q  SRLR1   LST  Ђr s t u v w x y  SRLR1   LST, 3z { | }          SRLT0   ASM M ;~  Ђ Ѓ          SRLT0   BIN @ ‚                SRLT0   LST  |ѓ „ … † ‡ € ‰ Љ  SRLT1   ASM f ;‹ Њ Ќ Ћ          SRLT1   BIN @ Џ                SRLT1   LST z {ђ ‘ ’ “ ” • – — ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее UARTCTC INC   Ђ ™ љ › њ ќ ћ џ  UARTCTC INCs '  Ў ў            SRLR1   COM   Ј               ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееerrupt Identification Register
    (w)     FCR - FIFO Control Register
$C3 (r/w)   LCR - Line Control Register
$C4 (r/w)   MCR - Modem Control Register
$C5 (r)     LSR - Line Status Register
$C6 (r)     MSR - Modem Status Register
$C7 (r/w)         Scratch Pad Register

-------------------------------------------------------------------------------
16c550 UART - Universal Asynchronous Receiver/Transmitter Detailed Description
-------------------------------------------------------------------------------

i       3    $0003
                1200     384                   230400       2    $0002
                1800     256    $0100          460800       1    $0001
                2400     192    $00c0

        note: baudrates higher 230k are unknown to work on the retroreplay
              hardware. (most pc's wont do more than 115k anyway ;=P)

if bit 7 of LCR is 0 :

$C0 - (r/w) RXD/TXD - Receive/Transmit Buffer

$C1 - (r/w) IER     - Interrupt Enable Register

         7 6 5 4 3 2 1 0
                      ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееf bit 7 of LCR is 1 :

$C0 - (r/w) DLL     - Baud Rate Divisor LSB
$C1 - (r/w) DLM     - Baud Rate Divisor MSB

        - Baud rate divisors can be calculated by taking the oscillating
          frequency (7,372,800) and dividing by the quantity of the desired
          baud rate times the UART clocking factor (16).  Use the following
          formula:
                      divisor = 7372800 / (BaudRate * 16);




        - it is not recommended to use zero as divisor.

            Baud Rate       Divisor     +---- 1 = enable data available interrupt (and 16550 Timeout)
                        +------ 1 = enable Transmit Holding Register empty (THRE) interrupt
                      +-------- 1 = enable Reviever lines status interrupt
                    +---------- 1 = enable modem-status-change interrupt
            +------------------ reserved (zero)

        - 16550 will interrupt if data exists in the FIFO and isn't read
          within the time it takes to receive four bytes or if no data is
          ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее-------------------------------------------------------------------------------
16c550 UART - Universal Asynchronous Receiver/Transmitter Overview
-------------------------------------------------------------------------------

Port-Address  Access        Description

$C0 (r/w) RXD/TXD Transmit/Receive Buffer
    (r/w)   DLL       if bit 7 of LCR is set: Baud Rate Divisor LSB
$C1 (r/w)   IER - Interrupt Enable Register
    (r/w)   DLM       if bit 7 of LCR is set: Baud Rate Divisor MSB
$C2 (r)     IIR - Int         Baud Rate      Divisor

                   1                             4800      96    $0060
                  15                             9600      48    $0030
                  75                            19200      24    $0018
                  50    9216                    38400      12    $000c
                 150    3072                    57600       8    $0008
                 300    1536                   115200       4    $0004
                 600     768                   153600received within the time it takes to receive four bytes.

$C2 - (r) IIR - Interrupt Identification Register

         7 6 5 4 3 2 1 0
                       +---- 1 = no int. pending, 0=int. pending
                   +-------- Interrupt ID bits (see below)
                 +---------- 16550  1 = timeout int. pending, 0 for 8250/16450
             +-------------- reserved (zero)
         +------------------ 16550  set to 1 if FIFO queues are enabled

        Interrupt ID Bits

         21       Meaning              00        1 byte
         01        4 bytes
         10        8 bytes
         11       14 bytes

        - Bit 0 must be set in order to write to any other FCR bits
        - Bit 1 when set to 1 the RCVR FIFO is cleared and this bit is reset.
          The receiver shift register is not cleared.
        - Bit 2 when set to 1 the XMIT FIFO is cleared and this bit is reset.
          The transmit shift register is not cleared.


$C3 - (r/w) LCR - Line Control Register

         7 6 5 4 3 2 1 0
    rol Register

         7 6 5 4 3 2 1 0
                       +---- 1 = activate DTR
                     +------ 1 = activate RTS
                   +-------- OUT1
                 +---------- OUT2
               +------------ 0 = normal, 1 = loop back test
         +------------------ reserved (zero)

        - If bit 4 is set, data from the Transmit Shift Register is received
          in the Receiver Shift Register.  The SOUT line is set to logic
          high, the SIN line and control lines are disconif enabled.
            - Bit 1 is set when a second byte is received before the byte
            in the Receiver Buffer Register is read by the CPU (the 16550 in
            FIFO mode sets this bit when the queue is full and the byte in the
            Receiver Shift Register hasn't been moved into the queue).  This
            bit is reset when the CPU reads the LSR
            - Bit 2 is set whenever a byte is received that doesn't match the
            requested parity.  Reset upon reading the LSR.  (Th       Priority           To reset
         00  modem-status-change      lowest      read MSR
         01  transmit-register-empty  low         read IIR / write THR
         10  data-available           high        read rec buffer reg
         11  line-status              highest     read LSR

        - interrupt pending flag uses reverse logic, 0 = pending, 1 = none
        - interrupt will occur if any of the line status bits are set
        - THRE bit is set when THRE register is emptied into the TSR


$                 +------ word length select bits (see below)
                   +-------- 0 = 1 stop bit, 1 = 1.5 or 2  (see note)
                 +---------- 0 = no parity, 1 = parity (PEN)
               +------------ 0 = odd parity, 1 = even (EPS)
             +-------------- 0 = parity disabled, 1 = enabled
           +---------------- 0 = turn break off, 1 = force spacing break state
         +------------------ 1 = baud rate divisor latch (DLAB); 0 = RBR, THR or IER

        Bits
         10     Wordnected.   CTS, DSR,
          RI and CD inputs are disconnected.  DTR, RTS, OUT1 and OUT2 are
          then connected internally.

$C5 - (r) LSR - Line Status Register

         7 6 5 4 3 2 1 0
                       +---- 1 = data ready
                     +------ 1 = overrun error (OE)
                   +-------- 1 = parity error (PE)
                 +---------- 1 = framing error (FE)
               +------------ 1 = break interrupt  (BI)
             +-------------- 1 = transmitter holding register ee 16550 maintains
            parity information with each byte and sets bit 2 only when the byte
            is at the top of the FIFO queue.)
            - Bit 3 is set when a character is received without proper stop
            bits.  Upon detecting a framing error the UART attempts to
            resynchronize.  Reset by reading the LSR.  (The 16550 maintains
            this information with each byte and sets bit 3 only when the byte
            is at the top of the FIFO queue.)
            - Bit 4 iC2 - (w) FCR - FIFO Control Register

         7 6 5 4 3 2 1 0
                       +---- 1 = enable FIFO and clear XMIT and RCVR FIFO queues
                     +------ 1 = clear RCVR FIFO
                   +-------- 1 = clear XMIT FIFO
                 +---------- 1 = change RXRDY & TXRDY pins from mode 0 to mode 1 (DMA Mode select)
             +-------------- reserved (zero)
         +------------------ trigger level for RCVR FIFO interrupt

        Bits      RCVR FIFO
         76     Trigger Level
 length bits
         00 = 5 bits per character
         01 = 6 bits per character
         10 = 7 bits per character
         11 = 8 bits per character

        - stop bits = 1.5 for 5 bit words or 2 for 6, 7 or 8 bit words
        - bit 7 changes the mode of registers $C0 and $C1  If set these
          registers become the LSB and MSB of the baud rate divisor.
          Otherwise $C0 is the Transmit/Receive Buffer Register and $C1 is
          the Interrupt Enable Register.


$C4 - (r/w) MCR - Modem Contmpty (THRE)
           +---------------- 1 = transmitter shift register empty (TSRE)
         +------------------ 1 = 16550 PE/FE/Break in FIFO queue, 0 for 8250 & 16450

        - Bit 0 is set when a byte is placed in the Receiver Buffer Register
          and cleared when the byte is read by the CPU (or when the CPU
          clears the FIFO for the 16550).  Results in Receive Data Available
          Interrupts if enabled.
        - Bits 1-4 indicate errors and result in Line Status Interrupts
          s set when a break condition is sensed (when space is
            detected for longer than 1 fullword).  A zero byte is placed in
            the Receiver Buffer Register (or 16550 FIFO).  Reset by reading
            the LSR.  (The 16550 maintains this information with each byte and
            sets bit 4 only when the byte is at the top of the FIFO queue.)
        - Bit 5 is set when the Transmit Holding Register shifts a byte
          into the Transmit Shift Register (or XMIT FIFO queue is empty for
   or )
         +------------------ 1 = DCD  (data carrier detect)

        - Bits 0-3 are reset when the CPU reads the MSR
        - Bit 4 is the Modem Control Register RTS during loopback test
        - Bit 5 is the Modem Control Register DTR during loopback test
        - Bit 6 is the Modem Control Register OUT1 during loopback test
        - Bit 7 is the Modem Control Register OUT2 during loopback test

$C7 - (r/w) Scratch Pad Register

    This 8-bit Read/Write Register does not control the UART in anywaR FIFO and receiver interrupts are enabled, RCVR FIFO timeout
interrupts will occur as follows:

A. A FIFO timeout interrupt will occur, if the following conditions exist:

    - at least one character is in the FIFO
    - the most recent serial character received was longer than 4 continuous
      character times ago (if 2 stop bits are programmed the second one is in-
      cluded in this time delay).
    - the most recent CPU read of the FIFO was longer than 4 continuous
      character times ago.

   Thions will be delayed 1 character time
   minus the last stop bit time whenever the following occurs: THRE=1 and there
   have not been at least two bytes at the same time in the transmit FIFO,
   since the last THRE=1. The first transmitter interrupt after changing FCR0
   will be immediate, if it is enabled.

Character timeout and RCVR FIFO trigger level interrupts have the same priority
as the current received data available interrupt; XMIT FIFO empty has the same
priority as the current transmitter holdi       16550) and is cleared when a byte is written to the THR (or the
          XMIT FIFO).   Results in Transmit Holding Register Empty interrupts
          if enabled.
        - Bit 6 is set when both the Transmitter Holding Register and the
          Transmitter Shift Register are empty. On the 16550, when the XMIT
          FIFO and Transmitter Shift Register are empty.
        - Bit 7 is 16550 specific and indicates there is a byte in the FIFO
          queue that was received with a Parity, Framing oy. It is
    intended as a scratchpad register to be used by the programmer to hold data
    temporarily.

-------------------------------------------------------------------------------

FIFO Interrupt Mode Operation

When the RCVR FIFO and receiver interrupts are enabled (FCR0=1, IER0=1) RCVR
interrupts will occur as follows:

A. The receive data available interrupt will be issued to the CPU when the FIFO
   has reached its programmed trigger level; it will be cleared as soon as the
   FIFO drops below ite maximum time between a received character and a timeout interrupt will
   be 160 ms at 300 baud with a 12-bit receive character (i.e., 1 Start,
   8 Data, 1 Parity and 2 Stop Bits).

B. Character times are calculated by using the RCLK input for a clock signal
   (this makes the delay proportional to the baudrate).

C. When a timeout interrupt has occurred it is cleared and the timer reset when
   the CPU reads one character from the RCVR FIFO.

D. When a timeout interrupt has not occurred the timeout timeng register empty interrupt.

-------------------------------------------------------------------------------

FIFO Polled Mode Operation

With FCR0=1 resetting IER0, IER1, IER2, IER3 or all to zero puts the UART in
the FIFO Polled Mode of operation. Since the RCVR and XMITTER are controlled
separately either one or both can be in the polled mode of operation. In this
mode the user's program will check RCVR and XMITTER status via the LSR.

As stated previously:

- LSR0 will be set as long as there is one byr Break error.


$C6 - (r) MSR - Modem Status Register

         7 6 5 4 3 2 1 0
                       +---- 1 = DCTS (Delta CTS) (CTS changed)
                     +------ 1 = DDSR (Delta DSR) (DSR changed)
                   +-------- 1 = TERI (ring indicator changed)
                 +---------- 1 = DDCD (Delta Data Carrier Detect) (DCD changed)
               +------------ 1 = CTS  (clear to send)
             +-------------- 1 = DSR  (data set ready)
           +---------------- 1 = RI   (ring indicats programmed trigger level.
B. The IIR receive data available indication also occurs when the FIFO trigger
   level is reached, and like the interrupt it is cleared when the FIFO drops
   below the trigger level.
C. The receiver line status interrupt (IIR=06), as before, has higher priority
   than the received data available (IIR=04) interrupt.
D. The data ready bit (LSR0) is set as soon as a character is transferred from
   the shift register to the RCVR FIFO. It is reset when the FIFO is empty.

When RCVr is reset after a
   new character is received or after the CPU reads the RCVR FIFO.

When the XMIT FIFO and transmitter interrupts are enabled (FCR0=1, IER1=1),
XMIT interrupts will occur as follows:

A. The transmitter holding register interrupt (02) occurs when the XMIT FIFO is
   empty; it is cleared as soon as the transmitter holding register is written
   to (1 to 16 characters may be written to the XMIT FIFO while servicing this
   interrupt) or the IIR is read.
B. The transmitter FIFO empty indicatte in the RCVR FIFO.
- LSR1 to LSR4 will specify which error(s) has occurred.
- Character error status is handled the same way as when in the interrupt mode,
  the IIR is not affected since IER2=0.
- LSR5 will indicate when the XMIT FIFO is empty.
- LSR6 will indicate that both the XMIT FIFO and shift register are empty.
- LSR7 will indicate whether there are any errors in the RCVR FIFO.
- There is no trigger level reached or timeout condition indicated in the FIFO
  Polled Mode, however, the RCVR and XMIT pc",
    completed and updated from various other sources, register adresses and
    other related stuff adapted for the retro-replay hardware

retroreplay info:
    taken from the original inside_replay.txt written by Jens Schoenfeld

silversurfer info:
    taken from the original inside_surfer.txt written by Jens Schoenfeld, also
    adapted to fit.

-------------------------------------------------------------------------------                                                                              erent assemblers
; 20150714 - Modified to implement serial XON/XOFF and RTS/CTS
; ---------------------------------------------------------------------

; ---------------------------------------------------------------------
; SYSBIOS
;
; This is the BIOS non-resident portion of the new (banked)
; BIOS/Monitor for the NE Z80 (aka DarkStar)
;
; ---------------------------------------------------------------------
;
; Full BIOS memory scheme:
;
;	+-----------------+
;	+    SysCommon    +   <-- Resident portio------------------------
;
; Define which assembler we are using
;

; PASMO	EQU	1
MZMAC	EQU	1
; ZMAC	EQU	1			; ZMAC Z80 assembler, not Linux/Unix version

; ... only one at a time can be active (1) ...

;
; Monitor version numbers (major.minor)
;
MONMAJ		EQU	'3'
MONMIN		EQU	'4'

;
; Buffers addresses labels
;

; -- Global --
IOBYTE		EQU	0003H		; byte: Intel IOBYTE (CP/M 2.2 only)
CDISK		EQU	0004H		; byte: Last logged drive
BTPASIZ		EQU	0006H		; word: size of tpa + 1
;
; -- Private --
HMEMPAG		EQU	000BH		; bFIFOs are still fully capable of
  holding characters.

-------------------------------------------------------------------------------

general programming considerations:

- 16550's is pin and software compatible with the 16450 but has an internal
  16-byte FIFO queue that may be enabled/disabled by software
- PCs(XT) are capable of 38.4Kbaud, while AT's are capable of 115.2Kbaud ... a
  stock c64 using the SilverSurver should pull ~80Kbaud, the standard c64
  kernal implementation will do 2400baud.
- rec;
;=======================================================================
;
; Modular Z80 DarkStar (NE Z80) SysBios
;
;=======================================================================
;
; Original code:
; Z80 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
;
; Disassembled and reconstructed by
; Piergiorgio Betti <pbetti@lpconsul.net> on 2005 01 26
;
; Latest non modular BIOS is DARKSTAR-MONITOR-0.9.0.asm
; dated 20140531
; - Following addition of MultiF-Board doing complete rewrite of the
;   monin. Common to all images
;	+   FC00 - FFFF   +
;	+-----------------+
;	+-----------------+   +-----------------+   +-----------------+
;	+     SysBios     +   +   BootMonitor   +   +     [Other]     +
;	+   F000 - FBFF   +   +   F000 - FBFF   +   +   F000 - FBFF   +
;	+-----------------+   +-----------------+   +-----------------+
;
;	         ^                     ^                     ^
;	         |                     |                     |
;	         ---------------------------------------------
;	     yte: highest ram page
BBCBANK		EQU	000CH		; byte: current bank
BBCSTCK		EQU	000DH		; word: current stack
		;
PRVTOP		EQU	004FH		; top of private area storage
COLBUF		EQU	PRVTOP		; byte:
DSELBF		EQU	COLBUF-1	; byte: floppy drive select status
					; - bits: 0 = drive 0
					; - bits: 1 = drive 1
					; - bits: 2 = drive 2
					; - bits: 3 = drive 3
					; - bits: 4 = unused
					; - bits: 5 = head select
					; - bits: 6 = motor on (disabled by jumper)
					; - bits: 7 = unused
KBDBYTE		EQU	DSELBF-1	; byte: eiver checks only the first stop bit of each character regardless
  of the number of stop bits specified
- data loss can occur without overrun or framing errors if the interrupts are
  serviced too slowly
- reserved bits are usually set to zero.  Code should NOT rely on this being
  the case since future enhancement may use these bits

-------------------------------------------------------------------------------
sources:

UART info:
    register info taken from my favourite ms-dos/pc quickreference "help-tor/BIOS has been started.
;   Major goals:
;   o Modularization: Now monitor can grow up to 256kb instead of 4kb
;     :-)
;   o Specialized images fitted in memory page (4kb) or multiples
;   o Full support for new hardware
;   o I/O rewrite for MODE 2 interrupts
;   Minor goals:
;   o Full code clean-up & reoarganization
; ---------------------------------------------------------------------
; Revisions:
; 20140905 - Modified hexadecimal constants to 0xxH format to be widely
;            accepted by diff                 Variable section
;
; The above are always assembled at ORG F000 and linked and allocated
; in the EEPROM in this way:
;
;	+-----------------+
;	+    SysCommon    +
;	+   FC00 - FFFF   +
;	+     SysBios     +     <-- EEPROM page 1 ($C1000)
;	+   F000 - FBFF   +
;	+-----------------+
;	+-----------------+
;	+    SysCommon    +
;	+   FC00 - FFFF   +
;	+   BootMonitor   +     <-- EEPROM page 0 ($C0000)
;	+   F000 - FBFF   +
;	+-----------------+
;
; ---------------------------------------------store keyboard input
MIOBYTE		EQU	KBDBYTE-1	; byte:
					; - bits: 0: 0 = floppy write		1 = floppy read
					;         1: 0 = no ctrl on keypress	1 = ctrl on keypress
					;         2: 0 = scroll			1 = no scroll
					;         3: 0 = accept lowercase	1 = convert to uppercase
					;         4: 0 = destr. bkspace		1 = non destr. bkspace
					;         5: 0 = console out		1 = serial out
					;         6: 0 = disp. all chars	1 = obscure non punct.
					;         7: 0 = ctrl chr set 1		1 = ctrl chr set 2
TMPBYTEarea of RST38 (RST7)
RST7SP2		EQU	0039H
RST7SP1		EQU	0038H
RSRVBUF		EQU	RST7SP1-9	; free 9 byte buffer
APPBUF		EQU	RSRVBUF-2	; word: generic buffer
COPSYS		EQU	APPBUF-1	; Op system type for partition selection
UART0BR		EQU	COPSYS-1	; UART 0 baudrate
UART1BR		EQU	UART0BR-1	; UART 1 baudrate
CTC0TC		EQU	UART1BR-1	; CTC channel 0 time constant
CTC1TC		EQU	CTC0TC-1	; CTC channel 1 time constant
TIMRCON		EQU	CTC1TC-1	; timer buf
CNFBYTE		EQU	TIMRCON-1	; config byte
					; - bits: 0: 0 = UART1 intr disabled	1 = R

; Conventionally all bios/monitor images start at $F000.
; Except for special cases all code is copied to ram @ $F000.
; In this case eeprom page 0 is directly mapped into logical space
; by hardware so we can initialize the system at cold boot.
;
; We assume to initialize MMU as follow:
;
; +--------+
; |  F000  |	-> $C0000  eeprom page 0
; +--------+
; +--------+
; |  EFFF  |
; +--------+
;     ...       -> $00000 to $0EFFF ram
; +--------+
; |  0000  |
; +--------+
;


; include	modules/hwequs.inc.asm
D (input): PIO1 port B control register
KEYBSTRBBIT	EQU	7		; Strobe bit
	; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
CRTRAM2DAT	EQU	CRTBASE+8	; RAM2 access: PIO2 port A data register
CRTRAM2CNT	EQU	CRTBASE+10	; RAM2 access: PIO2 port A control register
	; Service/User port
CRTSERVDAT	EQU	CRTBASE+9	; Service (i/o): PIO2 port B data register
CRTSERVCNT	EQU	CRTBASE+11	; Service (i/o): PIO2 port B control register
PRNTBUSYBIT	EQU	0		; Printer BUSY bit		(in)	1
CRTWIDTHBIT	EQU	1		; Set 40/80 chars per li		EQU	MIOBYTE-1	; byte: transients flags
					; - bits: 0: 0 = high in cursor addressing
					;         1: 0 = ESC catched by ANSI driver
					;         2: 0 = CSI catched by ANSI driver
					;         3: 0 = Two byte code ESC seq. from serial
					;         4: 0 = Plain serial i/o (disable ANSI driver)
					;         5: 0 = store interrupt status (on/off)
					;         6: 0 = floppy home on err	1 = no home on err
					;         7: 0 = unlock LBA free addressing (unpartitioned)
CURSSHP		EQU	TMPBYTE-1	; curST8 redir UART1
					;         1: 1 = XON/XOFF enabled on UART0
					;         2: 1 = RTS/CTS enabled on UART0
					;         3: 0 = unused/reserved
					;         4: 0 = unused/reserved
					;         5: 0 = unused/reserved
					;         6: 0 = unused/reserved
					;         7: 0 = unused/reserved
FIFOSTO		EQU	000FH		; fifo queues storage start
FIFSIZE		EQU	8		; fifo queue lenght
FIFBLOK		EQU	11		; fifo queue size
FIFOU0		EQU	FIFOSTO		; uart 0 queue (alternate console)
FIFOKB		EQU	FIFOU0+FIFBLOK	; keyboar; Hardware equates
; ---------------------------------------------------------------------

; ---------------------------------------------------------------------
; LX529 VIDEO BOARD:
; ---------------------------------------------------------------------
CRTBASE		EQU	80H
	; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
CRTRAM0DAT	EQU	CRTBASE		; RAM0 access: PIO0 port A data register
CRTRAM0CNT	EQU	CRTBASE+2	; RAM0 access: PIO0 port A control register
	; Printer port
CRTPRNTDAT	EQUne	(out)	0
PIO2BIT2	EQU	2		; user 1 (input)		(in)	1
PIO2BIT3	EQU	3		; user 2 (input)		(in)	1
PIO2BIT4	EQU	4		; user 3 (input)		(in)	1
CLKSCLK		EQU	5		; DS1320 clock line		(out)	0
CLKIO		EQU	6		; DS1320 I/O line		(i/o)	1
CLKRST		EQU	7		; DS1320 RST line		(out)	0
	; normal set for PIO2 (msb) 01011101 (lsb) that is hex $5D
					; Other bits available to user
	; RAM3 control chars/graphics attributes
CRTRAM3PORT	EQU	CRTBASE+14	; RAM3 port
CRTBLINKBIT	EQU	0		; Blink
CRTREVRSBIT	EQU	1		; Reverse
CRTUNDERBIT	EQU	2sor shape
CURPBUF		EQU	CURSSHP-2	; word: cursor position
FTRKBUF		EQU	CURPBUF-2	; word: track # for i/o (0 - 65535)
FDRVBUF		EQU	FTRKBUF-1	; byte: drive number for i/0 (0 - 15)
FSECBUF		EQU	FDRVBUF-2	; word: sector # for i/o (1 .. 65535)
FRDPBUF		EQU	FSECBUF-2	; word: dma address for i/o
FSEKBUF		EQU	FRDPBUF-2	; word: current track number for drive A/B
RAM3BUF		EQU	FSEKBUF-1	; byte:
RAM2BUF		EQU	RAM3BUF-1	; byte:
RAM1BUF		EQU	RAM2BUF-1	; byte:
RAM0BUF		EQU	RAM1BUF-1	; byte:
RST7SP3		EQU	003AH		; keep clear d queue
FIFOEND		EQU	FIFOKB+FIFBLOK	; fifo blocks end
;
BLDOFFS		EQU	3000H		; place for disk bootloader

;
; Some commodity equs
;
CR		EQU	0DH		; ascii CR & LF
LF		EQU	0AH
FF		EQU	0CH		; FORM FEED (clear screen)
ESC		EQU	1BH		; ESCape
XONC		EQU	11H		; Xon
XOFC		EQU	13H		; Xoff
TRUE		EQU	-1
FALSE		EQU	0
TPA		EQU	0100H		; TPA base address (for CP/M)

;
; Modules equs
;
	; delay
MSCNT		EQU	246
	; mmu
MMUTSTPAGE	EQU	0DH		; logical page used for sizing
MMUTSTADDR	EQU	MMUTSTPAGE<<12	; logical page used for sizing	CRTBASE+1	; PRINTER (output): PIO0 port B data register
CRTPRNTCNT	EQU	CRTBASE+3	; PRINTER (output): PIO0 port B control register
					; STROBE is generated by hardware
	; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
CRTRAM1DAT	EQU	CRTBASE+4	; RAM1 access: PIO1 port A data register
CRTRAM1CNT	EQU	CRTBASE+6	; RAM1 access: PIO1 port A control register
	; Keyboard port (negated). Bit 7 is for strobe
CRTKEYBDAT	EQU	CRTBASE+5	; KEYBOARD (input): PIO1 port B data register
CRTKEYBCNT	EQU	CRTBASE+7	; KEYBOAR		; Underline
CRTHILITBIT	EQU	3		; Highlight
CRTMODEBIT	EQU	4		; ASCII/GRAPHIC mode
	; Beeper port
CRTBEEPPORT	EQU	CRTBASE+15	; Beeper port
	; 6545 CRT controller ports
CRT6545ADST	EQU	CRTBASE+12	; Address & Status register
CRT6545DATA	EQU	CRTBASE+13	; Data register
	; Cursor modes
BLISLOWBLOK	EQU	40H		; Blink, slow, block
BLISLOWLINE	EQU	4AH		; Blink, slow, line
BLIFASTBLOK	EQU	60H		; Blink, fast, block
BLIFASTLINE	EQU	6AH		; Blink, fast, line
CURSOROFF	EQU	20H		; Off
FIXBLOCK	EQU	00H		; Fixed, block
CURSOTB		EQU	1		; Acknowledge/Stop bit
;
PPDINI		EQU	00H		; 00000000 Dnl Init byte
PPDRDY		EQU	04H		; 00000100 Dnl Ready
PPDSTP		EQU	06H		; 00000110 Dnl Stop
PPDOKG		EQU	02H		; 00000010 Dnl Ok Go
PPUINI		EQU	01H		; 00000001 Upl Init byte
PPURDY		EQU	05H		; 00000101 Upl Ready
PPUACK		EQU	07H		; 00000111 Upl Acknowledge
PPUOKG		EQU	03H		; 00000011 Upl Ok Go
;
; virtual disks (PC-linked over parallel port)
VDRDSEC		EQU	0		; read sector command
VDWRSEC		EQU	1		; write sector command
VDBUFSZ		EQU	10		; 10 bytes block 8255 configuration port

READCFG8255	EQU	10010010b	; Set 8255 IDEportC to output, IDEportA/B input
WRITECFG8255	EQU	10000000b	; Set all three 8255 ports to output mode
;IDE control lines for use with IDEportC.
IDEA0LINE	EQU	01H		; direct from 8255 to IDE interface
IDEA1LINE	EQU	02H		; direct from 8255 to IDE interface
IDEA2LINE	EQU	04H		; direct from 8255 to IDE interface
IDECS0LINE	EQU	08H		; inverter between 8255 and IDE interface
IDECS1LINE	EQU	10H		; inverter between 8255 and IDE interface
IDEWRLINE	EQSelect UART 0
UART1		EQU	UART1BASE	; Select UART 1
R0RXTX		EQU	0		; (r/w) RXD/TXD Transmit/Receive Buffer
R0BRDL		EQU	0		; (r/w) DLL  if bit 7 of LCR is set: Baud Rate Divisor LSB
R1IER		EQU	1		; (r/w) IER - Interrupt Enable Register
R1BRDM		EQU	1		; (r/w) DLM if bit 7 of LCR is set: Baud Rate Divisor MSB
R2IIR		EQU	2		; (r)   IIR - Interrupt Identification Register
R2FCR		EQU	2		; (w)   FCR - FIFO Control Register
R3LCR		EQU	3		; (r/w) LCR - Line Control Register
R4MCR		EQU	4		; (r/w) MCR - Modem Control RRON	EQU	0AH		; On

; ---------------------------------------------------------------------
; LX390 FDC CONTROLLER:
; ---------------------------------------------------------------------
FDCBASE		EQU	0D0H
FDCCMDSTATR	EQU	FDCBASE		; Command and status register
FDCTRAKREG	EQU	FDCBASE+1	; Track register
FDCSECTREG	EQU	FDCBASE+2	; Sector register
FDCDATAREG	EQU	FDCBASE+7	; Data register *** Verificare che sia $d7
FDCDRVRCNT	EQU	FDCBASE+6	; Driver select/control register
;
FDCRESTC	EQU	00000111b	; 1771 restore (
; ---------------------------------------------------------------------
; MULTF-BOARD: MMU, IDE, SERIAL, CTC
; ---------------------------------------------------------------------
; -- I/O --
MMUPORT		EQU	20H
MENAPRT		EQU	21H
; -- Map --
EEPAGE0		EQU	0C0H		; page 0 of eeprom
EEPSTA		EQU	0F000H		; eeprom location after MMU reset
MMTPAPAG	EQU	(EEPSTA>>8)-1	; TPA top page (256 bytes pages)
IMTPAG		EQU	0FFH		; eeprom page with image table
IMTSIZ		EQU	1024		; size
RAMTBL		EQU	0E000H		; ram table location
TBLBLU	20H		; inverter between 8255 and IDE interface
IDERDLINE	EQU	40H		; inverter between 8255 and IDE interface
IDERSTLINE	EQU	80H		; inverter between 8255 and IDE interface
;Symbolic constants for the IDE Drive registers
REGDATA		EQU	IDECS0LINE
REGERR		EQU	IDECS0LINE + IDEA0LINE
REGSECCNT	EQU	IDECS0LINE + IDEA1LINE
REGSECTOR	EQU	IDECS0LINE + IDEA1LINE + IDEA0LINE
REGCYLLSB	EQU	IDECS0LINE + IDEA2LINE
REGCYLMSB	EQU	IDECS0LINE + IDEA2LINE + IDEA0LINE
REGSHD		EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE		;(0EH)
REGCOMegister
R5LSR		EQU	5		; (r)   LSR - Line Status Register
R6MSR		EQU	6		; (r)   MSR - Modem Status Register
R7SPR		EQU	7		; (r/w) SPR - Scratch Pad Register
	; speeds:
UART1200	EQU	96		; = 1,843,200 / ( 16 x 1200 )
UART2400	EQU	48		; = 1,843,200 / ( 16 x 2400 )
UART4800	EQU	24		; = 1,843,200 / ( 16 x 4800 )
UART9600	EQU	12		; = 1,843,200 / ( 16 x 9600 )
UART19K2	EQU	06		; = 1,843,200 / ( 16 x 19,200 )
UART38K4	EQU	03		; = 1,843,200 / ( 16 x 38,400 )
UART57K6	EQU	02		; = 1,843,200 / ( 16 x 57,600 )
UART115K2	seek to trak 0) cmd
FDCSEEKC	EQU	00010111b	; seek cmd
FDCREADC	EQU	10001000b	; read cmd
FDCWRITC	EQU	10101000b	; write cmd
FDCRESET	EQU	11010000b	; fdc reset immediate cmd
;
; ---------------------------------------------------------------------
; LX389: PARALLEL INTERFACE
; ---------------------------------------------------------------------
; alternate printer port
ALTPRNPRT	EQU	03H
;
; parallel port PC link
PPDATAP		EQU	03H		; Data port
PPCNTRP		EQU	02H		; Control port
PPSTROB		EQU	0		; Strobe bit
PPAKSK		EQU	48		; block size
MAXBLK		EQU	20		; max images
RTBSIZ		EQU	TBLBLK * MAXBLK	; real table size
					; A table block is:
TNAMELEN	EQU	8		;	name		: 8 bytes
TPAGELEN	EQU	2		;	page offset	: 2 bytes
TIADDRLEN	EQU	4		;	image address	: 4 bytes
TSIZELEN	EQU	4		;	image size	: 4 bytes
TDESCLEN	EQU	20		;	description	: 20 bytes
; -- IDE --
IDEPORTA	EQU	0E0H		; lower 8 bits of IDE interface
IDEPORTB	EQU	0E1H		; upper 8 bits of IDE interface
IDEPORTC	EQU	0E2H		; control lines for IDE interface
IDEPORTCTRL	EQU	0E3H		;MAND	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE	;(0FH)
REGSTATUS	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
REGCONTROL	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
REGASTATUS	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
;IDE Command Constants.
CMDRECAL	EQU	010H
CMDREAD		EQU	020H
CMDWRITE	EQU	030H
CMDINIT		EQU	091H
CMDID		EQU	0ECH
CMDSPINDOWN	EQU	0E0H
CMDSPINUP	EQU	0E1H
; -- 16C550 UARTS --
UART0BASE	EQU	0C0H		; Port base address for 0
UART1BASE	EQU	0C8H		; Port base address for 1
UART0		EQU	UART0BASE	; EQU	01		; = 1,843,200 / ( 16 x 115,200 )

U0DEFSPEED	EQU	UART19K2	; UART 0 default speed
U1DEFSPEED	EQU	UART9600	; UART 1 default speed
; -- Z80CTC --
CTCBASE		EQU	0E8H
CTCCHAN0	EQU	CTCBASE+0	; Channel 1 - Free
CTCCHAN1	EQU	CTCBASE+1	; Channel 2 - System Timer
CTCCHAN2	EQU	CTCBASE+2	; Channel 3 - UART 1 Interrupt
CTCCHAN3	EQU	CTCBASE+3	; Channel 4 - UART 0 Interrupt
CTC0TCHI	EQU	32		; hi speed chan. 0 tc: 4Mhz / 256 / 32 = 488.28 Hz
CTC1TC100HZ	EQU	5		; lo speed chan. 1 tc: 488.28 Hz / 5 = ~ 97.6 Hz
CTC1TC5h at the top of logical space page Fh
; you need to have Fh * on top address lines * because this address
; is the index to MMU page.
;
; So:
;
; 	LD	A,00h		<--- phis. page number	00xxxh (4k page)
; 	LD	B,F0h		<--- log. page number 	 Fxxxh (cpu page)
; 	LD	C,20h		<--- MMU I/O address
; 	OUT	(C),A
; 	RET
;
; The OUT instruction place:
; A on data lines D0-D7
; Fh (from B register) on A12-A15
; on port 20h (C register)
;
;
; Memory is organized as follow:
;
;	Slot 1	-> RAM	  -> 512k from 00000h to 7ffffh (man                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                LD	A,(HL)
	OUT	(CRT6545DATA),A
	INC	HL
	INC	B
	LD	A,B
	CP	$14
	JR	NZ,ICTLP0
	LD	HL,$0000
	LD	(CURPBUF),HL
	CALL	SDPYSTA
; 	JP	CRSLOC

;	fall through...

;;
;; CRSLOC - init CRT cursor at CURPBUF
;
CRSLOC:
	LD	HL,(CURPBUF)
	CALL	SCRSPOS
	XOR	A
	LD	(COLBUF),A		; save cursor position
	RET


;;
;; GET DISPLAY CURSOR POSITION and return in HL
;
GCRSPOS:
	LD	A,$0E
	OUT	(CRT6545ADST),A
	IN	A,(CRT6545DATA)
	LD	H,A
	LD	A,$0F
	OUT	(CRT6545ADST),A
	IN	A,(CRT6545DATA)
	LD	L,A
	INC	HL
	JR	CRTPRGEND

;;
;; SET DISPLAY ST0HZ	EQU	10		; lo speed chan. 1 tc: 488.28 Hz / 10 = ~ 48.8 Hz
CTC1TC25HZ	EQU	19		; lo speed chan. 1 tc: 488.28 Hz / 19 = ~ 25 Hz
CTC1TC10HZ	EQU	48		; lo speed chan. 1 tc: 488.28 Hz / 48 = ~ 10 Hz
CTC1TC2HZ	EQU	244		; lo speed chan. 1 tc: 488.28 Hz / 244 = ~ 2 Hz
SYSHERTZ	EQU	CTC1TC25HZ	; System timer hertz
; -- EEPROM --
EEP29EE		EQU	01H		; type 29EE020
EEP29XE		EQU	02H		; type 29LE020 or 29VE020
EEP29C		EQU	04H		; type 29C020
EEPUNSUPP	EQU	08H		; unsupported
EEPROGLOCK	EQU	10H		; programming locked
	;
EERIdatory)
;	Slot 2	-> RAM	  -> 128k from 80000h to 9ffffh (option 1)
;	Slot 2	-> RAM    -> 256k from 80000h to bffffh (option 2)
;	Slot 3	-> EEPROM -> 256k from c0000h to fffffh (mandatory)
;


;-------------------------------------
; Production / Testing

BBDEBUG	EQU	TRUE


;-------------------------------------
; Segments, pages locations

IF	BBDEBUG

BBIMGP	EQU	04H		; Image location (DEBUG)
BBAPPP	EQU	0EH
BBPAG	EQU	0FH		; Base page location

ELSE

BBIMGP	EQU	EEPAGE0		; Image location
BBAPPP	EQU	0EH
BBPAG	E;
;=======================================================================
;
; Modular Z80 DarkStar (NE Z80) Monitor
;
;=======================================================================
;
; CRTC
; SY6545A-1 and PIOs for video ram access on LX529
; ---------------------------------------------------------------------

;; 6545 initialization string
CRTTAB1:
	DB	$6F,$50,$57,$28,$1A,0,$19,$19,$48,$0B
	DB	0,$0B,0,0,0,0,0,0,0,0

;;
;; CRTCINI - init buffers,6545,test vram,clear,leave cursor at home
;;
CRTCIART ADDRESS
;
SDPYSTA:
	LD	A,$0C
	OUT	(CRT6545ADST),A
	LD	A,H
	OUT	(CRT6545DATA),A
	LD	A,$0D
	OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
	JR	CRTPRGEND


;;
;; DISMVC display char and move cursor
;
DISMVC:
	CALL	DISPCH
; 	JP	SCRSPOS

	; fall through...
;;
;; SET DISPLAY CURSOR ADDRESS EXTENDED
;;
SCRSPOS:
	LD	A,$0E
	OUT	(CRT6545ADST),A
	LD	A,H
	OUT	(CRT6545DATA),A
	LD	A,$0F
	OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
SCRSPOS1:
	LD	A,$12
	OUT	(CRT6545ADST),A
	LD	A,H
	OUT	(CRT6545DATA),A
	LD	A,$13
NEPROM	EQU	80H		; tried to program eeprom running inside it

;
; MMU organization
;
; MMU manage 16 4kb pages in Z80 address space (logical)
; It can assign any of 256 4k pages (physical) from its
; 1Mb address space.
;
; To load phisycal page XXh to logical page (in CPU address space) Y,
; you should consider that MMU is at a fixed address 20h and that
; logical 4K page Y is derived in the MMU by the usage of A12,A13,A14
; and A15 address lines during an I/O instruction.
;
; So to address phys. ram page 00QU	0FH		; Base page location

ENDIF

TRNPAG	EQU	0DH		; Page used for transient MMU ops
BBBASE	EQU	BBPAG << 12	; non resident base address
BBCOMN	EQU	BBBASE + 0C00H	; resident portion address

SYSBASE EQU	BBBASE		; use this to have 60K TPA
; SYSBASE EQU	BBCOMN		; use this to have 63K TPA

;-------------------------------------
                                                                                                                                                                                        NI:
	CALL	INICRT
	CALL	DBLANK
	CALL	GIOINI			; init remaing hardware on the board
	LD	A,$FF
	LD	(RAM3BUF),A
	LD	HL,$0000
	LD	(CURPBUF),HL
	JR	CRSLOC

;;
;; INICRT
;
INICRT:
					; initialize PIOs
	LD	A,$8F			; 10-00-1111 mode ctrl word
					; Mode 2 (I/O port A)
	OUT	(CRTRAM0CNT),A
	OUT	(CRTRAM1CNT),A
	OUT	(CRTRAM2CNT),A
	CALL	INI6545			; init 6545
	JP	CRTPRGEND		; go on...


;;
;; INI6545 - initialize sy6545
;;
INI6545:
	LD	HL,CRTTAB1	; now read from eprom
	LD	B,$00
	LD	A,B
ICTLP0:	OUT    (CRT6545ADST),A
		OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
	JR	CRTPRGEND

;;
;; DBLANK
;; fill video ram (2k) with 0's
;
DBLANK:
	LD	HL,$0000
	LD	(RAM0BUF),HL
	XOR	A
	LD	(RAM2BUF),A
;;
;; CRTFILL - Fill video ram with ram buffer chrs
;
CRTFILL:
	LD	A,$EF
	LD	(RAM3BUF),A
	LD	HL,$0000
	LD	(CURPBUF),HL
	CALL	RSTDPY
CFIL1:	PUSH	HL
	CALL	DISPGR
	POP	HL
	INC	HL
	LD	A,H
	CP	$08
	JR	NZ,CFIL1
	JR	RSTDPY

;;
;; RSTDPY - zeroes SY6545 higher register (R12 to R19)
;;
RSTDPY:
	LD	B,$08
RDPY1:	LD	A,B
	ADD	A,$0B
	OUT	(CRT6545ADST)ing ?
	EX	DE,HL
	JR	NZ,CONOU2		; yes: do alternate
	CP	$20			; no: is less then 0x20 (space) ?
	JR	NC,COJP1		; no: go further
	ADD	A,A			; yes: is a special char
	LD	H,0
	LD	L,A
	LD	BC,IOCVEC
	ADD	HL,BC
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)			; jump to IOCVEC handler
COJP1:	EX	DE,HL
	BIT	6,(HL)			; auto ctrl chars ??
	JR	Z,COJP2			; no
	CP	$40			; yes: convert
	JR	C,COJP2
	CP	$60
	JR	NC,COJP2
	SUB	$40
COJP2:	CALL	DISPCH			; display char
	; move cursor right
MOVRGT:
	CALL	GCRSPOS			; update cursor p	ADD	HL,DE
	JP	SCRSPOS			; update position
BCEXIT:
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;;
;; LFEED: down one line, scroll, home, clreol
;
LFEED:
	XOR	A
	LD	(COLBUF),A
LFEED1:	CALL	SCRTST
	RET	C
	LD	HL,MIOBYTE
	BIT	2,(HL)
	LD	DE,$F830
	CALL	GCRSPOS
	DEC	HL
	JR	Z,MDJMP0
	ADD	HL,DE
	JP	SCRSPOS
MDJMP0:	PUSH	HL
	CALL	CLRLIN
	LD	HL,(CURPBUF)
	LD	DE,$0050
	ADD	HL,DE
	LD	DE,$0820
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,MDJMP1
	RES	3,H
MDJMP1:	LD	(CURPBUF),HL
	CALL	SDPYSTA
	POP	HL
	JR	C,MEJP
	RES	3,H
MEJP:	JP	SCRSPOS

;;UT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
	POP	HL
	JP	CRTPRGEND

;;
;; IOCNULL (a void routine) from here a list of routines to handle
;; console char output
;
IOCNULL:
	RET				; null entry. start of control routines vector
					; for primary (non-escaped) mode
;
UCASEMOD:
	EX	DE,HL
	SET	3,(HL)
	RET
LCASEMOD:
	EX	DE,HL
	RES	3,(HL)
	RET
;;
;; SNDBEEP - sound beep
SNDBEEP:
	OUT	(CRTBEEPPORT),A
	RET
;;
;; backspace
;;
BAKSPC:
	LD	HL,MIOBYTE
	LD	A,(HL)
	BIT	4,(HL)
	JR	NZ,MOVLFTDND		; set ND
	CALL	MOVLFTND,A
	XOR	A
	OUT	(CRT6545DATA),A
	DJNZ	RDPY1
; 	JP	CRTPRGEND

	; fall through...

;;
;; CRTPRGEND
;; resets 6545 register pointer
;
CRTPRGEND:
	LD	A,$1F
	OUT	(CRT6545ADST),A
	RET

;;
;; DISPGR - display in graphic mode (raw output)
;
DISPGR:
	IN	A,(CRT6545ADST)
	BIT	7,A
	JR	Z,DISPGR
	LD	HL,RAM0BUF
	LD	A,(HL)
	OUT	(CRTRAM0DAT),A
	INC	HL
	LD	A,(HL)
	OUT	(CRTRAM1DAT),A
	INC	HL
	LD	A,(HL)
	OUT	(CRTRAM2DAT),A
	LD	A,(RAM3BUF)
	OUT	(CRTRAM3PORT),A
	XOR	A
	OUT	(CRT6545DATA),A
	RET

;;
;; DISPCH - Display in text modeosition
	CALL	SCRSPOS
	LD	A,(COLBUF)
	INC	A
	CP	$50
	JR	Z,LFEED			; go down if needed
;;
SAVCOLB:
	LD	(COLBUF),A		; save cursor position
	RET
CONOU2:					; alternate processing....
	CP	$20			; is a ctrl char ??
	JR	NC,CURADR		; no: will set cursor pos
	ADD	A,A			; yes
	LD	H,0
	LD	L,A
	LD	BC,IOCVEC2
	ADD	HL,BC
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)			; jump to service routine... (IOCVEC2)
;; cursor addressing service routine
;; address is ESC + (COL # + 32) + (ROW # + 32) (then need a NUL to terminat
;; SCRTST - Verify if we need video scroll
;
SCRTST:
	LD	DE,(CURPBUF)
	XOR	A
	SBC	HL,DE
	LD	A,H
	CP	$07
	RET	C
	LD	A,L
	CP	$CF
	RET
;;
;; CLRSCR - clear screen (ASCII mode)
;
CLRSCR:
	LD	HL,$0000
	XOR	A
	LD	(COLBUF),A
	CPL
	LD	(RAM3BUF),A
	LD	(CURPBUF),HL
	CALL	SCRSPOS
	CALL	SDPYSTA
	PUSH	HL
CLSNC:	LD	A,$20
	CALL	DISPCH
	INC	HL
	LD	A,H
	CP	$08
	JR	NZ,CLSNC
	POP	HL
	JP	SCRSPOS

CURBLB:
	LD	L,$40           ; (0 10 00000) 1/16 blink scan 0
	JR	CURSETMODE
CURBLL:
	LD	L,$4A           ; (0 10 01010) 1/16 blink s		; destructive
	LD	A,' '
	CALL	DISPCH			; display char
	CALL	MOVRGT
	CALL	MOVLFTND
	RET

;;
;; cursor left, non destructive only
;;
MOVLFTND:
	LD	HL,MIOBYTE
	LD	A,(HL)
MLFTND:	PUSH	AF
	SET	4,(HL)
	CALL	MOVLFTDND
	POP	AF
	LD	(HL),A
	RET

;;
;; cursor left
;;
MOVLFTDND:
	CALL	GCRSPOS
	DEC	HL
	LD	DE,(CURPBUF)
	XOR	A
	SBC	HL,DE
	CP	H
	JR	NZ,MOVLFT1
	CP	L
	RET	Z
MOVLFT1:
	DEC	HL
	ADD	HL,DE
	CALL	SCRSPOS
	PUSH	HL
	LD	A,(COLBUF)
	DEC	A
	CP	$FF
	JR	NZ,MOVLFT2
	LD	A,$4F
MOVLFT2:
	LD	(COLBUF),A
	LD	HL,MIOBYTE
	BIT	4 (raw output)
;;
DISPCH:
	PUSH	AF
DGCLP0:	IN	A,(CRT6545ADST)
	BIT	7,A
	JR	Z,DGCLP0
	POP	AF
	OUT	(CRTRAM0DAT),A
	LD	A,(RAM3BUF)
	OUT	(CRTRAM3PORT),A
	XOR	A
	OUT	(CRT6545DATA),A
	RET


;;
;; BCONOUT print out the char in reg C
;; with full evaluation of control chars
;;
;; register clean: can be used as CP/M BIOS replacement
;;
BCONOUT:
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	; force jump to register restore and exit in stack
	LD	HL,BCEXIT
	PUSH	HL
	;
	LD	A,C
	LD	HL,MIOBYTE
	BIT	7,(HL)			; alternate char processe...)
CURADR:	LD	HL,TMPBYTE
	BIT	0,(HL)
	JR	NZ,SETROW
	CP	$70			; greater then 80 ?
	RET	NC			; yes: error
	SUB	$20			; no: ok
	LD	(APPBUF),A		; store column
	SET	0,(HL)			; switch row/col flag
	RET
SETROW:	CP	$39			; greater than 24 ?
	RET	NC			; yes: error
	SUB	$1F			; no: ok
	RES	0,(HL)			; resets flags
	LD	HL,MIOBYTE
	RES	7,(HL)			; done reset
	LD	B,A
	LD	HL,$FFB0
	LD	DE,$0050
CUROFS:	ADD	HL,DE			; calc. new offset
	DJNZ	CUROFS
	LD	A,(APPBUF)
	LD	(COLBUF),A
	LD	E,A
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(CURPBUF)
can 10
	JR	CURSETMODE
CURBFB:
	LD	L,$60           ; (0 11 00000) 1/32 blink scan 0
	JR	CURSETMODE
CURBFL:
	LD	L,$6A           ; (0 11 01010) 1/32 blink scan 10
	JR	CURSETMODE
SCUROF:
	LD	L,$20           ; (0 01 00000) cursor off
	JR	CURSETMODE
CURFXB:
	LD	L,$00           ; (0 00 00000) fixed scan 0
	JR	CURSETMODE
SCURON:
; 	LD	L,$0A           ; (0 00 01010) cursor on
	JR	CURSET
CURSETMODE:
	PUSH	HL
	JR	CURSET1

;;
;; Setup cursor. (user mode)
;;
CURSET:
	PUSH	HL
	LD	A,(CURSSHP)
	LD	L,A
CURSET1:
	LD	A,$0A
	O,(HL)
	POP	HL
	RET	NZ
	LD	A,$20
	JP	DISMVC
; 	JP	DISPCH
;;
;; CHOME - move cursor at col 0
;
CHOME:
	LD	HL,COLBUF
	LD	E,(HL)
	XOR	A
	LD	(HL),A
	LD	D,A
	CALL	GCRSPOS
	DEC	HL
	SBC	HL,DE
	CALL	SCRSPOS
	RET

;; IOCCR - handle carriage return (0x0d)
;; should position the cursor at col 0
;
IOCCR:
	EX	DE,HL
	BIT	3,(HL)
	JR	Z,IOCCR1
	CALL	CLREOL
IOCCR1:	JR	CHOME
;;
;; clear to end of page
;;
CLREOP:
	XOR	A
	LD	HL,(CURPBUF)
	LD	DE,$07D0
	ADD	HL,DE
	EX	DE,HL
	CALL	GCRSPOS
	DEC	HL
	EX	DE,HL
	SBC	HL,DE
	PUSH	HL
	POP	B	RET
BLUEON:
	LD	HL,RAM3BUF
	SET	7,(HL)
	RET
BLINKON:
	LD	HL,RAM3BUF
	RES	0,(HL)
	RET
REVON:
	LD	HL,RAM3BUF
	RES	1,(HL)
	RET
UNDERON:
	LD	HL,RAM3BUF
	RES	2,(HL)
	RET
HLIGHTON:
	LD	HL,RAM3BUF
	RES	3,(HL)
	RET
REDOFF:
	LD	HL,RAM3BUF
	RES	5,(HL)
	RET
GREENOFF:
	LD	HL,RAM3BUF
	RES	6,(HL)
	RET
BLUEOFF:
	LD	HL,RAM3BUF
	RES	7,(HL)
	RET
;;
;; MOVDWN - cursor down one line
;
MOVDWN:
	CALL	GCRSPOS
	DEC	HL
	LD	DE,$0050
	ADD	HL,DE
	CALL	SCRSPOS
	JP	LFEED1
;;
RIOCESC:
	EX	DE,HL
	RES	7,(HL)
	RET
;
SASCFLTR:
	EX	DE,HL
	SE  clear to EOP
	DW	CLREOL			; SI  0x0f (^O)  clear to EOL
	DW	IOCNULL			; DLE 0x10 (^P)  no-op
	DW	RESATTR			; DC1 0x11 (^Q)  reset all attributes
	DW	CRTCINI			; DC2 0x12 (^R)  hard crt reset and clear
	DW	IOCNULL			; DC3 0x13 (^S)  no-op
	DW	IOCNULL			; DC4 0x14 (^T)  no-op
	DW	MOVUP			; NAK 0x15 (^U)  cursor up one line
	DW	SCROLLOFF		; SYN 0x16 (^V)  scroll off
	DW	SCROLLON		; ETB 0x17 (^W)  scroll on
	DW	MOVLFTND		; CAN 0x18 (^X)  cursor left (non destr. only)
	DW	MOVRGT			; EM  0x19 (^Y)  cursor right5 RAM3BUF (red)
	DW	REDOFF			; SI  0x0f (^O)  res bit 5 RAM3BUF (red)
	DW	GREENON			; DLE 0x10 (^P)  set bit 6 RAM3BUF (green)
	DW	GREENOFF		; DC1 0x11 (^Q)  res bit 6 RAM3BUF (green)
	DW	CURBLB			; DC2 0x12 (^R)  cursor blink slow block
	DW	CURBLL			; DC3 0x13 (^S)  cursor blink slow line
	DW	IOCNULL			; DC4 0x14 (^T)  no-op
	DW	IOCNULL			; NAK 0x15 (^U)  no-op
	DW	IOCNULL			; SYN 0x16 (^V)  no-op
	DW	SASCFLTR		; ETB 0x17 (^W)  set ascii filter
	DW	RASCFLTR		; CAN 0x18 (^X)  reset ascii filter
	DW	NDBKSP		C
CLRJ0:	CALL	CLRLIN1
	EX	DE,HL
	JP	SCRSPOS
;;
;; CLREOL - clear to end of line
;
CLREOL:
	LD	A,(COLBUF)
	LD	B,A
	LD	A,$50
	SUB	B
	LD	B,$00
	LD	C,A
	CALL	GCRSPOS
	DEC	HL
	EX	DE,HL
	JR	CLRJ0
;;
SCROLLOFF:
	EX	DE,HL
	SET	2,(HL)
	RET
SCROLLON:
	EX	DE,HL
	RES	2,(HL)
	RET
SIOCESC:
	EX	DE,HL
	SET	7,(HL)
	RET
;;
;; RESATTR - reset all attributes
;
RESATTR:
	LD	A,$FF
	LD	(RAM3BUF),A
	RET

;;
;; IOCNULL (a void routine) from here a list of routines to handle
;; console char output while in alternate processing (ESC T	6,(HL)
	RET

;;
;; CLRLIN - clear current line
;
CLRLIN:
	LD	BC,$0050
CLRLIN1:
	LD	A,(RAM3BUF)
	PUSH	AF
	LD	A,$FF
	LD	(RAM3BUF),A
CLRLP1:	LD	A,$20
	CALL	DISPCH
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,CLRLP1
	POP	AF
	LD	(RAM3BUF),A
	RET

;; This table define the offsets to jump to control routines
;; for primary (non-escaped) mode

IOCVEC:
	DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
	DW	UCASEMOD		; SOH 0x01 (^A)  uppercase mode
	DW	LCASEMOD		; STX 0x02 (^B)  normal case mode
	DW	IOCNULL			; ETX 0
	DW	MOVDWN			; SUB 0x1a (^Z)  cursor down one line
	DW	SIOCESC			; ESC 0x1b (^[)  activate alternate output processing
	DW	IOCNULL			; FS  0x1c (^\)  no-op
	DW	IOCNULL			; GS  0x1d (^])  no-op
	DW	IOCNULL			; RS  0x1e (^^)  disabled (no-op)
	DW	IOCNULL			; US  0x1f (^_)  no-op

;; This table define the offsets to jump to control routines
;; for alternate (escaped) mode

IOCVEC2:
	DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
	DW	BLINKOFF		; SOH 0x01 (^A)  BLINK OFF
	DW	BLINKON			; STX 0x0	; EM  0x19 (^Y)  set non destructive BS
	DW	DBKSP			; SUB 0x1a (^Z)  set destructive BS
	DW	REVON			; ESC 0x1b (^[)  REVERSE ON
	DW	REVOFF			; FS  0x1c (^\)  REVERSE OFF
	DW	BLUEON			; GS  0x1d (^])  set bit 7 RAM3BUF (blue)
	DW	BLUEOFF			; RS  0x1e (^^)  res bit 7 RAM3BUF (blue)
	DW	IOCNULL			; US  0x1f (^_)  no-op

                                                                                                                                                                                                prefixed ctrl chars)
;
MOVUP:
	CALL	GCRSPOS
	LD	DE,$FFAF
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(CURPBUF)
	EX	DE,HL
	XOR	A
	SBC	HL,DE
	CPL
	CP	H
	ADD	HL,DE
	RET	Z
	JP	SCRSPOS
RASCFLTR:
	EX	DE,HL
	RES	6,(HL)
	RET
NDBKSP:
	EX	DE,HL
	SET	4,(HL)
	RET
DBKSP:
	EX	DE,HL
	RES	4,(HL)
	RET
BLINKOFF:
	LD	HL,RAM3BUF
	SET	0,(HL)
	RET
REVOFF:
	LD	HL,RAM3BUF
	SET	1,(HL)
	RET
UNDEROFF:
	LD	HL,RAM3BUF
	SET	2,(HL)
	RET
HLIGHTOFF:
	LD	HL,RAM3BUF
	SET	3,(HL)
	RET
REDON:
	LD	HL,RAM3BUF
	SET	5,(HL)
	RET
GREENON:
	LD	HL,RAM3BUF
	SET	6,(HL)
x00 (^C)  no-op
	DW	SCUROF			; EOT 0x04 (^D)  cursor off
	DW	SCURON			; ENQ 0x05 (^E)  cursor on
	DW	CRSLOC			; ACK 0x06 (^F)  locate cursor at CURPBUF
	DW	SNDBEEP			; BEL 0x07 (^G)  beep
	DW	BAKSPC			; BS  0x08 (^H)  cursor left (destr. and non destr.)
	DW	IOCNULL			; HT  0x09 (^I)  no-op
	DW	MOVDWN			; LF  0x0a (^J)  cursor down one line
	DW	CHOME			; VT  0x0b (^K)  cursor @ column 0
	DW	CLRSCR			; FF  0x0c (^L)  page down (clear screen)
	DW	IOCCR			; CR  0x0d (^M)  provess CR
	DW	CLREOP			; SO  0x0e (^N)2 (^B)  BLINK ON
	DW	UNDEROFF		; ETX 0x03 (^C)  UNDER OFF
	DW	UNDERON			; EOT 0x04 (^D)  UNDER ON
	DW	HLIGHTOFF		; ENQ 0x05 (^E)  HLIGHT OFF
	DW	HLIGHTON		; ACK 0x06 (^F)  HLIGHT ON
	DW	IOCNULL			; BEL 0x07 (^G)  no-op
	DW	IOCNULL			; BS  0x08 (^H)  no-op
	DW	IOCNULL			; HT  0x09 (^I)  no-op
	DW	IOCNULL			; LF  0x0a (^J)  no-op
	DW	IOCNULL			; VT  0x0b (^K)  no-op
	DW	DBLANK			; FF  0x0c (^L)  blank screen
	DW	RIOCESC			; CR  0x0d (^M)  clear alternate output processing
	DW	REDON			; SO  0x0e (^N)  set bit                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	EQU	0FC45H
BBU1TX         	EQU	0FC3FH
BBEXEC         	EQU	0FD29H
BBHDRD         	EQU	0FCFFH
BBVOID         	EQU	0FD6AH
UASTKB         	EQU	0FEA4H
MMPMAP         	EQU	0FD6BH
INTRDI         	EQU	0FE0FH
SCONIN         	EQU	0FC2DH
VCONIN         	EQU	0FC15H
BBDIV16        	EQU	0FCDBH
BBHDWR         	EQU	0FCF9H
MMGETP         	EQU	0FD78H
INTREN         	EQU	0FDFEH
RLDROM         	EQU	0FE97H
BBMUL16        	EQU	0FCE1H
SYSCOM         	EQU	0FC00H
UASTAV         	EQU	0FEA2H
SYTIMR         	EQU	0FE19H
SCONST           	EQU	0FD11H
BBRDVDSK       	EQU	0FC75H
BBFWRITE       	EQU	0FC8DH
BBCPBOOT       	EQU	0FCC3H
BBCURSET       	EQU	0FC21H
BBTRKSET       	EQU	0FCABH
BBWRVDSK       	EQU	0FC7BH
BBCONOUT       	EQU	0FD9FH
BBDRIVEID      	EQU	0FCF3H
BBPSNDBLK      	EQU	0FC63H
BBCRTCINI      	EQU	0FC03H
BBPRCVBLK      	EQU	0FC6FH
BBCRTFILL      	EQU	0FC09H
BBFDRVSEL      	EQU	0FCD5H
BBDPRMSET      	EQU	0FD17H
;****** EOF ***

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       	EQU	0FC33H
VCONST         	EQU	0FC1BH
SRXRSM         	EQU	0FE7FH
SRXSTP         	EQU	0FE7BH
BBU0INI        	EQU	0FC39H
BBU1INI        	EQU	0FC51H
BBFREAD        	EQU	0FC87H
BBEIDCK        	EQU	0FD23H
BBHDGEO        	EQU	0FD05H
BBSTACK        	EQU	0FED2H
BBFHOME        	EQU	0FC81H
BBCONIN        	EQU	0FD94H
CRDUREG        	EQU	0FC27H
SINTVEC        	EQU	0FFF0H
SYSCMLO        	EQU	0FED2H
VOIDISR        	EQU	0FE22H
BBSTTIM        	EQU	0FC9FH
BBCONST        	EQU	0FDAAH
SCONOUT        	EQU	0FC27H
VCONOUT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ;
;=======================================================================
;
; Modular Z80 DarkStar (NE Z80) Monitor
;
;=======================================================================
;
; Generic I/O ports
; ---------------------------------------------------------------------

GIOINI:
	LD	A,$CF			; 11-00-1111 mode ctrl word
					; Mode 3 (bit mode port B)
	OUT	(CRTPRNTCNT),A		; send to PIO0
	EX	AF,AF'
	XOR	A			; bit mask 00000000 (all outputs)
	OUT	(CRTPRNTCNT),A		; send to PIO0
	EX	AF,AF'			; relo;****** Equ's file autogenerated by genequs ver: 1.0
;****** Input files:
;****** SysCommon.lst
TX0            	EQU	0FE89H
FIN            	EQU	0FDC4H
TX01           	EQU	0FE8BH
DLY1           	EQU	0FD89H
DLY2           	EQU	0FD87H
FOUT           	EQU	0FDE1H
U1NUL          	EQU	0FE72H
U0ISR          	EQU	0FE25H
U1ISR          	EQU	0FE5BH
DELAY          	EQU	0FD85H
UISRE          	EQU	0FE50H
FSTAT          	EQU	0FDB5H
UISRI          	EQU	0FE35H
DOSTX          	EQU	0FE81H
BBU1ST         	EQU	0FC4BH
BBU1RX           	EQU	0FC0FH
BBOFFCAL       	EQU	0FCE7H
BBINICTC       	EQU	0FC57H
BBSTBASE       	EQU	0FEAEH
BBRESCTC       	EQU	0FC5DH
BBRDTIME       	EQU	0FCA5H
BBCALRET       	EQU	0FD5AH
BBDMASET       	EQU	0FCB7H
BBJTOBNK       	EQU	0FC00H
BBDSKSEL       	EQU	0FCBDH
BBHDINIT       	EQU	0FCEDH
BBSECSET       	EQU	0FCB1H
BBHDBOOT       	EQU	0FD0BH
BBUPLCHR       	EQU	0FC69H
BBPRNCHR       	EQU	0FC99H
BBVCPMBT       	EQU	0FCC9H
BBFLOPIO       	EQU	0FC93H
BBEPMNGR       	EQU	0FD1DH
BBSIDSET       	EQU	0FCCFH
BBLDPART                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ad mode 3 ctrl word
	OUT	(CRTKEYBCNT),A		; send to PIO1
	EX	AF,AF'
	DEC	A			; load bit mask 11111111 (all inputs)
	OUT	(CRTKEYBCNT),A		; send to PIO1
	EX	AF,AF'
	OUT	(CRTSERVCNT),A		; reload mode 3 ctrl word
	LD	A,$5D			; bit mask 01011101
					;          ||||||||- b0 in  (printer busy line)
					;          |||||||-- b1 out (40/80 col. mode)
					;          ||||||--- b2 in  (unassigned)
					;          |||||---- b3 in  (unassigned)
					;          ||||----- b4 in  (unassigned)
					;          ||------- b5 o
;;
;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
;;

	include darkstar.equ
	include Common.inc.asm

LF	EQU	0AH
CR	EQU	0DH
BS	EQU	08H		;Back space (required for sector display)
BELL	EQU	07H
TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
ESC	EQU	1BH
CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
				;on other video cards)
RDCON	EQU	1		;For CP/M I/O
WRCON	EQU	2
PRINT	EQU	9
CONST	EQU	11		;CONSOLE STAT
BDOS	EQU	5

FALSE	EQU	0
TRUE	EQU	-1

QUIT	EQU	0

	ORG	$1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                .j
. . ее:J o>
УЊ}УЌбГјЙлЛЮЙлЛћЙУЏЙ!L ~хЛжН<сwЙНI+н[H ЇнRј ЅИ+Нmе:O =юя >O2O !L ЛfбА> Гj!O ^ЇwWНI+нRНmЙлЛ^(НџеЇ*H РлНI+лнRеБНQлГm:O G>Pђ OНI+лилЛЦЙлЛ–ЙлЛюЙ>я2> ЙНIЇял*H лЇнR/јИГmлЛ¶ЙлЛжЙлЛ¦Й!> ЛЖЙ!> ЛОЙ!> ЛЦЙ!> ЛЮЙ!> ЛоЙ!> ЛцЙ!> ЛюЙ!> Л†Й!> ЛЋЙ!> Л–Й!> ЛћЙ!> Л®Й!> Л¶Й!> ЛѕЙНI+P НmГ‰лЛѕЙлЛцЙP :> х>я2> > НЮx± цс2> ЙF$(#>,<#8kТ|†џ#јя##В°ґ/%8ё####Fдрц #####‹Fь&,цъ###JШЬак2#>ПУѓЇУѓУ‡=У‡У‹>]У‹Ыut (ds1320 clock line)
					;          ||------- b6 in  (ds1320 i/o line)
					;          |-------- b7 out (ds1320 RST line)
	OUT	(CRTSERVCNT),A		; send to PIO2
	IN	A,(CRTSERVDAT)		; read data port PIO2
	RES	CLKRST,A		; ensure DS1320 RST line is low (active)
	RES	1,A			; Modo 40/80 colonne (80)
	OUT	(CRTSERVDAT),A		; send to PIO2
	RET

;;
;; PRNCHR - send a char to printer port (from C)
;
PRNCHR:
	IN	A,(CRTSERVDAT) 
	BIT	PRNTBUSYBIT,A
	JR	NZ,PRNCHR
	LD	A,C
	OUT	(CRTPRNTDAT),A
	RET

                         00

	LD	A,U0DEFSPEED		; uart 0 init
	LD	(UART0BR),A
	CALL	INIUART0
	LD	A,UART38K4		; uart 1 init
	LD	(UART1BR),A
	CALL	INIUART1

	LD	C,'@'
TRASM:	CALL	TXCHAR0
	CALL	TXCHAR1
	CALL	BBCONOUT
	INC	C
	LD	A,C
	CP	'z'
	JR	NZ,TRASM
	LD	C,'@'
	JR	TRASM

; RECE:	CALL	RXCHAR1
; 	CP	3
; 	JP	Z,0
; 	LD	C,A
; 	CALL	BBCONOUT
; 	JR	RECE



;-------------------------------------------------------------------------------

MSINIT		DB 'Initalising UART...',CR,LF,'$'
MSINITOK	DB 'Ok.',CR,LF,'$'
MSINITNOK	DB 'Failure',CR,LF,'$'
;>2+ НN>2* НW@НбНыНџэyюz с@нInitalising UART...
$Ok.
$Failure
$   >А2кН`Й>И2кН`ЙЕЄ:кЖOнA:кЖOнxюЄВЭU:кЖOнA:кЖOнxюUВЭЂ:кЖOнA:кюА :+ G:* G:кЖ OнA :кЖOнA:кЖOнA:кЖOнA:кЖOнAБЇЙБ>яЙyЕх>АЖOнxЛoКдсG>АЖ OнAБЙyЕх>ИЖOнxЛoКюсG>ИЖ OнAБЙЕ>ИЖOнxЛG(х>ИЖ OнxБЙЕЭеХеЭ!K Э~ Лo >АЖOнxЛG(х>АЖ OнxЭ! Нµэ(ыуНбэыy!L Л^(юaъpю{тpЛЇбСЭбБЙ:K Лo Е>АЖOнxЛGБ ЇЙЭеЭ! НµэЭб ЇЙ>яЙЕ>ИЖOнxЛGБ ЇЙ>яЙНЬ>рУи>ЧУл>Ул>ЧУк>Ук>ЧУй:( Уй>'Уи:) УиЙнMНЪ>УиУйУкУлЙ oPW( H         Н‰ЛїЛЏУ‰ЙЫ‰ЛG ъyУЃЙ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
;-------------------------------------------------------------------------------

SER_ON:		DS	1	; serial on/off
UART_FAIL:	DS	1	; UART has failed detection flag
SER_BAUD:	DS	1	; specify desired UART com rate in bps

	include uartctc.inc.asm
	include crtc.inc.asm
	include genio.inc.asm

	END

                                                                                                                                                                                                                          Н‹Нй>я2> !  "H )>ЏУ‚У†УЉН#Гј!л xУЊ~УЌ#xю ф!  "H НZ*H НmЇ2O Й>УЊЫЌg>УЊЫЌo#b>УЊ|УЌ>УЊ}УЌRНЮ>УЊ|УЌ>УЊ}УЌ>УЊ|УЌ>УЊ}УЌ1!  "; Ї2= >п2> !  "H Н°еНБб#|ю х xЖУЊЇУЌц>УЊЙЫЊЛ(ъ!; ~УЂ#~У„#~У€:> УЋЇУЌЙхЫЊЛ(ъсУЂ:> УЋЇУЌЙхЕХе!Ђеy!L Л~л 5ю 0‡& oi	~#foйлЛv(
ю@8ю`0Ц@НЮНIНm:O <юP(R2O Йю 0‡& o©	~#foй!K ЛF юpРЦ 2- ЛЖЙю9РЦЛ†!L ЛѕG!°яP э:- 2O _л*H ГmбСБсЙЇ2O НГШ!L ЛV0шНI+(ГmеНN*H P  енRб8Лњ"H НZб8ЛњГmн[H ЇнR|юШ}юПЙ!  Ї2O /2> "H НmНZе> НЮ#|ю хбГm.@.J.`   1:			
   2:			;;
   3:			;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
   4:			;;
   5:			
   6:				include darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FDC4          	FIN            	EQU	0FDC4H
   5:	FD89          	DLY1           	EQU	0FD89H
   6:	FD87          	DLY2           	EQU	0FD87H
   7:	FDE1          	FOUT           	EQU	0FDE1H
   8:	FE70          	U1NUL          	EQU	0FE        	RLDROM         	EQU	0FE79H
  31:	FCE1          	BBMUL16        	EQU	0FCE1H
  32:	FC00          	SYSCOM         	EQU	0FC00H
  33:	FE84          	UASTAV         	EQU	0FE84H
  34:	FE19          	SYTIMR         	EQU	0FE19H
  35:	FC33          	SCONST         	EQU	0FC33H
  36:	FC1B          	VCONST         	EQU	0FC1BH
  37:	FC39          	BBU0INI        	EQU	0FC39H
  38:	FC51          	BBU1INI        	EQU	0FC51H
  39:	FC87          	BBFREAD        	EQU	0FC87H
  40:	FD23          	BBEIDCK        	EQU	0FD        	BBHDINIT       	EQU	0FCEDH
  63:	FCB1          	BBSECSET       	EQU	0FCB1H
  64:	FD0B          	BBHDBOOT       	EQU	0FD0BH
  65:	FC69          	BBUPLCHR       	EQU	0FC69H
  66:	FC99          	BBPRNCHR       	EQU	0FC99H
  67:	FCC9          	BBVCPMBT       	EQU	0FCC9H
  68:	FC93          	BBFLOPIO       	EQU	0FC93H
  69:	FD1D          	BBEPMNGR       	EQU	0FD1DH
  70:	FCCF          	BBSIDSET       	EQU	0FCCFH
  71:	FD11          	BBLDPART       	EQU	0FD11H
  72:	FC75          	BBRDVDSK       	EQU	0FC0 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
  10:			;
  11:			; Disassembled and reconstructed by
  12:			; Piergiorgio Betti <pbetti@lpconsul.net> on 2005 01 26
  13:			;
  14:			; Latest non modular BIOS is DARKSTAR-MONITOR-0.9.0.asm
  15:			; dated 20140531
  16:			; - Following addition of MultiF-Board doing complete rewrite of the
  17:			;   monitor/BIOS has been started.
  18:			;   Major goals:
  19:			;   o Modularization: Now monitor can grow up to 256kb instead of 4kb
  20:			;     :-)
  270H
   9:	FE25          	U0ISR          	EQU	0FE25H
  10:	FE59          	U1ISR          	EQU	0FE59H
  11:	FD85          	DELAY          	EQU	0FD85H
  12:	FE4E          	UISRE          	EQU	0FE4EH
  13:	FDB5          	FSTAT          	EQU	0FDB5H
  14:	FE32          	UISRI          	EQU	0FE32H
  15:	FC4B          	BBU1ST         	EQU	0FC4BH
  16:	FC45          	BBU1RX         	EQU	0FC45H
  17:	FC3F          	BBU1TX         	EQU	0FC3FH
  18:	FD29          	BBEXEC         	EQU	0FD29H
  19:	FCFF          	BBHDRD 23H
  41:	FD05          	BBHDGEO        	EQU	0FD05H
  42:	FEB4          	BBSTACK        	EQU	0FEB4H
  43:	FC81          	BBFHOME        	EQU	0FC81H
  44:	FD94          	BBCONIN        	EQU	0FD94H
  45:	FC27          	CRDUREG        	EQU	0FC27H
  46:	FFF0          	SINTVEC        	EQU	0FFF0H
  47:	FEB4          	SYSCMLO        	EQU	0FEB4H
  48:	FE22          	VOIDISR        	EQU	0FE22H
  49:	FC9F          	BBSTTIM        	EQU	0FC9FH
  50:	FDAA          	BBCONST        	EQU	0FDAAH
  51:	FC27          	SCONOUT75H
  73:	FC8D          	BBFWRITE       	EQU	0FC8DH
  74:	FCC3          	BBCPBOOT       	EQU	0FCC3H
  75:	FC21          	BBCURSET       	EQU	0FC21H
  76:	FCAB          	BBTRKSET       	EQU	0FCABH
  77:	FC7B          	BBWRVDSK       	EQU	0FC7BH
  78:	FD9F          	BBCONOUT       	EQU	0FD9FH
  79:	FCF3          	BBDRIVEID      	EQU	0FCF3H
  80:	FC63          	BBPSNDBLK      	EQU	0FC63H
  81:	FC03          	BBCRTCINI      	EQU	0FC03H
  82:	FC6F          	BBPRCVBLK      	EQU	0FC6FH
  83:	FC09          	BBCRTFI1:			;   o Specialized images fitted in memory page (4kb) or multiples
  22:			;   o Full support for new hardware
  23:			;   o I/O rewrite for MODE 2 interrupts
  24:			;   Minor goals:
  25:			;   o Full code clean-up & reoarganization
  26:			; ---------------------------------------------------------------------
  27:			; Revisions:
  28:			; 20140905 - Modified hexadecimal constants to 0xxH format to widely
  29:			;            accepeted by different assemblers
  30:			; ------------------------------        	EQU	0FCFFH
  20:	FD6A          	BBVOID         	EQU	0FD6AH
  21:	FE86          	UASTKB         	EQU	0FE86H
  22:	FD6B          	MMPMAP         	EQU	0FD6BH
  23:	FE0F          	INTRDI         	EQU	0FE0FH
  24:	FC2D          	SCONIN         	EQU	0FC2DH
  25:	FC15          	VCONIN         	EQU	0FC15H
  26:	FCDB          	BBDIV16        	EQU	0FCDBH
  27:	FCF9          	BBHDWR         	EQU	0FCF9H
  28:	FD78          	MMGETP         	EQU	0FD78H
  29:	FDFE          	INTREN         	EQU	0FDFEH
  30:	FE79          	EQU	0FC27H
  52:	FC0F          	VCONOUT        	EQU	0FC0FH
  53:	FCE7          	BBOFFCAL       	EQU	0FCE7H
  54:	FC57          	BBINICTC       	EQU	0FC57H
  55:	FE90          	BBSTBASE       	EQU	0FE90H
  56:	FC5D          	BBRESCTC       	EQU	0FC5DH
  57:	FCA5          	BBRDTIME       	EQU	0FCA5H
  58:	FD5A          	BBCALRET       	EQU	0FD5AH
  59:	FCB7          	BBDMASET       	EQU	0FCB7H
  60:	FC00          	BBJTOBNK       	EQU	0FC00H
  61:	FCBD          	BBDSKSEL       	EQU	0FCBDH
  62:	FCED  LL      	EQU	0FC09H
  84:	FCD5          	BBFDRVSEL      	EQU	0FCD5H
  85:	FD17          	BBDPRMSET      	EQU	0FD17H
  86:			;****** EOF ***
  87:			
**** sert.asm ****
   7:				include Common.inc.asm
**** Common.inc.asm ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) SysBios
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; Original code:
   9:			; Z8---------------------------------------
  31:			
  32:			
  33:			; ---------------------------------------------------------------------
  34:			; SYSBIOS
  35:			;
  36:			; This is the BIOS non-resident portion of the new (banked)
  37:			; BIOS/Monitor for the NE Z80 (aka DarkStar)
  38:			;
  39:			; ---------------------------------------------------------------------
  40:			;
  41:			; Full BIOS memory scheme:
  42:			;
  43:			;	+-----------------+
  44:			;	+    SysCommon    +   <-- Resident porti  SysCommon    +
  68:			;	+   FC00 - FFFF   +
  69:			;	+   BootMonitor   +     <-- EEPROM page 0 ($C0000)
  70:			;	+   F000 - FBFF   +
  71:			;	+-----------------+
  72:			;
  73:			; ---------------------------------------------------------------------
  74:			;
  75:			; Define which assembler we are using
  76:			;
  77:			
  78:			; PASMO	EQU	1
  79:	0001          	MZMAC	EQU	1
  80:			; ZMAC	EQU	1			; ZMAC Z80 assembler, not Linux/Unix version
  81:			
  82:			; ... only one at a time can be active  = drive 3
 111:								; - bits: 4 = unused
 112:								; - bits: 5 = head select
 113:								; - bits: 6 = motor on (disabled by jumper)
 114:								; - bits: 7 = unused
 115:	004D          	KBDBYTE		EQU	DSELBF-1	; byte: store keyboard input
 116:	004C          	MIOBYTE		EQU	KBDBYTE-1	; byte:
 117:								; - bits: 0: 0 = floppy write		1 = floppy read
 118:								;         1: 0 = no ctrl on keypress	1 = ctrl on keypress
 119:								;         2: 0 = scroll			1 = no scroll
 120:								;         3: 0 =   	FTRKBUF		EQU	CURPBUF-2	; word: track # for i/o (0 - 65535)
 137:	0045          	FDRVBUF		EQU	FTRKBUF-1	; byte: drive number for i/0 (0 - 15)
 138:	0043          	FSECBUF		EQU	FDRVBUF-2	; word: sector # for i/o (1 .. 65535)
 139:	0041          	FRDPBUF		EQU	FSECBUF-2	; word: dma address for i/o
 140:	003F          	FSEKBUF		EQU	FRDPBUF-2	; word: current track number for drive A/B
 141:	003E          	RAM3BUF		EQU	FSEKBUF-1	; byte:
 142:	003D          	RAM2BUF		EQU	RAM3BUF-1	; byte:
 143:	003C          	Ron. Common to all images
  45:			;	+   FC00 - FFFF   +
  46:			;	+-----------------+
  47:			;	+-----------------+   +-----------------+   +-----------------+
  48:			;	+     SysBios     +   +   BootMonitor   +   +     [Other]     +
  49:			;	+   F000 - FBFF   +   +   F000 - FBFF   +   +   F000 - FBFF   +
  50:			;	+-----------------+   +-----------------+   +-----------------+
  51:			;
  52:			;	         ^                     ^                     ^
  53:			;	         |                     |              (1) ...
  83:			
  84:			;
  85:			; Monitor version numbers (major.minor)
  86:			;
  87:	0033          	MONMAJ		EQU	'3'
  88:	0032          	MONMIN		EQU	'2'
  89:			
  90:			;
  91:			; Buffers addresses labels
  92:			;
  93:			
  94:			; -- Global --
  95:	0003          	IOBYTE		EQU	0003H		; byte: Intel IOBYTE (CP/M 2.2 only)
  96:	0004          	CDISK		EQU	0004H		; byte: Last logged drive
  97:	0006          	BTPASIZ		EQU	0006H		; word: size of tpa + 1
  98:			;
  99:			; -- Private --
 100:	000B       accept lowercase	1 = convert to uppercase
 121:								;         4: 0 = destr. bkspace		1 = non destr. bkspace
 122:								;         5: 0 = console out		1 = serial out
 123:								;         6: 0 = disp. all chars	1 = obscure non punct.
 124:								;         7: 0 = ctrl chr set 1		1 = ctrl chr set 2
 125:	004B          	TMPBYTE		EQU	MIOBYTE-1	; byte: transients flags
 126:								; - bits: 0: 0 = high in cursor addressing
 127:								;         1: 0 = ESC catched by ANSI driver
 128:								;         2: AM1BUF		EQU	RAM2BUF-1	; byte:
 144:	003B          	RAM0BUF		EQU	RAM1BUF-1	; byte:
 145:	003A          	RST7SP3		EQU	003AH		; keep clear area of RST38 (RST7)
 146:	0039          	RST7SP2		EQU	0039H
 147:	0038          	RST7SP1		EQU	0038H
 148:	002F          	VDSKBUF		EQU	RST7SP1-9	; table: 9 bytes command structure buffer
 149:	002D          	APPBUF		EQU	VDSKBUF-2	; word: generic buffer
 150:	002C          	COPSYS		EQU	APPBUF-1	; Op system type for partition selection
 151:	002B          	UART0BR		EQU	COPSYS       |
  54:			;	         ---------------------------------------------
  55:			;	                      Variable section
  56:			;
  57:			; The above are always assembled at ORG F000 and linked and allocated
  58:			; in the EEPROM in this way:
  59:			;
  60:			;	+-----------------+
  61:			;	+    SysCommon    +
  62:			;	+   FC00 - FFFF   +
  63:			;	+     SysBios     +     <-- EEPROM page 1 ($C1000)
  64:			;	+   F000 - FBFF   +
  65:			;	+-----------------+
  66:			;	+-----------------+
  67:			;	+      	HMEMPAG		EQU	000BH		; byte: highest ram page
 101:	000C          	BBCBANK		EQU	000CH		; byte: current bank
 102:	000D          	BBCSTCK		EQU	000DH		; word: current stack
 103:					;
 104:	004F          	PRVTOP		EQU	004FH		; top of private area storage
 105:	004F          	COLBUF		EQU	PRVTOP		; byte:
 106:	004E          	DSELBF		EQU	COLBUF-1	; byte: floppy drive select status
 107:								; - bits: 0 = drive 0
 108:								; - bits: 1 = drive 1
 109:								; - bits: 2 = drive 2
 110:								; - bits: 30 = CSI catched by ANSI driver
 129:								;         3: 0 = Two byte code ESC seq. from serial
 130:								;         4: 0 = Plain serial i/o (disable ANSI driver)
 131:								;         5: 0 = store interrupt status (on/off)
 132:								;         6: 0 = floppy home on err	1 = no home on err
 133:								;         7: 0 = unlock LBA free addressing (unpartitioned)
 134:	004A          	CURSSHP		EQU	TMPBYTE-1	; cursor shape
 135:	0048          	CURPBUF		EQU	CURSSHP-2	; word: cursor position
 136:	0046       -1	; UART 0 baudrate
 152:	002A          	UART1BR		EQU	UART0BR-1	; UART 1 baudrate
 153:	0029          	CTC0TC		EQU	UART1BR-1	; CTC channel 0 time constant
 154:	0028          	CTC1TC		EQU	CTC0TC-1	; CTC channel 1 time constant
 155:	0027          	TIMRCON		EQU	CTC1TC-1	; timer buf
 156:	0026          	CNFBYTE		EQU	TIMRCON-1	; config byte
 157:								; - bits: 0: 0 = UART1 intr disabled	1 = RST8 redir UART1
 158:								;         1: 0 = unused/reserved
 159:								;         2: 0 = unused/reserved
 160:			   	TPA		EQU	0100H		; TPA base address (for CP/M)
 184:			
 185:			;
 186:			; Modules equs
 187:			;
 188:				; delay
 189:	00F6          	MSCNT		EQU	246
 190:				; mmu
 191:	000D          	MMUTSTPAGE	EQU	0DH		; logical page used for sizing
 192:	D000          	MMUTSTADDR	EQU	MMUTSTPAGE<<12	; logical page used for sizing
 193:			
 194:			; Conventionally all bios/monitor images start at $F000.
 195:			; Except for special cases all code is copied to ram @ $F000.
 196:			; In this case eeprom page 0 is dire      	CRTRAM0CNT	EQU	CRTBASE+2	; RAM0 access: PIO0 port A control register
 225:				; Printer port
 226:	0081          	CRTPRNTDAT	EQU	CRTBASE+1	; PRINTER (output): PIO0 port B data register
 227:	0083          	CRTPRNTCNT	EQU	CRTBASE+3	; PRINTER (output): PIO0 port B control register
 228:								; STROBE is generated by hardware
 229:				; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
 230:	0084          	CRTRAM1DAT	EQU	CRTBASE+4	; RAM1 access: PIO1 port A data register
 231:	0086          	CRTRAM1C        	PIO2BIT3	EQU	3		; user 2 (input)		(in)	1
 246:	0004          	PIO2BIT4	EQU	4		; user 3 (input)		(in)	1
 247:	0005          	CLKSCLK		EQU	5		; DS1320 clock line		(out)	0
 248:	0006          	CLKIO		EQU	6		; DS1320 I/O line		(i/o)	1
 249:	0007          	CLKRST		EQU	7		; DS1320 RST line		(out)	0
 250:				; normal set for PIO2 (msb) 01011101 (lsb) that is hex $5D
 251:								; Other bits available to user
 252:				; RAM3 control chars/graphics attributes
 253:	008E          	CRTRAM3PORT	EQU	CRTBASE+14					;         3: 0 = unused/reserved
 161:								;         4: 0 = unused/reserved
 162:								;         5: 0 = unused/reserved
 163:								;         6: 0 = unused/reserved
 164:								;         7: 0 = unused/reserved
 165:	000F          	FIFOSTO		EQU	000FH		; fifo queues storage start
 166:	0008          	FIFSIZE		EQU	8		; fifo queue lenght
 167:	000B          	FIFBLOK		EQU	11		; fifo queue size
 168:	000F          	FIFOU0		EQU	FIFOSTO		; uart 0 queue (alternate console)
 169:	001A          	FIFOKB		EQctly mapped into logical space
 197:			; by hardware so we can initialize the system at cold boot.
 198:			;
 199:			; We assume to initialize MMU as follow:
 200:			;
 201:			; +--------+
 202:			; |  F000  |	-> $C0000  eeprom page 0
 203:			; +--------+
 204:			; +--------+
 205:			; |  EFFF  |
 206:			; +--------+
 207:			;     ...       -> $00000 to $0EFFF ram
 208:			; +--------+
 209:			; |  0000  |
 210:			; +--------+
 211:			;
 212:			
 213:			
 214:			; include	modules/hwequs.inc.asm
 215:			; HarNT	EQU	CRTBASE+6	; RAM1 access: PIO1 port A control register
 232:				; Keyboard port (negated). Bit 7 is for strobe
 233:	0085          	CRTKEYBDAT	EQU	CRTBASE+5	; KEYBOARD (input): PIO1 port B data register
 234:	0087          	CRTKEYBCNT	EQU	CRTBASE+7	; KEYBOARD (input): PIO1 port B control register
 235:	0007          	KEYBSTRBBIT	EQU	7		; Strobe bit
 236:				; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
 237:	0088          	CRTRAM2DAT	EQU	CRTBASE+8	; RAM2 access: PIO2 port A data register
 238:		; RAM3 port
 254:	0000          	CRTBLINKBIT	EQU	0		; Blink
 255:	0001          	CRTREVRSBIT	EQU	1		; Reverse
 256:	0002          	CRTUNDERBIT	EQU	2		; Underline
 257:	0003          	CRTHILITBIT	EQU	3		; Highlight
 258:	0004          	CRTMODEBIT	EQU	4		; ASCII/GRAPHIC mode
 259:				; Beeper port
 260:	008F          	CRTBEEPPORT	EQU	CRTBASE+15	; Beeper port
 261:				; 6545 CRT controller ports
 262:	008C          	CRT6545ADST	EQU	CRTBASE+12	; Address & Status register
 263:	008D          	CRT6545DATA	EQU	CRU	FIFOU0+FIFBLOK	; keyboard queue
 170:	0025          	FIFOEND		EQU	FIFOKB+FIFBLOK	; fifo blocks end
 171:			;
 172:	3000          	BLDOFFS		EQU	3000H		; place for disk bootloader
 173:			
 174:			;
 175:			; Some commodity equs
 176:			;
 177:	000D          	CR		EQU	0DH		; ascii CR & LF
 178:	000A          	LF		EQU	0AH
 179:	000C          	FF		EQU	0CH		; FORM FEED (clear screen)
 180:	001B          	ESC		EQU	1BH		; ESCape
 181:	FFFF          	TRUE		EQU	-1
 182:	0000          	FALSE		EQU	0
 183:	0100       dware equates
 216:			; ---------------------------------------------------------------------
 217:			
 218:			; ---------------------------------------------------------------------
 219:			; LX529 VIDEO BOARD:
 220:			; ---------------------------------------------------------------------
 221:	0080          	CRTBASE		EQU	80H
 222:				; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
 223:	0080          	CRTRAM0DAT	EQU	CRTBASE		; RAM0 access: PIO0 port A data register
 224:	0082    008A          	CRTRAM2CNT	EQU	CRTBASE+10	; RAM2 access: PIO2 port A control register
 239:				; Service/User port
 240:	0089          	CRTSERVDAT	EQU	CRTBASE+9	; Service (i/o): PIO2 port B data register
 241:	008B          	CRTSERVCNT	EQU	CRTBASE+11	; Service (i/o): PIO2 port B control register
 242:	0000          	PRNTBUSYBIT	EQU	0		; Printer BUSY bit		(in)	1
 243:	0001          	CRTWIDTHBIT	EQU	1		; Set 40/80 chars per line	(out)	0
 244:	0002          	PIO2BIT2	EQU	2		; user 1 (input)		(in)	1
 245:	0003  TBASE+13	; Data register
 264:				; Cursor modes
 265:	0040          	BLISLOWBLOK	EQU	40H		; Blink, slow, block
 266:	004A          	BLISLOWLINE	EQU	4AH		; Blink, slow, line
 267:	0060          	BLIFASTBLOK	EQU	60H		; Blink, fast, block
 268:	006A          	BLIFASTLINE	EQU	6AH		; Blink, fast, line
 269:	0020          	CURSOROFF	EQU	20H		; Off
 270:	0000          	FIXBLOCK	EQU	00H		; Fixed, block
 271:	000A          	CURSORON	EQU	0AH		; On
 272:			
 273:			; --------------------------------------------------2:	0003          	ALTPRNPRT	EQU	03H
 293:			;
 294:			; parallel port PC link
 295:	0003          	PPDATAP		EQU	03H		; Data port
 296:	0002          	PPCNTRP		EQU	02H		; Control port
 297:	0000          	PPSTROB		EQU	0		; Strobe bit
 298:	0001          	PPAKSTB		EQU	1		; Acknowledge/Stop bit
 299:			;
 300:	0000          	PPDINI		EQU	00H		; 00000000 Dnl Init byte
 301:	0004          	PPDRDY		EQU	04H		; 00000100 Dnl Ready
 302:	0006          	PPDSTP		EQU	06H		; 00000110 Dnl Stop
 303:	0002          	PPDOKG		op page (256 bytes pages)
 323:	00FF          	IMTPAG		EQU	0FFH		; eeprom page with image table
 324:	0400          	IMTSIZ		EQU	1024		; size
 325:	E000          	RAMTBL		EQU	0E000H		; ram table location
 326:	0030          	TBLBLK		EQU	48		; block size
 327:	0014          	MAXBLK		EQU	20		; max images
 328:	03C0          	RTBSIZ		EQU	TBLBLK * MAXBLK	; real table size
 329:								; A table block is:
 330:	0008          	TNAMELEN	EQU	8		;	name		: 8 bytes
 331:	0002          	TPAGELEN	EQU	2		;	page offset	: 8255 and IDE interface
 348:	0010          	IDECS1LINE	EQU	10H		;inverter between 8255 and IDE interface
 349:	0020          	IDEWRLINE	EQU	20H		;inverter between 8255 and IDE interface
 350:	0040          	IDERDLINE	EQU	40H		;inverter between 8255 and IDE interface
 351:	0080          	IDERSTLINE	EQU	80H		;inverter between 8255 and IDE interface
 352:			;Symbolic constants for the IDE Drive registers
 353:	0008          	REGDATA		EQU	IDECS0LINE
 354:	0009          	REGERR		EQU	IDECS0LINE + IDEA0LINE
 355:	-------------------
 274:			; LX390 FDC CONTROLLER:
 275:			; ---------------------------------------------------------------------
 276:	00D0          	FDCBASE		EQU	0D0H
 277:	00D0          	FDCCMDSTATR	EQU	FDCBASE		; Command and status register
 278:	00D1          	FDCTRAKREG	EQU	FDCBASE+1	; Track register
 279:	00D2          	FDCSECTREG	EQU	FDCBASE+2	; Sector register
 280:	00D7          	FDCDATAREG	EQU	FDCBASE+7	; Data register *** Verificare che sia $d7
 281:	00D6          	FDCDRVRCNT	EQU	FDCBASE+6	; DEQU	02H		; 00000010 Dnl Ok Go
 304:	0001          	PPUINI		EQU	01H		; 00000001 Upl Init byte
 305:	0005          	PPURDY		EQU	05H		; 00000101 Upl Ready
 306:	0007          	PPUACK		EQU	07H		; 00000111 Upl Acknowledge
 307:	0003          	PPUOKG		EQU	03H		; 00000011 Upl Ok Go
 308:			;
 309:			; virtual disks (PC-linked over parallel port)
 310:	0000          	VDRDSEC		EQU	0		; read sector command
 311:	0001          	VDWRSEC		EQU	1		; write sector command
 312:	000A          	VDBUFSZ		EQU	10		; 9 bytes bloc2 bytes
 332:	0004          	TIADDRLEN	EQU	4		;	image address	: 4 bytes
 333:	0004          	TSIZELEN	EQU	4		;	image size	: 4 bytes
 334:	0014          	TDESCLEN	EQU	20		;	description	: 20 bytes
 335:			; -- IDE --
 336:	00E0          	IDEPORTA	EQU	0E0H		;lower 8 bits of IDE interface
 337:	00E1          	IDEPORTB	EQU	0E1H		;upper 8 bits of IDE interface
 338:	00E2          	IDEPORTC	EQU	0E2H		;control lines for IDE interface
 339:	00E3          	IDEPORTCTRL	EQU	0E3H		;8255 configuration port
 340:			
 341:000A          	REGSECCNT	EQU	IDECS0LINE + IDEA1LINE
 356:	000B          	REGSECTOR	EQU	IDECS0LINE + IDEA1LINE + IDEA0LINE
 357:	000C          	REGCYLLSB	EQU	IDECS0LINE + IDEA2LINE
 358:	000D          	REGCYLMSB	EQU	IDECS0LINE + IDEA2LINE + IDEA0LINE
 359:	000E          	REGSHD		EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE		;(0EH)
 360:	000F          	REGCOMMAND	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE	;(0FH)
 361:	000F          	REGSTATUS	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
 362:	0016    river select/control register
 282:			;
 283:	0007          	FDCRESTC	EQU	007H		; 1771 restore (seek to trak 0) cmd
 284:	0017          	FDCSEEKC	EQU	017H		; seek cmd
 285:	0088          	FDCREADC	EQU	088H		; read cmd
 286:	00A8          	FDCWRITC	EQU	0A8H		; write cmd
 287:			;
 288:			; ---------------------------------------------------------------------
 289:			; LX389: PARALLEL INTERFACE
 290:			; ---------------------------------------------------------------------
 291:			; alternate printer port
 29k
 313:			; ---------------------------------------------------------------------
 314:			; MULTF-BOARD: MMU, IDE, SERIAL, CTC
 315:			; ---------------------------------------------------------------------
 316:			; -- I/O --
 317:	0020          	MMUPORT		EQU	20H
 318:	0021          	MENAPRT		EQU	21H
 319:			; -- Map --
 320:	00C0          	EEPAGE0		EQU	0C0H		; page 0 of eeprom
 321:	F000          	EEPSTA		EQU	0F000H		; eeprom location after MMU reset
 322:	00EF          	MMTPAPAG	EQU	(EEPSTA>>8)-1	; TPA t	0092          	READCFG8255	EQU	10010010b	;Set 8255 IDEportC to output, IDEportA/B input
 342:	0080          	WRITECFG8255	EQU	10000000b	;Set all three 8255 ports to output mode
 343:			;IDE control lines for use with IDEportC.
 344:	0001          	IDEA0LINE	EQU	01H		;direct from 8255 to IDE interface
 345:	0002          	IDEA1LINE	EQU	02H		;direct from 8255 to IDE interface
 346:	0004          	IDEA2LINE	EQU	04H		;direct from 8255 to IDE interface
 347:	0008          	IDECS0LINE	EQU	08H		;inverter between       	REGCONTROL	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
 363:	0016          	REGASTATUS	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
 364:			;IDE Command Constants.
 365:	0010          	CMDRECAL	EQU	010H
 366:	0020          	CMDREAD		EQU	020H
 367:	0030          	CMDWRITE	EQU	030H
 368:	0091          	CMDINIT		EQU	091H
 369:	00EC          	CMDID		EQU	0ECH
 370:	00E0          	CMDSPINDOWN	EQU	0E0H
 371:	00E1          	CMDSPINUP	EQU	0E1H
 372:			; -- 16C550 UARTS --
 373:	00C0          	UART0BASE	EQU	0C0H		; Port PR - Scratch Pad Register
 388:				; speeds:
 389:	0060          	UART1200	EQU	96		; = 1,843,200 / ( 16 x 1200 )
 390:	0030          	UART2400	EQU	48		; = 1,843,200 / ( 16 x 2400 )
 391:	0018          	UART4800	EQU	24		; = 1,843,200 / ( 16 x 4800 )
 392:	000C          	UART9600	EQU	12		; = 1,843,200 / ( 16 x 9600 )
 393:	0006          	UART19K2	EQU	06		; = 1,843,200 / ( 16 x 19,200 )
 394:	0003          	UART38K4	EQU	03		; = 1,843,200 / ( 16 x 38,400 )
 395:	0002          	UART57K6	EQU	02		; = 1,843,200 / (11:	00F4          	CTC1TC2HZ	EQU	244		; lo speed chan. 1 tc: 488.28 Hz / 244 = ~ 2 Hz
 412:	0013          	SYSHERTZ	EQU	CTC1TC25HZ	; System timer hertz
 413:			; -- EEPROM --
 414:	0001          	EEP29EE		EQU	01H		; type 29EE020
 415:	0002          	EEP29XE		EQU	02H		; type 29LE020 or 29VE020
 416:	0004          	EEP29C		EQU	04H		; type 29C020
 417:	0008          	EEPUNSUPP	EQU	08H		; unsupported
 418:	0010          	EEPROGLOCK	EQU	10H		; programming locked
 419:				;
 420:	0080          	EERINEPROM	EQU	80Hnstruction place:
 447:			; A on data lines D0-D7
 448:			; Fh (from B register) on A12-A15
 449:			; on port 20h (C register)
 450:			;
 451:			;
 452:			; Memory is organized as follow:
 453:			;
 454:			;	Slot 1	-> RAM	  -> 512k from 00000h to 7ffffh (mandatory)
 455:			;	Slot 2	-> RAM	  -> 128k from 80000h to 9ffffh (option 1)
 456:			;	Slot 2	-> RAM    -> 256k from 80000h to bffffh (option 2)
 457:			;	Slot 3	-> EEPROM -> 256k from c0000h to fffffh (mandatory)
 458:			;
 459:			
 460:			
 461:			;-----base address for 0
 374:	00C8          	UART1BASE	EQU	0C8H		; Port base address for 1
 375:	00C0          	UART0		EQU	UART0BASE	; Select UART 0
 376:	00C8          	UART1		EQU	UART1BASE	; Select UART 1
 377:	0000          	R0RXTX		EQU	0		; (r/w) RXD/TXD Transmit/Receive Buffer
 378:	0000          	R0BRDL		EQU	0		; (r/w) DLL  if bit 7 of LCR is set: Baud Rate Divisor LSB
 379:	0001          	R1IER		EQU	1		; (r/w) IER - Interrupt Enable Register
 380:	0001          	R1BRDM		EQU	1		; (r/w) DLM if bit 7 of LCR  16 x 57,600 )
 396:	0001          	UART115K2	EQU	01		; = 1,843,200 / ( 16 x 115,200 )
 397:			
 398:	0006          	U0DEFSPEED	EQU	UART19K2	; UART 0 default speed
 399:	000C          	U1DEFSPEED	EQU	UART9600	; UART 1 default speed
 400:			; -- Z80CTC --
 401:	00E8          	CTCBASE		EQU	0E8H
 402:	00E8          	CTCCHAN0	EQU	CTCBASE+0	; Channel 1 - Free
 403:	00E9          	CTCCHAN1	EQU	CTCBASE+1	; Channel 2 - System Timer
 404:	00EA          	CTCCHAN2	EQU	CTCBASE+2	; Channel 3 - UART 1 Interrupt
 405:	00E		; tried to program eeprom running inside it
 421:			
 422:			;
 423:			; MMU organization
 424:			;
 425:			; MMU manage 16 4kb pages in Z80 address space (logical)
 426:			; It can assign any of 256 4k pages (physical) from its
 427:			; 1Mb address space.
 428:			;
 429:			; To load phisycal page XXh to logical page (in CPU address space) Y,
 430:			; you should consider that MMU is at a fixed address 20h and that
 431:			; logical 4K page Y is derived in the MMU by the usage of A12,A13,A14
 432:			; an--------------------------------
 462:			; Production / Testing
 463:			
 464:	0000          	BBDEBUG	EQU	FALSE
 465:			
 466:			
 467:			;-------------------------------------
 468:			; Segments, pages locations
 469:			
 470:	0000          	IF	BBDEBUG
 476:			ELSE
 477:			
 478:	00C0          	BBIMGP	EQU	EEPAGE0		; Image location
 479:	000E          	BBAPPP	EQU	0EH
 480:	000F          	BBPAG	EQU	0FH		; Base page location
 481:			
 482:			ENDIF
 483:			
 484:	000D          	TRNPAG	EQU	0DH		; Page used for is set: Baud Rate Divisor MSB
 381:	0002          	R2IIR		EQU	2		; (r)   IIR - Interrupt Identification Register
 382:	0002          	R2FCR		EQU	2		; (w)   FCR - FIFO Control Register
 383:	0003          	R3LCR		EQU	3		; (r/w) LCR - Line Control Register
 384:	0004          	R4MCR		EQU	4		; (r/w) MCR - Modem Control Register
 385:	0005          	R5LSR		EQU	5		; (r)   LSR - Line Status Register
 386:	0006          	R6MSR		EQU	6		; (r)   MSR - Modem Status Register
 387:	0007          	R7SPR		EQU	7		; (r/w) SB          	CTCCHAN3	EQU	CTCBASE+3	; Channel 4 - UART 0 Interrupt
 406:	0020          	CTC0TCHI	EQU	32		; hi speed chan. 0 tc: 4Mhz / 256 / 32 = 488.28 Hz
 407:	0005          	CTC1TC100HZ	EQU	5		; lo speed chan. 1 tc: 488.28 Hz / 5 = ~ 97.6 Hz
 408:	000A          	CTC1TC50HZ	EQU	10		; lo speed chan. 1 tc: 488.28 Hz / 10 = ~ 48.8 Hz
 409:	0013          	CTC1TC25HZ	EQU	19		; lo speed chan. 1 tc: 488.28 Hz / 19 = ~ 25 Hz
 410:	0030          	CTC1TC10HZ	EQU	48		; lo speed chan. 1 tc: 488.28 Hz / 48 = ~ 10 Hz
 4d A15 address lines during an I/O instruction.
 433:			;
 434:			; So to address phys. ram page 00h at the top of logical space page Fh
 435:			; you need to have Fh * on top address lines * because this address
 436:			; is the index to MMU page.
 437:			;
 438:			; So:
 439:			;
 440:			; 	LD	A,00h		<--- phis. page number	00xxxh (4k page)
 441:			; 	LD	B,F0h		<--- log. page number 	 Fxxxh (cpu page)
 442:			; 	LD	C,20h		<--- MMU I/O address
 443:			; 	OUT	(C),A
 444:			; 	RET
 445:			;
 446:			; The OUT itransient MMU ops
 485:	F000          	BBBASE	EQU	BBPAG << 12	; non resident base address
 486:	FC00          	BBCOMN	EQU	BBBASE + 0C00H	; resident portion address
 487:			
 488:	F000          	SYSBASE EQU	BBBASE		; use this to have 60K TPA
 489:			; SYSBASE EQU	BBCOMN		; use this to have 63K TPA
 490:			
 491:			;-------------------------------------
**** sert.asm ****
   8:			
   9:	000A          	LF	EQU	0AH
  10:	000D          	CR	EQU	0DH
  11:	0008          	BS	EQU	08H		;Back space (required for sector 0118  CD9FFD  		CALL	BBCONOUT
  41:	011B  0C      		INC	C
  42:	011C  79      		LD	A,C
  43:	011D  FE7A    		CP	'z'
  44:	011F  20F1    		JR	NZ,TRASM
  45:	0121  0E40    		LD	C,'@'
  46:	0123  18ED    		JR	TRASM
  47:			
  48:			; RECE:	CALL	RXCHAR1
  49:			; 	CP	3
  50:			; 	JP	Z,0
  51:			; 	LD	C,A
  52:			; 	CALL	BBCONOUT
  53:			; 	JR	RECE
  54:			
  55:			
  56:			
  57:			;-------------------------------------------------------------------------------
  58:			
  59:	0125  496E6974	MSINIT		DB 'InitalisIDRV	EQU	FALSE			; set TRUE to enable ANSI console driver
  13:			
  14:			;------- UARTS Section ---------
  15:			
  16:			
  17:			WRUREG0	macro	uregister
  18:				LD	A,UART0
  19:				ADD	A,uregister
  20:				LD	C,A
  21:				OUT	(C),B
  22:				endm
  23:			
  24:			RDUREG0	macro	uregister
  25:				LD	A,UART0
  26:				ADD	A,uregister
  27:				LD	C,A
  28:				IN	A,(C)
  29:				endm
  30:			
  31:			WRUREG1	macro	uregister
  32:				LD	A,UART1
  33:				ADD	A,uregister
  34:				LD	C,A
  35:				OUT	(C),B
  36:6:			
  87:	0157          	INIUART1:
  88:	0157  3EC8    		LD	A,UART1
  89:	0159  32EA02  		LD	(SUART),A
  90:	015C  CD6001  		CALL	DOINIUART
  91:	015F  C9      		RET
  92:			
  93:	0160          	DOINIUART:
  94:	0160  C5      		PUSH	BC
  95:	0161  06AA    		LD	B,$AA
  96:	0163          		WRUREG	R7SPR
  97:	016B          		RDUREG	R7SPR
  98:	0173  FEAA    		CP	$AA			; test if you could store aa
  99:	0175  C2DD01  		JP	NZ,INIUNOK		; if not, the uart can't be found
 100:			
 101:	0178  0655    		LD	B,$55
 display)
  12:	0007          	BELL	EQU	07H
  13:	0009          	TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
  14:	001B          	ESC	EQU	1BH
  15:	001C          	CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
  16:							;on other video cards)
  17:	0001          	RDCON	EQU	1		;For CP/M I/O
  18:	0002          	WRCON	EQU	2
  19:	0009          	PRINT	EQU	9
  20:	000B          	CONST	EQU	11		;CONSOLE STAT
  21:	0005          	BDOS	EQU	5
  22:			
  23:	0000      ing UART...',CR,LF,'$'
	      616C6973
	      696E6720
	      55415254
	      2E2E2E0D
	      0A24
  60:	013B  4F6B2E0D	MSINITOK	DB 'Ok.',CR,LF,'$'
	      0A24
  61:	0141  4661696C	MSINITNOK	DB 'Failure',CR,LF,'$'
	      7572650D
	      0A24
  62:			;
  63:			;-------------------------------------------------------------------------------
  64:			
  65:	014B .. 014B 00	SER_ON:		DS	1	; serial on/off
  66:	014C .. 014C 00	UART_FAIL:	DS	1	; UART has failed detection flag
  67:	014D .. 014D 00	SER_BAUD:	DS	1	; 				endm
  37:			
  38:			RDUREG1	macro	uregister
  39:				LD	A,UART1
  40:				ADD	A,uregister
  41:				LD	C,A
  42:				IN	A,(C)
  43:				endm
  44:			
  45:			WRUREG	macro	uregister
  46:				LD	A,(SUART)
  47:				ADD	A,uregister
  48:				LD	C,A
  49:				OUT	(C),B
  50:				endm
  51:			
  52:			RDUREG	macro	uregister
  53:				LD	A,(SUART)
  54:				ADD	A,uregister
  55:				LD	C,A
  56:				IN	A,(C)
  57:				endm
  58:			
  59:			DESEQ	macro	p1,p2
  60:				LD	DE,[p1 << 8] + p2
  61:				endm
  62:			
  63:			; 102:	017A          		WRUREG	R7SPR
 103:	0182          		RDUREG	R7SPR
 104:	018A  FE55    		CP	$55			; or is defective
 105:	018C  C2DD01  		JP	NZ,INIUNOK
 106:			
 107:	018F  0680    		LD      B, $80
 108:	0191          		WRUREG	R3LCR			; enable baud rate divisor registers
 109:	0199  3AEA02  		LD	A,(SUART)		; initialize baud rate.
 110:	019C  FEC0    		CP	UART0			; which uart ?
 111:	019E  2006    		JR	NZ,INIU1
 112:	01A0  3A2B00  		LD	A,(UART0BR)		; uart 0
 113:	01A3  47      		LD	B,A
 114:	01A4  1804        	FALSE	EQU	0
  24:	FFFF          	TRUE	EQU	-1
  25:			
  26:	0000          	QUIT	EQU	0
  27:			
  28:	0100          		ORG	$100
  29:			
  30:	0100  3E06    		LD	A,U0DEFSPEED		; uart 0 init
  31:	0102  322B00  		LD	(UART0BR),A
  32:	0105  CD4E01  		CALL	INIUART0
  33:	0108  3E03    		LD	A,UART38K4		; uart 1 init
  34:	010A  322A00  		LD	(UART1BR),A
  35:	010D  CD5701  		CALL	INIUART1
  36:			
  37:	0110  0E40    		LD	C,'@'
  38:	0112  CDE101  	TRASM:	CALL	TXCHAR0
  39:	0115  CDFB01  		CALL	TXCHAR1
  40:	specify desired UART com rate in bps
  68:			
  69:				include uartctc.inc.asm
**** uartctc.inc.asm ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) Monitor
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; UARTS AND CTC management
   9:			; ---------------------------------------------------------------------
  10:			
  11:			
  12:	0000          	ANS	EXTERN	FSTAT, FOUT
  64:			
  65:			; ;;
  66:			; ;; Select UART for following operations
  67:			; ;;
  68:			; ;; A = Selected chip
  69:			; ;;
  70:			;
  71:			; SELUART:
  72:			; 	LD	(UARTSEL),A
  73:			; 	RET
  74:			
  75:			;;
  76:			;; Select UART for following operations
  77:			;;
  78:			;; A = Selected chip
  79:			;;
  80:			
  81:	014E          	INIUART0:
  82:	014E  3EC0    		LD	A,UART0
  83:	0150  32EA02  		LD	(SUART),A
  84:	0153  CD6001  		CALL	DOINIUART
  85:	0156  C9      		RET
  8		JR	INIU2
 115:	01A6  3A2A00  	INIU1:	LD	A,(UART1BR)		; uart 1
 116:	01A9  47      		LD	B,A
 117:	01AA          	INIU2:	WRUREG	R0BRDL			; write lsb divisor register
 118:	01B2  0600    		LD	B,$0
 119:	01B4          		WRUREG	R1BRDM			; write msb divisor register (alwyas 0 for us)
 120:			
 121:	01BC  0603    		LD	B,00000011B		; setup 8 bit, 1 stop, no parity
 122:								; 7 6 5 4 3 2 1 0
 123:								;             +------ 11 = 8 bit word length
 124:								;           +-------- 0 = 1 stop bit
 125:							601    		LD	B,00000001B	        ; 7 6 5 4 3 2 1 0
 146:								;               +---- 1 = enable data available interrupt (and 16550 Timeout)
 147:								;             +------ 0 = disable Transmit Holding Register empty (THRE) interrupt
 148:								;           +-------- 0 = disable Receiver lines status interrupt
 149:								;         +---------- 0 = disable modem-status-change interrupt
 150:								; +------------------ reserved (zero)
 151:	01D2          		WRUREG	R1IER
 152:	01DA  C1      		POP	BC
 153FE          	TXBUSY1:
 193:	01FE          		RDUREG1	R5LSR			; read status
 194:	0205  CB6F    		BIT	5,A			; ready to send?
 195:	0207  CAFE01  		JP	Z,TXBUSY1		; no, retry.
 196:	020A  F1      		POP	AF
 197:	020B  47      		LD	B,A
 198:	020C          		WRUREG1	R0RXTX
 199:	0213  C1      		POP	BC
 200:	0214  C9      		RET
 201:			
 202:			
 203:			
 204:			;;
 205:			;; Receive a char from serial line 1
 206:			;;
 207:			;; A: return input char
 208:			
 209:	0215          	RXCHAR1:
 210:	0215  C5      		PUSntil data is ready
 244:	0245          		RDUREG0	R0RXTX
 245:	024C  180F    		JR	RXCHE
 246:	024E          	RXCHAFIF:
 247:	024E  DD210F00		LD	IX,FIFOU0
 248:	0252          	RXCHAFLP:
 249:	0252  CDB5FD  		CALL	FSTAT			; queue status
 250:	0255  28FB    		JR	Z,RXCHAFLP		; loop until char is ready
 251:	0257  F3      		DI
 252:	0258  CDE1FD  		CALL	FOUT			; get a character from the queue
 253:	025B  FB      		EI
 254:	025C  79      		LD	A,C 			; and put it in correct register
 255:	025D  214C00  	RXCHE:	LD	H	;         +---------- 0 = no parity
 126:								;       +------------ 0 = odd parity (n/a)
 127:								;     +-------------- 0 = parity disabled (n/a)
 128:								;   +---------------- 0 = turn break off
 129:								; +------------------ 0 = disable divisor registers
 130:	01BE          		WRUREG	R3LCR
 131:	01C6  0607    		LD	B,00000111B		; 7 6 5 4 3 2 1 0
 132:								;               +---- 1 = enable FIFO and clear XMIT and RCVR FIFO queues
 133:								;             +------ 1 = clear RCVR FIFO
 134:	:	01DB  AF      		XOR	A			; init ok
 154:	01DC  C9      		RET
 155:	01DD  C1      	INIUNOK:POP	BC
 156:	01DE  3EFF    		LD	A,$FF
 157:	01E0  C9      		RET
 158:			
 159:			
 160:			;;
 161:			;; Sends a char over serial line 0
 162:			;;
 163:			;; C: output char
 164:			
 165:	FFFF          		IF NOT ANSIDRV
 166:	01E1          	TXCHAR0:
 167:				ELSE
 169:				ENDIF
 170:	01E1  79      		LD	A,C
 171:	01E2  C5      		PUSH	BC
 172:	01E3  F5      		PUSH	AF
 173:	01E4          	TXBUSY0:
 174:	01E4          		RDH	BC
 211:	0216          	RXBUSY1:
 212:	0216          		RDUREG1	R5LSR			; read status
 213:	021D  CB47    		BIT	0,A			; data available in rx buffer?
 214:	021F  28F5    		JR	Z,RXBUSY1		; loop until data is ready
 215:	0221          		RDUREG1	R0RXTX
 216:	0228  C1      		POP	BC
 217:	0229  C9      		RET
 218:			
 219:			;;
 220:			;; Receive a char from serial line 0
 221:			;;
 222:			;; A: return input char
 223:			
 224:	022A          	RXCHAR0:
 225:	022A  C5      		PUSH	BC
 226:	022B  DDE5    		PUSH	IX
L,MIOBYTE
 256:	0260  CB5E    		BIT	3,(HL)			; yes: transform to uppercase ?
 257:	0262  280C    		JR	Z,RXCHE1		; no
 258:	0264  FE61    		CP	'a'			; yes: is less then 'a' ?
 259:	0266  FA7002  		JP	M,RXCHE1		; yes: return, already ok
 260:	0269  FE7B    		CP	'{'			; no: then is greater than 'z' ?
 261:	026B  F27002  		JP	P,RXCHE1		; yes: do nothing
 262:	026E  CBAF    		RES	5,A			; no: convert uppercase...
 263:	0270          	RXCHE1:
 264:	FFFF          		IF 	NOT ANSIDRV
 265:	0270  E1      		POP	HL
 266:							;           +-------- 1 = clear XMIT FIFO
 135:								;         +---------- 0 = RXRDY & TXRDY pins mode 0
 136:								;        +-------------- reserved (zero)
 137:								; +------------------ trigger level for FIFO interrupt
 138:								;	Bits      RCVR FIFO
 139:								;	 76     Trigger Level
 140:								;	 00        1 byte         <-- actually
 141:								;	 01        4 bytes
 142:								;	 10        8 bytes
 143:								;	 11       14 bytes
 144:	01C8          		WRUREG	R2FCR
 145:	01D0  0UREG0	R5LSR			; read status
 175:	01EB  CB6F    		BIT	5,A			; ready to send?
 176:	01ED  CAE401  		JP	Z,TXBUSY0		; no, retry.
 177:	01F0  F1      		POP	AF
 178:	01F1  47      		LD	B,A
 179:	01F2          		WRUREG0	R0RXTX
 180:	01F9  C1      		POP	BC
 181:	01FA  C9      		RET
 182:			
 183:			;;
 184:			;; Sends a char over serial line 1
 185:			;;
 186:			;; C: output char
 187:			
 188:	01FB          	TXCHAR1:
 189:	01FB  79      		LD	A,C
 190:	01FC  C5      		PUSH	BC
 191:	01FD  F5      		PUSH	AF
 192:	01 227:	022D  D5      		PUSH	DE
 228:	022E  E5      		PUSH	HL
 229:	022F  DD214B00		LD	IX,TMPBYTE
 230:			
 231:	0000          		IF	ANSIDRV
 235:				ENDIF
 236:			
 237:	0233  DD7E00  	ESCNX:	LD	A,(IX)
 238:	0236  CB6F    		BIT	5,A			; test system interrupt status
 239:	0238  2014    		JR	NZ,RXCHAFIF		; enabled, uses queue
 240:	023A          	RXBUSY0:
 241:	023A          		RDUREG0	R5LSR			; read status
 242:	0241  CB47    		BIT	0,A			; data available in rx buffer?
 243:	0243  28F5    		JR	Z,RXBUSY0		; loop u	0271  D1      		POP	DE
 267:	0272  DDE1    		POP	IX
 268:	0274  C1      		POP	BC
 269:	0275  C9      		RET
 270:				ELSE
 412:				ENDIF
 413:			
 414:			
 415:			;;
 416:			;; Test UART status
 417:			;;
 418:			;; Returned flags:
 419:			;; RX status -> carry flag, TX status -> Z flag
 420:			;; C = 1: A character is available in the buffer.
 421:			;; Z = 1: A character can be sent.
 422:			
 423:			; USTATUS:
 424:			; 	PUSH	BC
 425:			; 	RDUREG	R5LSR			; read status
 426:			; 	RRCA                     	; check on the status of the queue
 456:	0295  DDE1    		POP	IX
 457:	0297  2002    		JR	NZ,USTAT0		; return if z-flag set
 458:	0299  AF      		XOR	A
 459:	029A  C9      		RET
 460:	029B  3EFF    	USTAT0:	LD	A,$FF
 461:	029D  C9      		RET
 462:			
 463:			;; Test UART 1 status
 464:			;;
 465:			;; Returned value:
 466:			;; A =  0: No character in queue
 467:			;; A = FF: A character is available
 468:			
 469:	029E          	USTATUS1:
 470:	029E  C5      		PUSH	BC
 471:	029F          		RDUREG1	R5LSR			----- 1 = channel reset
 925:								;           +-------- 1 = time constant follow
 926:								;         +---------- 0 = n/a in counter mode
 927:								;       +------------ 1 = rise edge clock
 928:								;     +-------------- 0 = n/a in counter mode
 929:								;   +---------------- 1 = select counter mode
 930:								; +------------------ 1 = enable interrupts
 931:	02B9  D3EB    		OUT	(CTCCHAN3),A
 932:	02BB  3E01    		LD	A,1			; time constant set to 1. At first interrupt request
 933:								; f54:								;             +------ 1 = channel reset
 955:								;           +-------- 1 = time constant follow
 956:								;         +---------- 0 = n/a in counter mode
 957:								;       +------------ 1 = rise edge clock
 958:								;     +-------------- 0 = n/a in counter mode
 959:								;   +---------------- 1 = select counter mode
 960:								; +------------------ 1 = enable interrupts
 961:	02C9  D3E9    		OUT	(CTCCHAN1),A
 962:	02CB  3A2800  		LD	A,(CTC1TC)		; time constant for system timer (fr       ; rotate RX status into carry
 427:			; 	BIT     4, A                    ; check TX status (after rot!)
 428:			; 	POP	BC
 429:			; 	RET
 430:			
 431:			;;
 432:			;; Test UART 0 status
 433:			;;
 434:			;; The code above is clearly better, BUT not suitable for BDOS
 435:			;; return codes...
 436:			;;
 437:			;; Returned value:
 438:			;; A =  0: No character in queue
 439:			;; A = FF: A character is available
 440:			
 441:	0276          	USTATUS0:
 442:	0276  3A4B00  		LD	A,(TMPBYTE)
 443:	027; read status
 472:	02A6  CB47    		BIT	0,A			; data available in rx buffer?
 473:	02A8  C1      		POP	BC
 474:	02A9  2002    		JR	NZ,USTAT1
 475:	02AB  AF      		XOR	A
 476:	02AC  C9      		RET
 477:	02AD  3EFF    	USTAT1:	LD	A,$FF
 478:	02AF  C9      		RET
 479:			
 480:			
 481:	0000          		IF ANSIDRV			; ANSI driver for serial console
 902:				ENDIF
 903:			
 904:			;------- CTC Section ---------
 905:			
 906:			; NOTE: system interrupts are not enabled here. Look at resident portion
 907:			;     orm the UART will route it to the CPU
 934:	02BD  D3EB    		OUT	(CTCCHAN3),A
 935:			
 936:				; Channel 2 - UART 1 interrupt handler
 937:	02BF  3ED7    		LD	A,11010111B		; 7 6 5 4 3 2 1 0
 938:								;               +---- 1 = command flag
 939:								;             +------ 1 = channel reset
 940:								;           +-------- 1 = time constant follow
 941:								;         +---------- 0 = n/a in counter mode
 942:								;       +------------ 1 = rise edge clock
 943:								;     +-------------- 0 = n/a om 100 to 2 Hz)
 963:	02CE  D3E9    		OUT	(CTCCHAN1),A
 964:			
 965:				; Channel 0 - hi speed timer/prescaler (feed channel 1)
 966:	02D0  3E27    		LD	A,00100111B		; 7 6 5 4 3 2 1 0
 967:								;               +---- 1 = command flag
 968:								;             +------ 1 = channel reset
 969:								;           +-------- 1 = time constant follow
 970:								;         +---------- 0 = start immediate
 971:								;       +------------ 0 = no trigger
 972:								;     +-------------- 1 = prescale 256
 973:9  CB6F    		BIT	5,A			; test system interrupt status
 444:	027B  200F    		JR	NZ,USTAFIF		; enabled, uses queue
 445:	027D  C5      		PUSH	BC
 446:	027E          		RDUREG0	R5LSR			; read status
 447:	0285  CB47    		BIT	0,A			; data available in rx buffer?
 448:	0287  C1      		POP	BC
 449:	0288  2011    		JR	NZ,USTAT0
 450:	028A  AF      		XOR	A
 451:	028B  C9      		RET
 452:	028C          	USTAFIF:
 453:	028C  DDE5    		PUSH	IX
 454:	028E  DD210F00		LD	IX,FIFOU0
 455:	0292  CDB5FD  	USTAF1:	CALL	FSTAT		  of the BIOS
 908:			
 909:			;;
 910:			;; initialize Z80CTC
 911:			;;
 912:			
 913:	02B0          	INICTC:
 914:				; First resets all four channels
 915:	02B0  CDDC02  		CALL	RESCTC
 916:			
 917:				; CTC interrupt vector
 918:	02B3  3EF0    		LD	A,$F0			; vec is at FFF0
 919:	02B5  D3E8    		OUT	(CTCCHAN0),A
 920:			
 921:				; Channel 3 - UART 0 interrupt handler
 922:	02B7  3ED7    		LD	A,11010111B		; 7 6 5 4 3 2 1 0
 923:								;               +---- 1 = command flag
 924:								;             +-in counter mode
 944:								;   +---------------- 1 = select counter mode
 945:								; +------------------ 1 = enable interrupts
 946:	02C1  D3EA    		OUT	(CTCCHAN2),A
 947:	02C3  3E01    		LD	A,1			; time constant set to 1. At first interrupt request
 948:								; form the UART will route it to the CPU
 949:	02C5  D3EA    		OUT	(CTCCHAN2),A
 950:			
 951:				; Channel 1 - lo speed system timer
 952:	02C7  3ED7    		LD	A,11010111B		; 7 6 5 4 3 2 1 0
 953:								;               +---- 1 = command flag
 9								;   +---------------- 0 = select timer mode
 974:								; +------------------ 0 = disable interrupts
 975:	02D2  D3E8    		OUT	(CTCCHAN0),A
 976:	02D4  3A2900  		LD	A,(CTC0TC)			; time constant set to 32. 4Mhz / 256 / 32 = 488.28Hz
 977:	02D7  D3E8    		OUT	(CTCCHAN0),A
 978:			
 979:	02D9  C9      		RET				; all done
 980:			
 981:			;;
 982:			;;
 983:			;;
 984:	02DA          	CTCUNLCK:
 985:	02DA  ED4D    		RETI
 986:			
 987:			;;
 988:			;; Resets CTC
 989:			;;
 990:	02DC          	RESCTC:
 alization string
  13:	02EB          	CRTTAB1:
  14:	02EB  6F505728		DB	$6F,$50,$57,$28,$1A,0,$19,$19,$48,$0B
	      1A001919
	      480B
  15:	02F5  000B0000		DB	0,$0B,0,0,0,0,0,0,0,0
	      00000000
	      0000
  16:			
  17:			;;
  18:			;; CRTCINI - init buffers,6545,test vram,clear,leave cursor at home
  19:			;;
  20:	02FF          	CRTCINI:
  21:	02FF  CD1503  		CALL	INICRT
  22:	0302  CD8B03  		CALL	DBLANK
  23:	0305  CDE906  		CALL	GIOINI			; init remaing hardware on the board
  24:	0308  3EFF    	 FE14    		CP	$14
  58:	0333  20F4    		JR	NZ,ICTLP0
  59:	0335  210000  		LD	HL,$0000
  60:	0338  224800  		LD	(CURPBUF),HL
  61:	033B  CD5A03  		CALL	SDPYSTA
  62:			; 	JP	CRSLOC
  63:			
  64:			;	fall through...
  65:			
  66:			;;
  67:			;; CRSLOC - init CRT cursor at CURPBUF
  68:			;
  69:	033E          	CRSLOC:
  70:	033E  2A4800  		LD	HL,(CURPBUF)
  71:	0341  CD6D03  		CALL	SCRSPOS
  72:	0344  AF      		XOR	A
  73:	0345  324F00  		LD	(COLBUF),A		; save cursor position
  74:	0348  C9      		RET
  73  		CALL	DISPCH
 112:			; 	JP	SCRSPOS
 113:			
 114:				; fall through...
 115:			;;
 116:			;; SET DISPLAY CURSOR ADDRESS EXTENDED
 117:			;;
 118:	036D          	SCRSPOS:
 119:	036D  3E0E    		LD	A,$0E
 120:	036F  D38C    		OUT	(CRT6545ADST),A
 121:	0371  7C      		LD	A,H
 122:	0372  D38D    		OUT	(CRT6545DATA),A
 123:	0374  3E0F    		LD	A,$0F
 124:	0376  D38C    		OUT	(CRT6545ADST),A
 125:	0378  7D      		LD	A,L
 126:	0379  D38D    		OUT	(CRT6545DATA),A
 127:	037B          	SCRSPOS1:
 128:	037B  3E12   991:	02DC  CDDA02  		CALL	CTCUNLCK
 992:	02DF  3E03    		LD	A,00000011B		; 7 6 5 4 3 2 1 0
 993:								;               +---- 1 = command flag
 994:								;             +------ 1 = channel reset
 995:								; +------------------ 0 = n/a
 996:	02E1  D3E8    		OUT	(CTCCHAN0),A
 997:	02E3  D3E9    		OUT	(CTCCHAN1),A
 998:	02E5  D3EA    		OUT	(CTCCHAN2),A
 999:	02E7  D3EB    		OUT	(CTCCHAN3),A
1000:	02E9  C9      		RET
1001:			; -----------
1002:			
1003:	02EA  00      	SUART:	DEFB	0
1004:			
1005:			; ------	LD	A,$FF
  25:	030A  323E00  		LD	(RAM3BUF),A
  26:	030D  210000  		LD	HL,$0000
  27:	0310  224800  		LD	(CURPBUF),HL
  28:	0313  1829    		JR	CRSLOC
  29:			
  30:			;;
  31:			;; INICRT
  32:			;
  33:	0315          	INICRT:
  34:								; initialize PIOs
  35:	0315  3E8F    		LD	A,$8F			; 10-00-1111 mode ctrl word
  36:								; Mode 2 (I/O port A)
  37:	0317  D382    		OUT	(CRTRAM0CNT),A
  38:	0319  D386    		OUT	(CRTRAM1CNT),A
  39:	031B  D38A    		OUT	(CRTRAM2CNT),A
  40:	031D  CD2303  		CALL	INI65455:			
  76:			
  77:			;;
  78:			;; GET DISPLAY CURSOR POSITION and return in HL
  79:			;
  80:	0349          	GCRSPOS:
  81:	0349  3E0E    		LD	A,$0E
  82:	034B  D38C    		OUT	(CRT6545ADST),A
  83:	034D  DB8D    		IN	A,(CRT6545DATA)
  84:	034F  67      		LD	H,A
  85:	0350  3E0F    		LD	A,$0F
  86:	0352  D38C    		OUT	(CRT6545ADST),A
  87:	0354  DB8D    		IN	A,(CRT6545DATA)
  88:	0356  6F      		LD	L,A
  89:	0357  23      		INC	HL
  90:	0358  1862    		JR	CRTPRGEND
  91:			
  92:			;;
  93:			;; SET DISPL 		LD	A,$12
 129:	037D  D38C    		OUT	(CRT6545ADST),A
 130:	037F  7C      		LD	A,H
 131:	0380  D38D    		OUT	(CRT6545DATA),A
 132:	0382  3E13    		LD	A,$13
 133:	0384  D38C    		OUT	(CRT6545ADST),A
 134:	0386  7D      		LD	A,L
 135:	0387  D38D    		OUT	(CRT6545DATA),A
 136:	0389  1831    		JR	CRTPRGEND
 137:			
 138:			;;
 139:			;; DBLANK
 140:			;; fill video ram (2k) with 0's
 141:			;
 142:	038B          	DBLANK:
 143:	038B  210000  		LD	HL,$0000
 144:	038E  223B00  		LD	(RAM0BUF),HL
 145:	0391  AF     -----
**** sert.asm ****
  70:				include crtc.inc.asm
**** crtc.inc.asm ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) Monitor
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; CRTC
   9:			; SY6545A-1 and PIOs for video ram access on LX529
  10:			; ---------------------------------------------------------------------
  11:			
  12:			;; 6545 initi			; init 6545
  41:	0320  C3BC03  		JP	CRTPRGEND		; go on...
  42:			
  43:			
  44:			;;
  45:			;; INI6545 - initialize sy6545
  46:			;;
  47:	0323          	INI6545:
  48:	0323  21EB02  		LD	HL,CRTTAB1	; now read from eprom
  49:	0326  0600    		LD	B,$00
  50:	0328  78      		LD	A,B
  51:	0329  D38C    	ICTLP0:	OUT    (CRT6545ADST),A
  52:	032B  7E      		LD	A,(HL)
  53:	032C  D38D    		OUT	(CRT6545DATA),A
  54:	032E  23      		INC	HL
  55:	032F  04      		INC	B
  56:	0330  78      		LD	A,B
  57:	0331 AY START ADDRESS
  94:			;
  95:	035A          	SDPYSTA:
  96:	035A  3E0C    		LD	A,$0C
  97:	035C  D38C    		OUT	(CRT6545ADST),A
  98:	035E  7C      		LD	A,H
  99:	035F  D38D    		OUT	(CRT6545DATA),A
 100:	0361  3E0D    		LD	A,$0D
 101:	0363  D38C    		OUT	(CRT6545ADST),A
 102:	0365  7D      		LD	A,L
 103:	0366  D38D    		OUT	(CRT6545DATA),A
 104:	0368  1852    		JR	CRTPRGEND
 105:			
 106:			
 107:			;;
 108:			;; DISMVC display char and move cursor
 109:			;
 110:	036A          	DISMVC:
 111:	036A  CDDE0 		XOR	A
 146:	0392  323D00  		LD	(RAM2BUF),A
 147:			;;
 148:			;; CRTFILL - Fill video ram with ram buffer chrs
 149:			;
 150:	0395          	CRTFILL:
 151:	0395  3EEF    		LD	A,$EF
 152:	0397  323E00  		LD	(RAM3BUF),A
 153:	039A  210000  		LD	HL,$0000
 154:	039D  224800  		LD	(CURPBUF),HL
 155:	03A0  CDB003  		CALL	RSTDPY
 156:	03A3  E5      	CFIL1:	PUSH	HL
 157:	03A4  CDC103  		CALL	DISPGR
 158:	03A7  E1      		POP	HL
 159:	03A8  23      		INC	HL
 160:	03A9  7C      		LD	A,H
 161:	03AA  FE08    		CP	$0 		OUT	(CRTRAM0DAT),A
 199:	03CD  23      		INC	HL
 200:	03CE  7E      		LD	A,(HL)
 201:	03CF  D384    		OUT	(CRTRAM1DAT),A
 202:	03D1  23      		INC	HL
 203:	03D2  7E      		LD	A,(HL)
 204:	03D3  D388    		OUT	(CRTRAM2DAT),A
 205:	03D5  3A3E00  		LD	A,(RAM3BUF)
 206:	03D8  D38E    		OUT	(CRTRAM3PORT),A
 207:	03DA  AF      		XOR	A
 208:	03DB  D38D    		OUT	(CRT6545DATA),A
 209:	03DD  C9      		RET
 210:			
 211:			;;
 212:			;; DISPCH - Display in text mode (raw output)
 213:			;;
 214:	03DE          	DISPC3FF  EB      		EX	DE,HL
 247:	0400  2035    		JR	NZ,CONOU2		; yes: do alternate
 248:	0402  FE20    		CP	$20			; no: is less then 0x20 (space) ?
 249:	0404  300D    		JR	NC,COJP1		; no: go further
 250:	0406  87      		ADD	A,A			; yes: is a special char
 251:	0407  2600    		LD	H,0
 252:	0409  6F      		LD	L,A
 253:	040A  016906  		LD	BC,IOCVEC
 254:	040D  09      		ADD	HL,BC
 255:	040E  7E      		LD	A,(HL)
 256:	040F  23      		INC	HL
 257:	0410  66      		LD	H,(HL)
 258:	0411  6F      		LD	L,A
 259:	0412 7      		ADD	A,A			; yes
 285:	043C  2600    		LD	H,0
 286:	043E  6F      		LD	L,A
 287:	043F  01A906  		LD	BC,IOCVEC2
 288:	0442  09      		ADD	HL,BC
 289:	0443  7E      		LD	A,(HL)
 290:	0444  23      		INC	HL
 291:	0445  66      		LD	H,(HL)
 292:	0446  6F      		LD	L,A
 293:	0447  E9      		JP	(HL)			; jump to service routine... (IOCVEC2)
 294:			;; cursor addressing service routine
 295:			;; address is ESC + (COL # + 32) + (ROW # + 32) (then need a NUL to terminate...)
 296:	0448  214B00  	CURADR:	LD	H8
 162:	03AC  20F5    		JR	NZ,CFIL1
 163:	03AE  1800    		JR	RSTDPY
 164:			
 165:			;;
 166:			;; RSTDPY - zeroes SY6545 higher register (R12 to R19)
 167:			;;
 168:	03B0          	RSTDPY:
 169:	03B0  0608    		LD	B,$08
 170:	03B2  78      	RDPY1:	LD	A,B
 171:	03B3  C60B    		ADD	A,$0B
 172:	03B5  D38C    		OUT	(CRT6545ADST),A
 173:	03B7  AF      		XOR	A
 174:	03B8  D38D    		OUT	(CRT6545DATA),A
 175:	03BA  10F6    		DJNZ	RDPY1
 176:			; 	JP	CRTPRGEND
 177:			
 178:				; fall through...
 179:			
 180:			;H:
 215:	03DE  F5      		PUSH	AF
 216:	03DF  DB8C    	DGCLP0:	IN	A,(CRT6545ADST)
 217:	03E1  CB7F    		BIT	7,A
 218:	03E3  28FA    		JR	Z,DGCLP0
 219:	03E5  F1      		POP	AF
 220:	03E6  D380    		OUT	(CRTRAM0DAT),A
 221:	03E8  3A3E00  		LD	A,(RAM3BUF)
 222:	03EB  D38E    		OUT	(CRTRAM3PORT),A
 223:	03ED  AF      		XOR	A
 224:	03EE  D38D    		OUT	(CRT6545DATA),A
 225:	03F0  C9      		RET
 226:			
 227:			
 228:			;;
 229:			;; BCONOUT print out the char in reg C
 230:			;; with full evaluation of control cha E9      		JP	(HL)			; jump to IOCVEC handler
 260:	0413  EB      	COJP1:	EX	DE,HL
 261:	0414  CB76    		BIT	6,(HL)			; auto ctrl chars ??
 262:	0416  280A    		JR	Z,COJP2			; no
 263:	0418  FE40    		CP	$40			; yes: convert
 264:	041A  3806    		JR	C,COJP2
 265:	041C  FE60    		CP	$60
 266:	041E  3002    		JR	NC,COJP2
 267:	0420  D640    		SUB	$40
 268:	0422  CDDE03  	COJP2:	CALL	DISPCH			; display char
 269:				; move cursor right
 270:	0425          	MOVRGT:
 271:	0425  CD4903  		CALL	GCRSPOS			; update L,TMPBYTE
 297:	044B  CB46    		BIT	0,(HL)
 298:	044D  200B    		JR	NZ,SETROW
 299:	044F  FE70    		CP	$70			; greater then 80 ?
 300:	0451  D0      		RET	NC			; yes: error
 301:	0452  D620    		SUB	$20			; no: ok
 302:	0454  322D00  		LD	(APPBUF),A		; store column
 303:	0457  CBC6    		SET	0,(HL)			; switch row/col flag
 304:	0459  C9      		RET
 305:	045A  FE39    	SETROW:	CP	$39			; greater than 24 ?
 306:	045C  D0      		RET	NC			; yes: error
 307:	045D  D61F    		SUB	$1F			; no: ok
 308:	045F  CB86    ;
 181:			;; CRTPRGEND
 182:			;; resets 6545 register pointer
 183:			;
 184:	03BC          	CRTPRGEND:
 185:	03BC  3E1F    		LD	A,$1F
 186:	03BE  D38C    		OUT	(CRT6545ADST),A
 187:	03C0  C9      		RET
 188:			
 189:			;;
 190:			;; DISPGR - display in graphic mode (raw output)
 191:			;
 192:	03C1          	DISPGR:
 193:	03C1  DB8C    		IN	A,(CRT6545ADST)
 194:	03C3  CB7F    		BIT	7,A
 195:	03C5  28FA    		JR	Z,DISPGR
 196:	03C7  213B00  		LD	HL,RAM0BUF
 197:	03CA  7E      		LD	A,(HL)
 198:	03CB  D380   rs
 231:			;;
 232:			;; register clean: can be used as CP/M BIOS replacement
 233:			;;
 234:	03F1          	BCONOUT:
 235:	03F1  F5      		PUSH	AF
 236:	03F2  C5      		PUSH	BC
 237:	03F3  D5      		PUSH	DE
 238:	03F4  E5      		PUSH	HL
 239:				; force jump to register restore and exit in stack
 240:	03F5  218004  		LD	HL,BCEXIT
 241:	03F8  E5      		PUSH	HL
 242:				;
 243:	03F9  79      		LD	A,C
 244:	03FA  214C00  		LD	HL,MIOBYTE
 245:	03FD  CB7E    		BIT	7,(HL)			; alternate char processing ?
 246:	0cursor position
 272:	0428  CD6D03  		CALL	SCRSPOS
 273:	042B  3A4F00  		LD	A,(COLBUF)
 274:	042E  3C      		INC	A
 275:	042F  FE50    		CP	$50
 276:	0431  2852    		JR	Z,LFEED			; go down if needed
 277:			;;
 278:	0433          	SAVCOLB:
 279:	0433  324F00  		LD	(COLBUF),A		; save cursor position
 280:	0436  C9      		RET
 281:	0437          	CONOU2:					; alternate processing....
 282:	0437  FE20    		CP	$20			; is a ctrl char ??
 283:	0439  300D    		JR	NC,CURADR		; no: will set cursor pos
 284:	043B  8		RES	0,(HL)			; resets flags
 309:	0461  214C00  		LD	HL,MIOBYTE
 310:	0464  CBBE    		RES	7,(HL)			; done reset
 311:	0466  47      		LD	B,A
 312:	0467  21B0FF  		LD	HL,$FFB0
 313:	046A  115000  		LD	DE,$0050
 314:	046D  19      	CUROFS:	ADD	HL,DE			; calc. new offset
 315:	046E  10FD    		DJNZ	CUROFS
 316:	0470  3A2D00  		LD	A,(APPBUF)
 317:	0473  324F00  		LD	(COLBUF),A
 318:	0476  5F      		LD	E,A
 319:	0477  19      		ADD	HL,DE
 320:	0478  EB      		EX	DE,HL
 321:	0479  2A4800  		LD	HL,(CURPBUF)
 322: 354:	04B0  E1      		POP	HL
 355:	04B1  3802    		JR	C,MDJMP1
 356:	04B3  CB9C    		RES	3,H
 357:	04B5  224800  	MDJMP1:	LD	(CURPBUF),HL
 358:	04B8  CD5A03  		CALL	SDPYSTA
 359:	04BB  E1      		POP	HL
 360:	04BC  3802    		JR	C,MEJP
 361:	04BE  CB9C    		RES	3,H
 362:	04C0  C36D03  	MEJP:	JP	SCRSPOS
 363:			
 364:			;;
 365:			;; SCRTST - Verify if we need video scroll
 366:			;
 367:	04C3          	SCRTST:
 368:	04C3  ED5B4800		LD	DE,(CURPBUF)
 369:	04C7  AF      		XOR	A
 370:	04C8  ED52    		SBC	HL,DE
 3           ; (0 10 01010) 1/16 blink scan 10
 404:	04FC  1812    		JR	CURSETMODE
 405:	04FE          	CURBFB:
 406:	04FE  2E60    		LD	L,$60           ; (0 11 00000) 1/32 blink scan 0
 407:	0500  180E    		JR	CURSETMODE
 408:	0502          	CURBFL:
 409:	0502  2E6A    		LD	L,$6A           ; (0 11 01010) 1/32 blink scan 10
 410:	0504  180A    		JR	CURSETMODE
 411:	0506          	SCUROF:
 412:	0506  2E20    		LD	L,$20           ; (0 01 00000) cursor off
 413:	0508  1806    		JR	CURSETMODE
 414:	050A          (non-escaped) mode
 446:			;
 447:	0524          	UCASEMOD:
 448:	0524  EB      		EX	DE,HL
 449:	0525  CBDE    		SET	3,(HL)
 450:	0527  C9      		RET
 451:	0528          	LCASEMOD:
 452:	0528  EB      		EX	DE,HL
 453:	0529  CB9E    		RES	3,(HL)
 454:	052B  C9      		RET
 455:			;;
 456:			;; SNDBEEP - sound beep
 457:	052C          	SNDBEEP:
 458:	052C  D38F    		OUT	(CRTBEEPPORT),A
 459:	052E  C9      		RET
 460:			
 461:			
 462:			;;
 463:			;; cursor left, non destructive only
 464:			;;
 465:	052F     	047C  19      		ADD	HL,DE
 323:	047D  C36D03  		JP	SCRSPOS			; update position
 324:	0480          	BCEXIT:
 325:	0480  E1      		POP	HL
 326:	0481  D1      		POP	DE
 327:	0482  C1      		POP	BC
 328:	0483  F1      		POP	AF
 329:	0484  C9      		RET
 330:			;;
 331:			;; LFEED: down one line, scroll, home, clreol
 332:			;
 333:	0485          	LFEED:
 334:	0485  AF      		XOR	A
 335:	0486  324F00  		LD	(COLBUF),A
 336:	0489  CDC304  	LFEED1:	CALL	SCRTST
 337:	048C  D8      		RET	C
 338:	048D  214C00  		LD	71:	04CA  7C      		LD	A,H
 372:	04CB  FE07    		CP	$07
 373:	04CD  D8      		RET	C
 374:	04CE  7D      		LD	A,L
 375:	04CF  FECF    		CP	$CF
 376:	04D1  C9      		RET
 377:			;;
 378:			;; CLRSCR - clear screen (ASCII mode)
 379:			;
 380:	04D2          	CLRSCR:
 381:	04D2  210000  		LD	HL,$0000
 382:	04D5  AF      		XOR	A
 383:	04D6  324F00  		LD	(COLBUF),A
 384:	04D9  2F      		CPL
 385:	04DA  323E00  		LD	(RAM3BUF),A
 386:	04DD  224800  		LD	(CURPBUF),HL
 387:	04E0  CD6D03  		CALL	SCRSPOS
 388:	04E3  CD	CURFXB:
 415:	050A  2E00    		LD	L,$00           ; (0 00 00000) fixed scan 0
 416:	050C  1802    		JR	CURSETMODE
 417:	050E          	SCURON:
 418:			; 	LD	L,$0A           ; (0 00 01010) cursor on
 419:	050E  1803    		JR	CURSET
 420:	0510          	CURSETMODE:
 421:	0510  E5      		PUSH	HL
 422:	0511  1805    		JR	CURSET1
 423:			
 424:			;;
 425:			;; Setup cursor. (user mode)
 426:			;;
 427:	0513          	CURSET:
 428:	0513  E5      		PUSH	HL
 429:	0514  3A4A00  		LD	A,(CURSSHP)
 430:	0517  6F      		     	MOVLFTND:
 466:	052F  214C00  		LD	HL,MIOBYTE
 467:	0532  7E      		LD	A,(HL)
 468:	0533  F5      		PUSH	AF
 469:	0534  CBE6    		SET	4,(HL)
 470:	0536  CD3C05  		CALL	MOVLFT
 471:	0539  F1      		POP	AF
 472:	053A  77      		LD	(HL),A
 473:	053B  C9      		RET
 474:			
 475:			;;
 476:			;; cursor left
 477:			;;
 478:	053C          	MOVLFT:
 479:	053C  CD4903  		CALL	GCRSPOS
 480:	053F  2B      		DEC	HL
 481:	0540  ED5B4800		LD	DE,(CURPBUF)
 482:	0544  AF      		XOR	A
 483:	0545  ED52    		SBC	HL,DEHL,MIOBYTE
 339:	0490  CB56    		BIT	2,(HL)
 340:	0492  1130F8  		LD	DE,$F830
 341:	0495  CD4903  		CALL	GCRSPOS
 342:	0498  2B      		DEC	HL
 343:	0499  2804    		JR	Z,MDJMP0
 344:	049B  19      		ADD	HL,DE
 345:	049C  C36D03  		JP	SCRSPOS
 346:	049F  E5      	MDJMP0:	PUSH	HL
 347:	04A0  CD4E06  		CALL	CLRLIN
 348:	04A3  2A4800  		LD	HL,(CURPBUF)
 349:	04A6  115000  		LD	DE,$0050
 350:	04A9  19      		ADD	HL,DE
 351:	04AA  112008  		LD	DE,$0820
 352:	04AD  E5      		PUSH	HL
 353:	04AE  ED52    		SBC	HL,DE
5A03  		CALL	SDPYSTA
 389:	04E6  E5      		PUSH	HL
 390:	04E7  3E20    	CLSNC:	LD	A,$20
 391:	04E9  CDDE03  		CALL	DISPCH
 392:	04EC  23      		INC	HL
 393:	04ED  7C      		LD	A,H
 394:	04EE  FE08    		CP	$08
 395:	04F0  20F5    		JR	NZ,CLSNC
 396:	04F2  E1      		POP	HL
 397:	04F3  C36D03  		JP	SCRSPOS
 398:			
 399:	04F6          	CURBLB:
 400:	04F6  2E40    		LD	L,$40           ; (0 10 00000) 1/16 blink scan 0
 401:	04F8  1816    		JR	CURSETMODE
 402:	04FA          	CURBLL:
 403:	04FA  2E4A    		LD	L,$4ALD	L,A
 431:	0518          	CURSET1:
 432:	0518  3E0A    		LD	A,$0A
 433:	051A  D38C    		OUT	(CRT6545ADST),A
 434:	051C  7D      		LD	A,L
 435:	051D  D38D    		OUT	(CRT6545DATA),A
 436:	051F  E1      		POP	HL
 437:	0520  C3BC03  		JP	CRTPRGEND
 438:			
 439:			;;
 440:			;; IOCNULL (a void routine) from here a list of routines to handle
 441:			;; console char output
 442:			;
 443:	0523          	IOCNULL:
 444:	0523  C9      		RET			; null entry. start of control routines vector
 445:							; for primary 
 484:	0547  BC      		CP	H
 485:	0548  2002    		JR	NZ,MOVLFT1
 486:	054A  BD      		CP	L
 487:	054B  C8      		RET	Z
 488:	054C          	MOVLFT1:
 489:	054C  2B      		DEC	HL
 490:	054D  19      		ADD	HL,DE
 491:	054E  CD6D03  		CALL	SCRSPOS
 492:	0551  E5      		PUSH	HL
 493:	0552  3A4F00  		LD	A,(COLBUF)
 494:	0555  3D      		DEC	A
 495:	0556  FEFF    		CP	$FF
 496:	0558  2002    		JR	NZ,MOVLFT2
 497:	055A  3E4F    		LD	A,$4F
 498:	055C          	MOVLFT2:
 499:	055C  324F00  		LD	(COLBUF),A
 500:	055F A
 536:	0587  2A4800  		LD	HL,(CURPBUF)
 537:	058A  11D007  		LD	DE,$07D0
 538:	058D  19      		ADD	HL,DE
 539:	058E  EB      		EX	DE,HL
 540:	058F  CD4903  		CALL	GCRSPOS
 541:	0592  2B      		DEC	HL
 542:	0593  EB      		EX	DE,HL
 543:	0594  ED52    		SBC	HL,DE
 544:	0596  E5      		PUSH	HL
 545:	0597  C1      		POP	BC
 546:	0598  CD5106  	CLRJ0:	CALL	CLRLIN1
 547:	059B  EB      		EX	DE,HL
 548:	059C  C36D03  		JP	SCRSPOS
 549:			;;
 550:			;; CLREOL - clear to end of line
 551:			;
 552:	059F          	Crocessing (ESC prefixed ctrl chars)
 587:			;
 588:	05C2          	MOVUP:
 589:	05C2  CD4903  		CALL	GCRSPOS
 590:	05C5  11AFFF  		LD	DE,$FFAF
 591:	05C8  19      		ADD	HL,DE
 592:	05C9  EB      		EX	DE,HL
 593:	05CA  2A4800  		LD	HL,(CURPBUF)
 594:	05CD  EB      		EX	DE,HL
 595:	05CE  AF      		XOR	A
 596:	05CF  ED52    		SBC	HL,DE
 597:	05D1  2F      		CPL
 598:	05D2  BC      		CP	H
 599:	05D3  19      		ADD	HL,DE
 600:	05D4  C8      		RET	Z
 601:	05D5  C36D03  		JP	SCRSPOS
 602:	05D8          	RASCFLTR:
	0605  CBF6    		SET	6,(HL)
 637:	0607  C9      		RET
 638:	0608          	BLUEON:
 639:	0608  213E00  		LD	HL,RAM3BUF
 640:	060B  CBFE    		SET	7,(HL)
 641:	060D  C9      		RET
 642:	060E          	BLINKON:
 643:	060E  213E00  		LD	HL,RAM3BUF
 644:	0611  CB86    		RES	0,(HL)
 645:	0613  C9      		RET
 646:	0614          	REVON:
 647:	0614  213E00  		LD	HL,RAM3BUF
 648:	0617  CB8E    		RES	1,(HL)
 649:	0619  C9      		RET
 650:	061A          	UNDERON:
 651:	061A  213E00  		LD	HL,RAM3BUF
 652:	061D  CB96     214C00  		LD	HL,MIOBYTE
 501:	0562  CB66    		BIT	4,(HL)
 502:	0564  E1      		POP	HL
 503:	0565  C0      		RET	NZ
 504:	0566  3E20    		LD	A,$20
 505:	0568  C36A03  		JP	DISMVC
 506:			; 	JP	DISPCH
 507:			;;
 508:			;; CHOME - move cursor at col 0
 509:			;
 510:	056B          	CHOME:
 511:	056B  214F00  		LD	HL,COLBUF
 512:	056E  5E      		LD	E,(HL)
 513:	056F  AF      		XOR	A
 514:	0570  77      		LD	(HL),A
 515:	0571  57      		LD	D,A
 516:	0572  CD4903  		CALL	GCRSPOS
 517:	0575  2B      		DEC	HL
 51LREOL:
 553:	059F  3A4F00  		LD	A,(COLBUF)
 554:	05A2  47      		LD	B,A
 555:	05A3  3E50    		LD	A,$50
 556:	05A5  90      		SUB	B
 557:	05A6  0600    		LD	B,$00
 558:	05A8  4F      		LD	C,A
 559:	05A9  CD4903  		CALL	GCRSPOS
 560:	05AC  2B      		DEC	HL
 561:	05AD  EB      		EX	DE,HL
 562:	05AE  18E8    		JR	CLRJ0
 563:			;;
 564:	05B0          	SCROLLOFF:
 565:	05B0  EB      		EX	DE,HL
 566:	05B1  CBD6    		SET	2,(HL)
 567:	05B3  C9      		RET
 568:	05B4          	SCROLLON:
 569:	05B4  EB      		EX	DE,HL
 603:	05D8  EB      		EX	DE,HL
 604:	05D9  CBB6    		RES	6,(HL)
 605:	05DB  C9      		RET
 606:	05DC          	NDBKSP:
 607:	05DC  EB      		EX	DE,HL
 608:	05DD  CBE6    		SET	4,(HL)
 609:	05DF  C9      		RET
 610:	05E0          	DBKSP:
 611:	05E0  EB      		EX	DE,HL
 612:	05E1  CBA6    		RES	4,(HL)
 613:	05E3  C9      		RET
 614:	05E4          	BLINKOFF:
 615:	05E4  213E00  		LD	HL,RAM3BUF
 616:	05E7  CBC6    		SET	0,(HL)
 617:	05E9  C9      		RET
 618:	05EA          	REVOFF:
 619:	05EA  213E00  		LD	HL,RA		RES	2,(HL)
 653:	061F  C9      		RET
 654:	0620          	HLIGHTON:
 655:	0620  213E00  		LD	HL,RAM3BUF
 656:	0623  CB9E    		RES	3,(HL)
 657:	0625  C9      		RET
 658:	0626          	REDOFF:
 659:	0626  213E00  		LD	HL,RAM3BUF
 660:	0629  CBAE    		RES	5,(HL)
 661:	062B  C9      		RET
 662:	062C          	GREENOFF:
 663:	062C  213E00  		LD	HL,RAM3BUF
 664:	062F  CBB6    		RES	6,(HL)
 665:	0631  C9      		RET
 666:	0632          	BLUEOFF:
 667:	0632  213E00  		LD	HL,RAM3BUF
 668:	0635  CBBE    		RES	7,(HL8:	0576  ED52    		SBC	HL,DE
 519:	0578  CD6D03  		CALL	SCRSPOS
 520:	057B  C9      		RET
 521:			
 522:			;; IOCCR - handle carriage return (0x0d)
 523:			;; should position the cursor at col 0
 524:			;
 525:	057C          	IOCCR:
 526:	057C  EB      		EX	DE,HL
 527:	057D  CB5E    		BIT	3,(HL)
 528:	057F  2803    		JR	Z,IOCCR1
 529:	0581  CD9F05  		CALL	CLREOL
 530:	0584  18E5    	IOCCR1:	JR	CHOME
 531:			;;
 532:			;; clear to end of page
 533:			;;
 534:	0586          	CLREOP:
 535:	0586  AF      		XOR	 570:	05B5  CB96    		RES	2,(HL)
 571:	05B7  C9      		RET
 572:	05B8          	SIOCESC:
 573:	05B8  EB      		EX	DE,HL
 574:	05B9  CBFE    		SET	7,(HL)
 575:	05BB  C9      		RET
 576:			;;
 577:			;; RESATTR - reset all attributes
 578:			;
 579:	05BC          	RESATTR:
 580:	05BC  3EFF    		LD	A,$FF
 581:	05BE  323E00  		LD	(RAM3BUF),A
 582:	05C1  C9      		RET
 583:			
 584:			;;
 585:			;; IOCNULL (a void routine) from here a list of routines to handle
 586:			;; console char output while in alternate pM3BUF
 620:	05ED  CBCE    		SET	1,(HL)
 621:	05EF  C9      		RET
 622:	05F0          	UNDEROFF:
 623:	05F0  213E00  		LD	HL,RAM3BUF
 624:	05F3  CBD6    		SET	2,(HL)
 625:	05F5  C9      		RET
 626:	05F6          	HLIGHTOFF:
 627:	05F6  213E00  		LD	HL,RAM3BUF
 628:	05F9  CBDE    		SET	3,(HL)
 629:	05FB  C9      		RET
 630:	05FC          	REDON:
 631:	05FC  213E00  		LD	HL,RAM3BUF
 632:	05FF  CBEE    		SET	5,(HL)
 633:	0601  C9      		RET
 634:	0602          	GREENON:
 635:	0602  213E00  		LD	HL,RAM3BUF
 636:)
 669:	0637  C9      		RET
 670:			;;
 671:			;; MOVDWN - cursor down one line
 672:			;
 673:	0638          	MOVDWN:
 674:	0638  CD4903  		CALL	GCRSPOS
 675:	063B  2B      		DEC	HL
 676:	063C  115000  		LD	DE,$0050
 677:	063F  19      		ADD	HL,DE
 678:	0640  CD6D03  		CALL	SCRSPOS
 679:	0643  C38904  		JP	LFEED1
 680:			;;
 681:	0646          	RIOCESC:
 682:	0646  EB      		EX	DE,HL
 683:	0647  CBBE    		RES	7,(HL)
 684:	0649  C9      		RET
 685:			;
 686:	064A          	SASCFLTR:
 687:	064A  EB      		EXde
 718:	066F  2305    		DW	IOCNULL			; ETX 0x00 (^C)  no-op
 719:	0671  0605    		DW	SCUROF			; EOT 0x04 (^D)  cursor off
 720:	0673  0E05    		DW	SCURON			; ENQ 0x05 (^E)  cursor on
 721:	0675  3E03    		DW	CRSLOC			; ACK 0x06 (^F)  locate cursor at CURPBUF
 722:	0677  2C05    		DW	SNDBEEP			; BEL 0x07 (^G)  beep
 723:	0679  3C05    		DW	MOVLFT			; BS  0x08 (^H)  cursor left (destr. and non destr.)
 724:	067B  2305    		DW	IOCNULL			; HT  0x09 (^I)  no-op
 725:	067D  3806    		DW	MOVDWN			; LF  0x0a (^J) :	069D  3806    		DW	MOVDWN			; SUB 0x1a (^Z)  cursor down one line
 742:	069F  B805    		DW	SIOCESC			; ESC 0x1b (^[)  activate alternate output processing
 743:	06A1  2305    		DW	IOCNULL			; FS  0x1c (^\)  no-op
 744:	06A3  2305    		DW	IOCNULL			; GS  0x1d (^])  no-op
 745:	06A5  2305    		DW	IOCNULL			; RS  0x1e (^^)  disabled (no-op)
 746:	06A7  2305    		DW	IOCNULL			; US  0x1f (^_)  no-op
 747:			
 748:			;; This table define the offsets to jump to control routines
 749:			;; for alternate (escaped)6C7  2606    		DW	REDOFF			; SI  0x0f (^O)  res bit 5 RAM3BUF (red)
 768:	06C9  0206    		DW	GREENON			; DLE 0x10 (^P)  set bit 6 RAM3BUF (green)
 769:	06CB  2C06    		DW	GREENOFF		; DC1 0x11 (^Q)  res bit 6 RAM3BUF (green)
 770:	06CD  F604    		DW	CURBLB			; DC2 0x12 (^R)  cursor blink slow block
 771:	06CF  FA04    		DW	CURBLL			; DC3 0x13 (^S)  cursor blink slow line
 772:	06D1  2305    		DW	IOCNULL			; DC4 0x14 (^T)  no-op
 773:	06D3  2305    		DW	IOCNULL			; NAK 0x15 (^U)  no-op
 774:	06D5  2305    		D	DE,HL
 688:	064B  CBF6    		SET	6,(HL)
 689:	064D  C9      		RET
 690:			
 691:			;;
 692:			;; CLRLIN - clear current line
 693:			;
 694:	064E          	CLRLIN:
 695:	064E  015000  		LD	BC,$0050
 696:	0651          	CLRLIN1:
 697:	0651  3A3E00  		LD	A,(RAM3BUF)
 698:	0654  F5      		PUSH	AF
 699:	0655  3EFF    		LD	A,$FF
 700:	0657  323E00  		LD	(RAM3BUF),A
 701:	065A  3E20    	CLRLP1:	LD	A,$20
 702:	065C  CDDE03  		CALL	DISPCH
 703:	065F  0B      		DEC	BC
 704:	0660  78      		LD	A,B
 705:	0661  B1      cursor down one line
 726:	067F  6B05    		DW	CHOME			; VT  0x0b (^K)  cursor @ column 0
 727:	0681  D204    		DW	CLRSCR			; FF  0x0c (^L)  page down (clear screen)
 728:	0683  7C05    		DW	IOCCR			; CR  0x0d (^M)  provess CR
 729:	0685  8605    		DW	CLREOP			; SO  0x0e (^N)  clear to EOP
 730:	0687  9F05    		DW	CLREOL			; SI  0x0f (^O)  clear to EOL
 731:	0689  2305    		DW	IOCNULL			; DLE 0x10 (^P)  no-op
 732:	068B  BC05    		DW	RESATTR			; DC1 0x11 (^Q)  reset all attributes
 733:	068D  FF02    		DW	C mode
 750:			
 751:	06A9          	IOCVEC2:
 752:	06A9  4606    		DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
 753:	06AB  E405    		DW	BLINKOFF		; SOH 0x01 (^A)  BLINK OFF
 754:	06AD  0E06    		DW	BLINKON			; STX 0x02 (^B)  BLINK ON
 755:	06AF  F005    		DW	UNDEROFF		; ETX 0x03 (^C)  UNDER OFF
 756:	06B1  1A06    		DW	UNDERON			; EOT 0x04 (^D)  UNDER ON
 757:	06B3  F605    		DW	HLIGHTOFF		; ENQ 0x05 (^E)  HLIGHT OFF
 758:	06B5  2006    		DW	HLIGHTON		; ACK 0x06 (^F)  HLIGHT ON
 759:	06BW	IOCNULL			; SYN 0x16 (^V)  no-op
 775:	06D7  4A06    		DW	SASCFLTR		; ETB 0x17 (^W)  set ascii filter
 776:	06D9  D805    		DW	RASCFLTR		; CAN 0x18 (^X)  reset ascii filter
 777:	06DB  DC05    		DW	NDBKSP			; EM  0x19 (^Y)  set non destructive BS
 778:	06DD  E005    		DW	DBKSP			; SUB 0x1a (^Z)  set destructive BS
 779:	06DF  1406    		DW	REVON			; ESC 0x1b (^[)  REVERSE ON
 780:	06E1  EA05    		DW	REVOFF			; FS  0x1c (^\)  REVERSE OFF
 781:	06E3  0806    		DW	BLUEON			; GS  0x1d (^])  set bit 7 RAM3BUF ( 		OR	C
 706:	0662  20F6    		JR	NZ,CLRLP1
 707:	0664  F1      		POP	AF
 708:	0665  323E00  		LD	(RAM3BUF),A
 709:	0668  C9      		RET
 710:			
 711:			;; This table define the offsets to jump to control routines
 712:			;; for primary (non-escaped) mode
 713:			
 714:	0669          	IOCVEC:
 715:	0669  4606    		DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
 716:	066B  2405    		DW	UCASEMOD		; SOH 0x01 (^A)  uppercase mode
 717:	066D  2805    		DW	LCASEMOD		; STX 0x02 (^B)  normal case moRTCINI			; DC2 0x12 (^R)  hard crt reset and clear
 734:	068F  2305    		DW	IOCNULL			; DC3 0x13 (^S)  no-op
 735:	0691  2305    		DW	IOCNULL			; DC4 0x14 (^T)  no-op
 736:	0693  C205    		DW	MOVUP			; NAK 0x15 (^U)  cursor up one line
 737:	0695  B005    		DW	SCROLLOFF		; SYN 0x16 (^V)  scroll off
 738:	0697  B405    		DW	SCROLLON		; ETB 0x17 (^W)  scroll on
 739:	0699  2F05    		DW	MOVLFTND		; CAN 0x18 (^X)  cursor left (non destr. only)
 740:	069B  2504    		DW	MOVRGT			; EM  0x19 (^Y)  cursor right
 7417  2305    		DW	IOCNULL			; BEL 0x07 (^G)  no-op
 760:	06B9  2305    		DW	IOCNULL			; BS  0x08 (^H)  no-op
 761:	06BB  2305    		DW	IOCNULL			; HT  0x09 (^I)  no-op
 762:	06BD  2305    		DW	IOCNULL			; LF  0x0a (^J)  no-op
 763:	06BF  2305    		DW	IOCNULL			; VT  0x0b (^K)  no-op
 764:	06C1  8B03    		DW	DBLANK			; FF  0x0c (^L)  blank screen
 765:	06C3  4606    		DW	RIOCESC			; CR  0x0d (^M)  clear alternate output processing
 766:	06C5  FC05    		DW	REDON			; SO  0x0e (^N)  set bit 5 RAM3BUF (red)
 767:	0blue)
 782:	06E5  3206    		DW	BLUEOFF			; RS  0x1e (^^)  res bit 7 RAM3BUF (blue)
 783:	06E7  2305    		DW	IOCNULL			; US  0x1f (^_)  no-op
 784:			
**** sert.asm ****
  71:				include genio.inc.asm
**** genio.inc.asm ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) Monitor
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; Generic I/O ports
   9:			; :								;          |||||---- b3 in  (unassigned)
  30:								;          ||||----- b4 in  (unassigned)
  31:								;          ||------- b5 out (ds1320 clock line)
  32:								;          ||------- b6 in  (ds1320 i/o line)
  33:								;          |-------- b7 out (ds1320 RST line)
  34:	06FD  D38B    		OUT	(CRTSERVCNT),A		; send to PIO2
  35:	06FF  DB89    		IN	A,(CRTSERVDAT)		; read data port PIO2
  36:	0701  CBBF    		RES	CLKRST,A		; ensure DS1320 RST line is low (active)
  37:	0703  CB8F    		RES	1,A			     =   0+    
bbcalret       =fd5a+    curbll           4fa     r0brdl         =   0+    
bbcbank        =   c+    curfxb           50a+    r0rxtx         =   0+    
bbcomn         =fc00+    curofs           46d     r1brdm         =   1+    
bbconin        =fd94+    curpbuf        =  48+    r1ier          =   1+    
bbconout       =fd9f+    curset           513     r2fcr          =   2+    
bbconst        =fdaa+    curset1          518     r2iir          =   2+    
bbcpboot       =fcc3+    cursetmode     bbfdrvsel      =fcd5+    doiniuart        160     rdureg0           31     
bbfhome        =fc81+    dselbf         =  4e+    rdureg1           92     
bbflopio       =fc93+    eep29c         =   4+    readcfg8255    =  92+    
bbfread        =fc87+    eep29ee        =   1+    redoff           626     
bbfwrite       =fc8d+    eep29xe        =   2+    redon            5fc     
bbhdboot       =fd0b+    eepage0        =  c0+    regastatus     =  16+    
bbhdgeo        =fd05+    eeproglock     =  10+    regcom---------------------------------------------------------------------
  10:			
  11:	06E9          	GIOINI:
  12:	06E9  3ECF    		LD	A,$CF			; 11-00-1111 mode ctrl word
  13:								; Mode 3 (bit mode port B)
  14:	06EB  D383    		OUT	(CRTPRNTCNT),A		; send to PIO0
  15:	06ED  08      		EX	AF,AF'
  16:	06EE  AF      		XOR	A			; bit mask 00000000 (all outputs)
  17:	06EF  D383    		OUT	(CRTPRNTCNT),A		; send to PIO0
  18:	06F1  08      		EX	AF,AF'			; reload mode 3 ctrl word
  19:	06F2  D387    		OUT	(CRTKEY; Modo 40/80 colonne (80)
  38:	0705  D389    		OUT	(CRTSERVDAT),A		; send to PIO2
  39:	0707  C9      		RET
  40:			
  41:			;;
  42:			;; PRNCHR - send a char to printer port (from C)
  43:			;
  44:	0708          	PRNCHR:
  45:	0708  DB89    		IN	A,(CRTSERVDAT) 
  46:	070A  CB47    		BIT	PRNTBUSYBIT,A
  47:	070C  20FA    		JR	NZ,PRNCHR
  48:	070E  79      		LD	A,C
  49:	070F  D381    		OUT	(CRTPRNTDAT),A
  50:	0711  C9      		RET
  51:			
**** sert.asm ****
  72:			
  73:	0712          		END



Statistic  510     r3lcr          =   3+    
bbcrtcini      =fc03+    cursoroff      =  20+    r4mcr          =   4+    
bbcrtfill      =fc09+    cursoron       =   a+    r5lsr          =   5+    
bbcstck        =   d+    cursshp        =  4a+    r6msr          =   6+    
bbcurset       =fc21+    dbksp            5e0     r7spr          =   7+    
bbdebug        =   0+    dblank           38b     ram0buf        =  3b+    
bbdiv16        =fcdb+    delay          =fd85+    ram1buf        =  3c+    
bbdmaset       =fcb7mand     =   f+    
bbhdinit       =fced+    eepsta         =f000+    regcontrol     =  16+    
bbhdrd         =fcff+    eepunsupp      =   8+    regcyllsb      =   c+    
bbhdwr         =fcf9+    eerineprom     =  80+    regcylmsb      =   d+    
bbimgp         =  c0+    esc            =  1b+    regdata        =   8+    
bbinictc       =fc57+    escnx            233+    regerr         =   9+    
bbjtobnk       =fc00+    false          =   0+    regseccnt      =   a+    
bbldpart       =fd11+    fdcbase    BCNT),A		; send to PIO1
  20:	06F4  08      		EX	AF,AF'
  21:	06F5  3D      		DEC	A			; load bit mask 11111111 (all inputs)
  22:	06F6  D387    		OUT	(CRTKEYBCNT),A		; send to PIO1
  23:	06F8  08      		EX	AF,AF'
  24:	06F9  D38B    		OUT	(CRTSERVCNT),A		; reload mode 3 ctrl word
  25:	06FB  3E5D    		LD	A,$5D			; bit mask 01011101
  26:								;          ||||||||- b0 in  (printer busy line)
  27:								;          |||||||-- b1 out (40/80 col. mode)
  28:								;          ||||||--- b2 in  (unassigned)
  29s:

     5	passes
     0	jr promotions
   522	symbols
     0	bytes

    20	macro calls
   325	macro bytes
     0	invented symbols



Symbol Table:

altprnprt      =   3+    ctcunlck         2da     print          =   9+    
ansidrv        =   0+    curadr           448     prnchr           708     
appbuf         =  2d+    curbfb           4fe+    prntbusybit    =   0+    
bbappp         =   e+    curbfl           502+    prvtop         =  4f+    
bbbase         =f000+    curblb           4f6     quit      +    deseq            127+    ram2buf        =  3d+    
bbdprmset      =fd17+    dgclp0           3df     ram3buf        =  3e+    
bbdriveid      =fcf3+    dismvc           36a     ramtbl         =e000+    
bbdsksel       =fcbd+    dispch           3de     rascfltr         5d8     
bbeidck        =fd23+    dispgr           3c1     rdcon          =   1+    
bbepmngr       =fd1d+    dly1           =fd89+    rdpy1            3b2     
bbexec         =fd29+    dly2           =fd87+    rdureg            f5     
    =  d0+    regsector      =   b+    
bbmul16        =fce1+    fdccmdstatr    =  d0+    regshd         =   e+    
bboffcal       =fce7+    fdcdatareg     =  d7+    regstatus      =   f+    
bbpag          =   f+    fdcdrvrcnt     =  d6+    resattr          5bc     
bbprcvblk      =fc6f+    fdcreadc       =  88+    resctc           2dc     
bbprnchr       =fc99+    fdcrestc       =   7+    revoff           5ea     
bbpsndblk      =fc63+    fdcsectreg     =  d2+    revon            614     
bbrdtime       =che            25d     
bbuplchr       =fc69+    frdpbuf        =  41+    rxche1           270     
bbvcpmbt       =fcc9+    fsecbuf        =  43+    sascfltr         64a     
bbvoid         =fd6a+    fsekbuf        =  3f+    savcolb          433+    
bbwrvdsk       =fc7b+    fstat          =fdb5+    sconin         =fc2d+    
bcexit           480     ftrkbuf        =  46+    sconout        =fc27+    
bconout          3f1+    gcrspos          349     sconst         =fc33+    
bdos           =   5+    gioini 2c     
cfil1            3a3     ideportc       =  e2+    suart            2ea     
chome            56b     ideportctrl    =  e3+    sysbase        =f000+    
clear          =  1c+    iderdline      =  40+    syscmlo        =feb4+    
clkio          =   6+    iderstline     =  80+    syscom         =fc00+    
clkrst         =   7+    idewrline      =  20+    syshertz       =  13+    
clksclk        =   5+    imtpag         =  ff+    sytimr         =fe19+    
clreol           59f     imtsiz         = 400+         =  30+    iocnull          523     txbusy1          1fe     
cnfbyte        =  26+    iocvec           669     txchar0          1e1     
cojp1            413     iocvec2          6a9     txchar1          1fb     
cojp2            422     kbdbyte        =  4d+    u0defspeed     =   6+    
colbuf         =  4f+    keybstrbbit    =   7+    u0isr          =fe25+    
conou2           437     lcasemod         528     u1defspeed     =   c+    
const          =   b+    lf             =   a+    u1isr         fca5+    fdcseekc       =  17+    riocesc          646     
bbrdvdsk       =fc75+    fdctrakreg     =  d1+    rldrom         =fe79+    
bbresctc       =fc5d+    fdcwritc       =  a8+    rst7sp1        =  38+    
bbsecset       =fcb1+    fdrvbuf        =  45+    rst7sp2        =  39+    
bbsidset       =fccf+    ff             =   c+    rst7sp3        =  3a+    
bbstack        =feb4+    fifblok        =   b+    rstdpy           3b0     
bbstbase       =fe90+    fifoend        =  25+    rtbsiz         = 3c0+           6e9     scrolloff        5b0     
bell           =   7+    greenoff         62c     scrollon         5b4     
bldoffs        =3000+    greenon          602     scrspos          36d     
blifastblok    =  60+    hlightoff        5f6     scrspos1         37b+    
blifastline    =  6a+    hlighton         620     scrtst           4c3     
blinkoff         5e4     hmempag        =   b+    scurof           506     
blinkon          60e     ictlp0           329     scuron           50e     
blislowblok   tab            =   9+    
clreop           586     ini6545          323     tblblk         =  30+    
clrj0            598     inicrt           315     tdesclen       =  14+    
clrlin           64e     inictc           2b0+    tiaddrlen      =   4+    
clrlin1          651     iniu1            1a6     timrcon        =  27+    
clrlp1           65a     iniu2            1aa     tmpbyte        =  4b+    
clrscr           4d2     iniuart0         14e     tnamelen       =   8+    
clsnc            4e7     ini =fe59+    
copsys         =  2c+    lfeed            485     u1nul          =fe70+    
cr             =   d+    lfeed1           489     uart0          =  c0+    
crdureg        =fc27+    maxblk         =  14+    uart0base      =  c0+    
crsloc           33e     mdjmp0           49f     uart0br        =  2b+    
crt6545adst    =  8c+    mdjmp1           4b5     uart1          =  c8+    
crt6545data    =  8d+    mejp             4c0     uart115k2      =   1+    
crtbase        =  80+    menaprt        =  2   
bbsttim        =fc9f+    fifokb         =  1a+    rxbusy0          23a     
bbtrkset       =fcab+    fifosto        =   f+    rxbusy1          216     
bbu0ini        =fc39+    fifou0         =   f+    rxchafif         24e     
bbu1ini        =fc51+    fifsize        =   8+    rxchaflp         252     
bbu1rx         =fc45+    fin            =fdc4+    rxchar0          22a+    
bbu1st         =fc4b+    fixblock       =   0+    rxchar1          215+    
bbu1tx         =fc3f+    fout           =fde1+    rx   =  40+    idea0line      =   1+    sdpysta          35a     
blislowline    =  4a+    idea1line      =   2+    ser_baud         14d+    
blueoff          632     idea2line      =   4+    ser_on           14b+    
blueon           608     idecs0line     =   8+    setrow           45a     
bs             =   8+    idecs1line     =  10+    sintvec        =fff0+    
btpasiz        =   6+    ideporta       =  e0+    siocesc          5b8     
cdisk          =   4+    ideportb       =  e1+    sndbeep          5uart1         157     tpa            = 100+    
cmdid          =  ec+    iniunok          1dd     tpagelen       =   2+    
cmdinit        =  91+    intrdi         =fe0f+    trasm            112     
cmdread        =  20+    intren         =fdfe+    trnpag         =   d+    
cmdrecal       =  10+    iobyte         =   3+    true           =ffff+    
cmdspindown    =  e0+    ioccr            57c     tsizelen       =   4+    
cmdspinup      =  e1+    ioccr1           584     txbusy0          1e4     
cmdwrite1+    uart1200       =  60+    
crtbeepport    =  8f+    miobyte        =  4c+    uart19k2       =   6+    
crtblinkbit    =   0+    mmgetp         =fd78+    uart1base      =  c8+    
crtcini          2ff     mmpmap         =fd6b+    uart1br        =  2a+    
crtfill          395+    mmtpapag       =  ef+    uart2400       =  30+    
crthilitbit    =   3+    mmuport        =  20+    uart38k4       =   3+    
crtkeybcnt     =  87+    mmutstaddr     =d000+    uart4800       =  18+    
crtkeybdat     =  85+          2ad     
crtservdat     =  89+    mzmac          =   1+    ustatus0         276+    
crttab1          2eb     ndbksp           5dc     ustatus1         29e+    
crtunderbit    =   2+    pio2bit2       =   2+    vconin         =fc15+    
crtwidthbit    =   1+    pio2bit3       =   3+    vconout        =fc0f+    
ctc0tc         =  29+    pio2bit4       =   4+    vconst         =fc1b+    
ctc0tchi       =  20+    ppakstb        =   1+    vdbufsz        =   a+    
ctc1tc         =  28+    ppcntrp                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        character to be output
;
srlout	push	af
sot0	ld	a,(opflg)	;test xon/xoff
	bit	0,a
	jr	nz,sot0		;idle if xoff
sot1	in	a,stat
	and	80h
	jr	z,sot1
	pop	af
	out	data,a
	ret
;
; vector setup routine
;
initvspc
	ld	hl,vspce	;vector space
	ld	l,0
	inc	h		;get on page boundary.
	ld	($vtab),hl	;save address.
	ld	a,h
	ld	i,a		;set i reg.
	ld	b,80h		;fill table with
	ld	de,dummy
iv1	ld	(hl),e		;rst 0's just in case.
	inc	hl
	ld	(hl),d
	inc	hl
	djnz	iv1
	ret
;
vset	ld	hl,($vtab)
	add	hl, mmutstpage     =   d+    uart57k6       =   2+    
crtmodebit     =   4+    monmaj         =  33+    uart9600       =   c+    
crtprgend        3bc     monmin         =  32+    uart_fail        14c+    
crtprntcnt     =  83+    movdwn           638     uastav         =fe84+    
crtprntdat     =  81+    movlft           53c     uastkb         =fe86+    
crtram0cnt     =  82+    movlft1          54c     ucasemod         524     
crtram0dat     =  80+    movlft2          55c     uisre          =fe4e+    
crtr=   2+    vdrdsec        =   0+    
ctc1tc100hz    =   5+    ppdatap        =   3+    vdskbuf        =  2f+    
ctc1tc10hz     =  30+    ppdini         =   0+    vdwrsec        =   1+    
ctc1tc25hz     =  13+    ppdokg         =   2+    voidisr        =fe22+    
ctc1tc2hz      =  f4+    ppdrdy         =   4+    wrcon          =   2+    
ctc1tc50hz     =   a+    ppdstp         =   6+    writecfg8255   =  80+    
ctcbase        =  e8+    ppstrob        =   0+    wrureg            c2     
ctcchan0       =  e8	title	SIO.Z80 - Serial i/o to host computer
;
	entry	srlinit,srlout,srlin,vset
	entry	pushem,popem,cphlde,baud
;
	ext	kbinit
;
; Interrupt program to run on CDOS.
; This program uses the interrupts on the Z80
; to receive data from a host computer
;
qbase	equ	20h
;
stat	equ	qbase
data	equ	qbase+1
baudr	equ	qbase
cmdr	equ	qbase+2
imskr	equ	qbase+3
;
xon	equ	11h
xoff	equ	13h
;
; initialise interrupts
;
srlinit	call	initvspc
	call	kbinit
	call	tuinit
	ret
;
; check for input
;
sbc
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ret
;
tuinit	ld	a,9
	out	cmdr,a
	ld	a,(baud)
	out	baudr,a
	ld	a,10h		;enable receive interrupts
	out	imskr,a
	ld	bc,qbase+8
	ld	de,rda
	call	vset
	im2
	ei
	ret
;
baud	db	84h	;for 300 baud
;
;	interrupt service routines
;
psoff	push	af
	ld	a,xoff
	call	srlout
	pop	af
	ret
;
pson	ld	a,xon
	jp	srlout
;
rda	di
	ld	(tstack),sp
	ld	sp,stack
	call	pushem
	ld	a,(ilen)
	ld	hl,opflg
	cp	imax-16
	call	z,psoff
	cp	imax
	jr	z,iret
;
	in	a,dataam1cnt     =  86+    movlftnd         52f     uisri          =fe32+    
crtram1dat     =  84+    movrgt           425     underoff         5f0     
crtram2cnt     =  8a+    movup            5c2     underon          61a     
crtram2dat     =  88+    mscnt          =  f6+    ustaf1           292+    
crtram3port    =  8e+    msinit           125+    ustafif          28c     
crtrevrsbit    =   1+    msinitnok        141+    ustat0           29b     
crtservcnt     =  8b+    msinitok         13b+    ustat1    +    ppuack         =   7+    wrureg0            0     
ctcchan1       =  e9+    ppuini         =   1+    wrureg1           61     
ctcchan2       =  ea+    ppuokg         =   3+    
ctcchan3       =  eb+    ppurdy         =   5+    
                                                                                                                                                                                                                                                                                      rlin	ld	a,(ilen)	;buffer length
	or	a		;empty ?
	ret	z		;Yes -> forget it
	call	getbyte
	scf
	ret
;
; get input and update pointers.
;
getbyte	push	hl
	push	de
	ld	hl,(ibgp)
	ld	a,(hl)		;get next char.
	inc	hl
	ld	de,ibend
	call	cphlde		;buffer end ?
	jr	c,noiwrap	;no ->
	ld	hl,ibstrt	;yes, back to start
noiwrap	ld	(ibgp),hl
	ld	hl,ilen
	dec	(hl)
	push	af
	ld	a,(ilen)
	cp	imax-20
	call	z,pson
	pop	af
	pop	de
	pop	hl
	ret
;
;  comms output routine
;  upon entry:	a contains the 
	and	7fh
	cp	xoff
	jr	z,idle
	cp	xon
	jr	z,nidle
	ld	hl,(ibpp)
	ld	(hl),a
	inc	hl
	ld	de,ibend
	call	cphlde
	jr	c,norw
	ld	hl,ibstrt
norw	ld	(ibpp),hl
	ld	hl,ilen
	inc	(hl)
;
iret	call	popem
	ld	sp,(tstack)
	ei
dummy	reti
;
idle	set	0,(hl)
	jr	iret
;
nidle	res	0,(hl)
	jr	iret
;
cphlde	push	hl		;compares hl & de
	or	a		;and sets flags.
	sbc	hl,de
	pop	hl
	ret
;
pushem	ex	(sp),hl		;save main regs on stack.
	push	de		;the hl pair is mod'd.
	push	bc
	push	af
	jp	(hl)
;
po                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                pem	pop	hl		;restore all main regs
	pop	af		;from stack after a
	pop	bc		;call to pushem.
	pop	de
	ex	(sp),hl
	ret
;
opflg	db	0
;
ilen	db	0		;input buffer length
ibgp	dw	ibstrt		;input buffer get pointer
ibpp	dw	ibstrt		;input buffer put pointer
ibstrt	equ	$		;input buffer start
ibuff	ds	0ffh		;input buffer
ibend	equ	$		;input buffer end
imax	equ	0ffh		;input buffer max length
;
tstack	ds	80h
stack	equ	$
;
$vtab	ds	2		;address of vector table
vspce	ds	200h		;vector space
;
	end
     
;;
;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
;;

	include datkstar.equ

LF	EQU	0AH
CR	EQU	0DH
BS	EQU	08H		;Back space (required for sector display)
BELL	EQU	07H
TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
ESC	EQU	1BH
CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
				;on other video cards)
RDCON	EQU	1		;For CP/M I/O
WRCON	EQU	2
PRINT	EQU	9
CONST	EQU	11		;CONSOLE STAT
BDOS	EQU	5

FALSE	EQU	0
TRUE	EQU	-1

QUIT	EQU	0

	ORG	$100




;----------------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ---------------------------------------------------------------

MSINIT		DB 'Initalising UART...',CR,LF,'$'
MSINITOK	DB 'Ok.',CR,LF,'$'
MSINITNOK	DB 'Failure',CR,LF,'$'
;
;-------------------------------------------------------------------------------

SER_ON:		DS	1	; serial on/off
UART_FAIL:	DS	1	; UART has failed detection flag
SER_BAUD:	DS	1	; specify desired UART com rate in bps

	include uartctc.inc.asm

	END

                                                                                             	include datkstar.equ

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         e',CR,LF,'$'
;
;-------------------------------------------------------------------------------

SER_ON:		DS	1	; serial on/off
UART_FAIL:	DS	1	; UART has failed detection flag
SER_BAUD:	DS	1	; specify desired UART com rate in bps

	include uartctc.inc.asm
	include crtc.inc.asm
	include genio.inc.asm

	END

                                                                                                                                                                                                             "H )>ЏУ‚У†УЉНГ­!Ь xУЊ~УЌ#xю ф!  "H НK*H Н^Ї2O Й>УЊЫЌg>УЊЫЌo#b>УЊ|УЌ>УЊ}УЌRНП>УЊ|УЌ>УЊ}УЌ>УЊ|УЌ>УЊ}УЌ1!  "; Ї2= >п2> !  "H НЎеНІб#|ю х xЖУЊЇУЌц>УЊЙЫЊЛ(ъ!; ~УЂ#~У„#~У€:> УЋЇУЌЙхЫЊЛ(ъсУЂ:> УЋЇУЌЙхЕХе!qеy!L Л~л 5ю 0‡& oq	~#foйлЛv(
ю@8ю`0Ц@НПН:Н^:O <юP(R2O Йю 0‡& o±	~#foй!K ЛF юpРЦ 2- ЛЖЙю9РЦЛ†!L ЛѕG!°яP э:- 2O _л*H Г^бСБсЙЇ2O НґШ!L ЛV0шН:+(Г^еНV*H P  енRб8Лњ"H НKб8ЛњГ^н[H ЇнR|юШ}юПЙ!  Ї2O /2> "H Н^НKе> НП#|ю хбГ^.@.J.`.j
. .    1:			
   2:			;;
   3:			;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
   4:			;;
   5:			
   6:				include darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FE89          	TX0            	EQU	0FE89H
   5:	FDC4          	FIN            	EQU	0FDC4H
   6:	FE8B          	TX01           	EQU	0FE8BH
   7:	FD89          	DLY1           	EQU	0FD89H
   8:	FD87          	DLY2           	EQU	0FD
;;
;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
;;

	include darkstar.equ
	include Common.inc.asm

LF	EQU	0AH
CR	EQU	0DH
BS	EQU	08H		;Back space (required for sector display)
BELL	EQU	07H
TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
ESC	EQU	1BH
CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
				;on other video cards)
RDCON	EQU	1		;For CP/M I/O
WRCON	EQU	2
PRINT	EQU	9
CONST	EQU	11		;CONSOLE STAT
BDOS	EQU	5

FALSE	EQU	0
TRUE	EQU	-1

QUIT	EQU	0

	ORG	$1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ее:J o>
УЊ}УЌбГ­ЙлЛЮЙлЛћЙУЏЙ!L ~Лf Н7> НПНН7Й!L ~хЛжНDсwЙН:+н[H ЇнRј ЅИ+Н^е:O =юя >O2O !L ЛfбА> Г[!O ^ЇwWН:+нRН^ЙлЛ^(Н§еЇ*H РлН:+лнRеБНYлГ^:O G>Pђ OН:+лилЛЦЙлЛ–ЙлЛюЙ>я2> ЙН:Їял*H лЇнR/јИГ^лЛ¶ЙлЛжЙлЛ¦Й!> ЛЖЙ!> ЛОЙ!> ЛЦЙ!> ЛЮЙ!> ЛоЙ!> ЛцЙ!> ЛюЙ!> Л†Й!> ЛЋЙ!> Л–Й!> ЛћЙ!> Л®Й!> Л¶Й!> ЛѕЙН:+P Н^ГzлЛѕЙлЛцЙP :> х>я2> > НПx± цс2> ЙNчя/ @sГ„Ћ§ДрКёј7@АNмш"ю(|N.
4злRадит:>ПУѓЇУѓУ‡=У‡87H
   9:	FDE1          	FOUT           	EQU	0FDE1H
  10:	FE72          	U1NUL          	EQU	0FE72H
  11:	FE25          	U0ISR          	EQU	0FE25H
  12:	FE5B          	U1ISR          	EQU	0FE5BH
  13:	FD85          	DELAY          	EQU	0FD85H
  14:	FE50          	UISRE          	EQU	0FE50H
  15:	FDB5          	FSTAT          	EQU	0FDB5H
  16:	FE35          	UISRI          	EQU	0FE35H
  17:	FE81          	DOSTX          	EQU	0FE81H
  18:	FC4B          	BBU1ST         	EQU	0FC4BH
  19:	FC45          	BBU1RX 00

; 	LD	A,U0DEFSPEED		; uart 0 init
; 	LD	(UART0BR),A
; 	CALL	INIUART0
	LD	A,UART9600		; uart 1 init
	LD	(UART1BR),A
	CALL	INIUART1

; 	LD	C,'@'
; TRASM:	CALL	TXCHAR0
; 	CALL	TXCHAR1
; 	CALL	BBCONOUT
; 	INC	C
; 	LD	A,C
; 	CP	'z'
; 	JR	NZ,TRASM
; 	LD	C,'@'
; 	JR	TRASM

RECE:	CALL	RXCHAR1
	CP	3
	JP	Z,0
	LD	C,A
	CALL	BBCONOUT
	JR	RECE



;-------------------------------------------------------------------------------

MSINIT		DB 'Initalising UART...',CR,LF,'$'
MSINITOK	DB 'Ok.',CR,LF,'$'
MSINITNOK	DB 'Failur>2* НHНюК  OНџэтInitalising UART...
$Ok.
$Failure
$   >А2ЫНQЙ>И2ЫНQЙЕЄ:ЫЖOнA:ЫЖOнxюЄВОU:ЫЖOнA:ЫЖOнxюUВОЂ:ЫЖOнA:ЫюА :+ G:* G:ЫЖ OнA :ЫЖOнA:ЫЖOнA:ЫЖOнA:ЫЖOнAБЇЙБ>яЙyЕх>АЖOнxЛoКХсG>АЖ OнAБЙyЕх>ИЖOнxЛoКпсG>ИЖ OнAБЙЕ>ИЖOнxЛG(х>ИЖ OнxБЙЕЭеХеЭ!K Э~ Лo >АЖOнxЛG(х>АЖ OнxЭ! Нµэ(ыуНбэыy!L Л^(юaъaю{тaЛЇбСЭбБЙ:K Лo Е>АЖOнxЛGБ ЇЙЭеЭ! НµэЭб ЇЙ>яЙЕ>ИЖOнxЛGБ ЇЙ>яЙНН>рУи>ЧУл>Ул>ЧУк>Ук>ЧУй:( Уй>'Уи:) УиЙнMНЛ>УиУйУкУлЙ oPW( H         НН|Нс>я2> ! У‹>]У‹Ы‰ЛїЛЏУ‰ЙЫ‰ЛG ъyУЃЙ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              	EQU	0FC45H
  20:	FC3F          	BBU1TX         	EQU	0FC3FH
  21:	FD29          	BBEXEC         	EQU	0FD29H
  22:	FCFF          	BBHDRD         	EQU	0FCFFH
  23:	FD6A          	BBVOID         	EQU	0FD6AH
  24:	FEA4          	UASTKB         	EQU	0FEA4H
  25:	FD6B          	MMPMAP         	EQU	0FD6BH
  26:	FE0F          	INTRDI         	EQU	0FE0FH
  27:	FC2D          	SCONIN         	EQU	0FC2DH
  28:	FC15          	VCONIN         	EQU	0FC15H
  29:	FCDB          	BBDIV16        	EQU	0FCDBH
  30:	FCF9          	EQU	0FFF0H
  52:	FED2          	SYSCMLO        	EQU	0FED2H
  53:	FE22          	VOIDISR        	EQU	0FE22H
  54:	FC9F          	BBSTTIM        	EQU	0FC9FH
  55:	FDAA          	BBCONST        	EQU	0FDAAH
  56:	FC27          	SCONOUT        	EQU	0FC27H
  57:	FC0F          	VCONOUT        	EQU	0FC0FH
  58:	FCE7          	BBOFFCAL       	EQU	0FCE7H
  59:	FC57          	BBINICTC       	EQU	0FC57H
  60:	FEAE          	BBSTBASE       	EQU	0FEAEH
  61:	FC5D          	BBRESCTC       	EQU	0FC5DH
  62:	FCA5  T       	EQU	0FD9FH
  84:	FCF3          	BBDRIVEID      	EQU	0FCF3H
  85:	FC63          	BBPSNDBLK      	EQU	0FC63H
  86:	FC03          	BBCRTCINI      	EQU	0FC03H
  87:	FC6F          	BBPRCVBLK      	EQU	0FC6FH
  88:	FC09          	BBCRTFILL      	EQU	0FC09H
  89:	FCD5          	BBFDRVSEL      	EQU	0FCD5H
  90:	FD17          	BBDPRMSET      	EQU	0FD17H
  91:			;****** EOF ***
  92:			
**** srlr1.asm ****
   7:				include Common.inc.asm
**** Common.inc.asm ****
   1:			;
   2:			;===========================-----------------------------------------------
  27:			; Revisions:
  28:			; 20140905 - Modified hexadecimal constants to 0xxH format to be widely
  29:			;            accepted by different assemblers
  30:			; 20150714 - Modified to implement serial XON/XOFF and RTS/CTS
  31:			; ---------------------------------------------------------------------
  32:			
  33:			; ---------------------------------------------------------------------
  34:			; SYSBIOS
  35:			;
  36:			; This is the BIOS non-resident p        	BBHDWR         	EQU	0FCF9H
  31:	FD78          	MMGETP         	EQU	0FD78H
  32:	FDFE          	INTREN         	EQU	0FDFEH
  33:	FE97          	RLDROM         	EQU	0FE97H
  34:	FCE1          	BBMUL16        	EQU	0FCE1H
  35:	FC00          	SYSCOM         	EQU	0FC00H
  36:	FEA2          	UASTAV         	EQU	0FEA2H
  37:	FE19          	SYTIMR         	EQU	0FE19H
  38:	FC33          	SCONST         	EQU	0FC33H
  39:	FC1B          	VCONST         	EQU	0FC1BH
  40:	FE7F          	SRXRSM         	EQU	0FE        	BBRDTIME       	EQU	0FCA5H
  63:	FD5A          	BBCALRET       	EQU	0FD5AH
  64:	FCB7          	BBDMASET       	EQU	0FCB7H
  65:	FC00          	BBJTOBNK       	EQU	0FC00H
  66:	FCBD          	BBDSKSEL       	EQU	0FCBDH
  67:	FCED          	BBHDINIT       	EQU	0FCEDH
  68:	FCB1          	BBSECSET       	EQU	0FCB1H
  69:	FD0B          	BBHDBOOT       	EQU	0FD0BH
  70:	FC69          	BBUPLCHR       	EQU	0FC69H
  71:	FC99          	BBPRNCHR       	EQU	0FC99H
  72:	FCC9          	BBVCPMBT       	EQU	0FC============================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) SysBios
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; Original code:
   9:			; Z80 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
  10:			;
  11:			; Disassembled and reconstructed by
  12:			; Piergiorgio Betti <pbetti@lpconsul.net> on 2005 01 26
  13:			;
  14:			; Latest non modular BIOS is DARKSTAR-MONITOR-0.9.0.asm
  15:			; dated 20140531
  1ortion of the new (banked)
  37:			; BIOS/Monitor for the NE Z80 (aka DarkStar)
  38:			;
  39:			; ---------------------------------------------------------------------
  40:			;
  41:			; Full BIOS memory scheme:
  42:			;
  43:			;	+-----------------+
  44:			;	+    SysCommon    +   <-- Resident portion. Common to all images
  45:			;	+   FC00 - FFFF   +
  46:			;	+-----------------+
  47:			;	+-----------------+   +-----------------+   +-----------------+
  48:			;	+     SysBios     +   +   BootMonitor 7FH
  41:	FE7B          	SRXSTP         	EQU	0FE7BH
  42:	FC39          	BBU0INI        	EQU	0FC39H
  43:	FC51          	BBU1INI        	EQU	0FC51H
  44:	FC87          	BBFREAD        	EQU	0FC87H
  45:	FD23          	BBEIDCK        	EQU	0FD23H
  46:	FD05          	BBHDGEO        	EQU	0FD05H
  47:	FED2          	BBSTACK        	EQU	0FED2H
  48:	FC81          	BBFHOME        	EQU	0FC81H
  49:	FD94          	BBCONIN        	EQU	0FD94H
  50:	FC27          	CRDUREG        	EQU	0FC27H
  51:	FFF0          	SINTVECC9H
  73:	FC93          	BBFLOPIO       	EQU	0FC93H
  74:	FD1D          	BBEPMNGR       	EQU	0FD1DH
  75:	FCCF          	BBSIDSET       	EQU	0FCCFH
  76:	FD11          	BBLDPART       	EQU	0FD11H
  77:	FC75          	BBRDVDSK       	EQU	0FC75H
  78:	FC8D          	BBFWRITE       	EQU	0FC8DH
  79:	FCC3          	BBCPBOOT       	EQU	0FCC3H
  80:	FC21          	BBCURSET       	EQU	0FC21H
  81:	FCAB          	BBTRKSET       	EQU	0FCABH
  82:	FC7B          	BBWRVDSK       	EQU	0FC7BH
  83:	FD9F          	BBCONOU6:			; - Following addition of MultiF-Board doing complete rewrite of the
  17:			;   monitor/BIOS has been started.
  18:			;   Major goals:
  19:			;   o Modularization: Now monitor can grow up to 256kb instead of 4kb
  20:			;     :-)
  21:			;   o Specialized images fitted in memory page (4kb) or multiples
  22:			;   o Full support for new hardware
  23:			;   o I/O rewrite for MODE 2 interrupts
  24:			;   Minor goals:
  25:			;   o Full code clean-up & reoarganization
  26:			; ----------------------  +   +     [Other]     +
  49:			;	+   F000 - FBFF   +   +   F000 - FBFF   +   +   F000 - FBFF   +
  50:			;	+-----------------+   +-----------------+   +-----------------+
  51:			;
  52:			;	         ^                     ^                     ^
  53:			;	         |                     |                     |
  54:			;	         ---------------------------------------------
  55:			;	                      Variable section
  56:			;
  57:			; The above are always assembled at ORG F000 and linked and allocaabels
  92:			;
  93:			
  94:			; -- Global --
  95:	0003          	IOBYTE		EQU	0003H		; byte: Intel IOBYTE (CP/M 2.2 only)
  96:	0004          	CDISK		EQU	0004H		; byte: Last logged drive
  97:	0006          	BTPASIZ		EQU	0006H		; word: size of tpa + 1
  98:			;
  99:			; -- Private --
 100:	000B          	HMEMPAG		EQU	000BH		; byte: highest ram page
 101:	000C          	BBCBANK		EQU	000CH		; byte: current bank
 102:	000D          	BBCSTCK		EQU	000DH		; word: current stack
 103:					;
 104:	004F          ll chars	1 = obscure non punct.
 124:								;         7: 0 = ctrl chr set 1		1 = ctrl chr set 2
 125:	004B          	TMPBYTE		EQU	MIOBYTE-1	; byte: transients flags
 126:								; - bits: 0: 0 = high in cursor addressing
 127:								;         1: 0 = ESC catched by ANSI driver
 128:								;         2: 0 = CSI catched by ANSI driver
 129:								;         3: 0 = Two byte code ESC seq. from serial
 130:								;         4: 0 = Plain serial i/o (disable ANSI driver)
 131:								;         5: 0 = store interr          	RST7SP1		EQU	0038H
 148:	002F          	RSRVBUF		EQU	RST7SP1-9	; free 9 byte buffer
 149:	002D          	APPBUF		EQU	RSRVBUF-2	; word: generic buffer
 150:	002C          	COPSYS		EQU	APPBUF-1	; Op system type for partition selection
 151:	002B          	UART0BR		EQU	COPSYS-1	; UART 0 baudrate
 152:	002A          	UART1BR		EQU	UART0BR-1	; UART 1 baudrate
 153:	0029          	CTC0TC		EQU	UART1BR-1	; CTC channel 0 time constant
 154:	0028          	CTC1TC		EQU	CTC0TC-1	; CTC channel 1 time constant
ted
  58:			; in the EEPROM in this way:
  59:			;
  60:			;	+-----------------+
  61:			;	+    SysCommon    +
  62:			;	+   FC00 - FFFF   +
  63:			;	+     SysBios     +     <-- EEPROM page 1 ($C1000)
  64:			;	+   F000 - FBFF   +
  65:			;	+-----------------+
  66:			;	+-----------------+
  67:			;	+    SysCommon    +
  68:			;	+   FC00 - FFFF   +
  69:			;	+   BootMonitor   +     <-- EEPROM page 0 ($C0000)
  70:			;	+   F000 - FBFF   +
  71:			;	+-----------------+
  72:			;
  73:			; -------------------	PRVTOP		EQU	004FH		; top of private area storage
 105:	004F          	COLBUF		EQU	PRVTOP		; byte:
 106:	004E          	DSELBF		EQU	COLBUF-1	; byte: floppy drive select status
 107:								; - bits: 0 = drive 0
 108:								; - bits: 1 = drive 1
 109:								; - bits: 2 = drive 2
 110:								; - bits: 3 = drive 3
 111:								; - bits: 4 = unused
 112:								; - bits: 5 = head select
 113:								; - bits: 6 = motor on (disabled by jumper)
 114:								; - bits: 7 = unused
 115:	004D          	KBDBYTE		EQupt status (on/off)
 132:								;         6: 0 = floppy home on err	1 = no home on err
 133:								;         7: 0 = unlock LBA free addressing (unpartitioned)
 134:	004A          	CURSSHP		EQU	TMPBYTE-1	; cursor shape
 135:	0048          	CURPBUF		EQU	CURSSHP-2	; word: cursor position
 136:	0046          	FTRKBUF		EQU	CURPBUF-2	; word: track # for i/o (0 - 65535)
 137:	0045          	FDRVBUF		EQU	FTRKBUF-1	; byte: drive number for i/0 (0 - 15)
 138:	0043          	FSECBUF		EQU	FDRVBUF-2	; word: sector # f 155:	0027          	TIMRCON		EQU	CTC1TC-1	; timer buf
 156:	0026          	CNFBYTE		EQU	TIMRCON-1	; config byte
 157:								; - bits: 0: 0 = UART1 intr disabled	1 = RST8 redir UART1
 158:								;         1: 1 = XON/XOFF enabled on UART0
 159:								;         2: 1 = RTS/CTS enabled on UART0
 160:								;         3: 0 = unused/reserved
 161:								;         4: 0 = unused/reserved
 162:								;         5: 0 = unused/reserved
 163:								;         6: 0 = unused/reserved
 164:								;         7: 0 = unu--------------------------------------------------
  74:			;
  75:			; Define which assembler we are using
  76:			;
  77:			
  78:			; PASMO	EQU	1
  79:	0001          	MZMAC	EQU	1
  80:			; ZMAC	EQU	1			; ZMAC Z80 assembler, not Linux/Unix version
  81:			
  82:			; ... only one at a time can be active (1) ...
  83:			
  84:			;
  85:			; Monitor version numbers (major.minor)
  86:			;
  87:	0033          	MONMAJ		EQU	'3'
  88:	0034          	MONMIN		EQU	'4'
  89:			
  90:			;
  91:			; Buffers addresses lU	DSELBF-1	; byte: store keyboard input
 116:	004C          	MIOBYTE		EQU	KBDBYTE-1	; byte:
 117:								; - bits: 0: 0 = floppy write		1 = floppy read
 118:								;         1: 0 = no ctrl on keypress	1 = ctrl on keypress
 119:								;         2: 0 = scroll			1 = no scroll
 120:								;         3: 0 = accept lowercase	1 = convert to uppercase
 121:								;         4: 0 = destr. bkspace		1 = non destr. bkspace
 122:								;         5: 0 = console out		1 = serial out
 123:								;         6: 0 = disp. aor i/o (1 .. 65535)
 139:	0041          	FRDPBUF		EQU	FSECBUF-2	; word: dma address for i/o
 140:	003F          	FSEKBUF		EQU	FRDPBUF-2	; word: current track number for drive A/B
 141:	003E          	RAM3BUF		EQU	FSEKBUF-1	; byte:
 142:	003D          	RAM2BUF		EQU	RAM3BUF-1	; byte:
 143:	003C          	RAM1BUF		EQU	RAM2BUF-1	; byte:
 144:	003B          	RAM0BUF		EQU	RAM1BUF-1	; byte:
 145:	003A          	RST7SP3		EQU	003AH		; keep clear area of RST38 (RST7)
 146:	0039          	RST7SP2		EQU	0039H
 147:	0038sed/reserved
 165:	000F          	FIFOSTO		EQU	000FH		; fifo queues storage start
 166:	0008          	FIFSIZE		EQU	8		; fifo queue lenght
 167:	000B          	FIFBLOK		EQU	11		; fifo queue size
 168:	000F          	FIFOU0		EQU	FIFOSTO		; uart 0 queue (alternate console)
 169:	001A          	FIFOKB		EQU	FIFOU0+FIFBLOK	; keyboard queue
 170:	0025          	FIFOEND		EQU	FIFOKB+FIFBLOK	; fifo blocks end
 171:			;
 172:	3000          	BLDOFFS		EQU	3000H		; place for disk bootloader
 173:			
 174:			;
 175:			; sume to initialize MMU as follow:
 202:			;
 203:			; +--------+
 204:			; |  F000  |	-> $C0000  eeprom page 0
 205:			; +--------+
 206:			; +--------+
 207:			; |  EFFF  |
 208:			; +--------+
 209:			;     ...       -> $00000 to $0EFFF ram
 210:			; +--------+
 211:			; |  0000  |
 212:			; +--------+
 213:			;
 214:			
 215:			
 216:			; include	modules/hwequs.inc.asm
 217:			; Hardware equates
 218:			; ---------------------------------------------------------------------
 219:			
 220:			; -----------085          	CRTKEYBDAT	EQU	CRTBASE+5	; KEYBOARD (input): PIO1 port B data register
 236:	0087          	CRTKEYBCNT	EQU	CRTBASE+7	; KEYBOARD (input): PIO1 port B control register
 237:	0007          	KEYBSTRBBIT	EQU	7		; Strobe bit
 238:				; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
 239:	0088          	CRTRAM2DAT	EQU	CRTBASE+8	; RAM2 access: PIO2 port A data register
 240:	008A          	CRTRAM2CNT	EQU	CRTBASE+10	; RAM2 access: PIO2 port A control register
 241:				; Service/User port
 242:	0089       	CRTUNDERBIT	EQU	2		; Underline
 259:	0003          	CRTHILITBIT	EQU	3		; Highlight
 260:	0004          	CRTMODEBIT	EQU	4		; ASCII/GRAPHIC mode
 261:				; Beeper port
 262:	008F          	CRTBEEPPORT	EQU	CRTBASE+15	; Beeper port
 263:				; 6545 CRT controller ports
 264:	008C          	CRT6545ADST	EQU	CRTBASE+12	; Address & Status register
 265:	008D          	CRT6545DATA	EQU	CRTBASE+13	; Data register
 266:				; Cursor modes
 267:	0040          	BLISLOWBLOK	EQU	40H		; Blink, slow, block
 268:	004A  Some commodity equs
 176:			;
 177:	000D          	CR		EQU	0DH		; ascii CR & LF
 178:	000A          	LF		EQU	0AH
 179:	000C          	FF		EQU	0CH		; FORM FEED (clear screen)
 180:	001B          	ESC		EQU	1BH		; ESCape
 181:	0011          	XONC		EQU	11H		; Xon
 182:	0013          	XOFC		EQU	13H		; Xoff
 183:	FFFF          	TRUE		EQU	-1
 184:	0000          	FALSE		EQU	0
 185:	0100          	TPA		EQU	0100H		; TPA base address (for CP/M)
 186:			
 187:			;
 188:			; Modules equs
 189:			;
 190:				; delay
 191:----------------------------------------------------------
 221:			; LX529 VIDEO BOARD:
 222:			; ---------------------------------------------------------------------
 223:	0080          	CRTBASE		EQU	80H
 224:				; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
 225:	0080          	CRTRAM0DAT	EQU	CRTBASE		; RAM0 access: PIO0 port A data register
 226:	0082          	CRTRAM0CNT	EQU	CRTBASE+2	; RAM0 access: PIO0 port A control register
 227:				; Printer port
 228:	0081          	CRT          	CRTSERVDAT	EQU	CRTBASE+9	; Service (i/o): PIO2 port B data register
 243:	008B          	CRTSERVCNT	EQU	CRTBASE+11	; Service (i/o): PIO2 port B control register
 244:	0000          	PRNTBUSYBIT	EQU	0		; Printer BUSY bit		(in)	1
 245:	0001          	CRTWIDTHBIT	EQU	1		; Set 40/80 chars per line	(out)	0
 246:	0002          	PIO2BIT2	EQU	2		; user 1 (input)		(in)	1
 247:	0003          	PIO2BIT3	EQU	3		; user 2 (input)		(in)	1
 248:	0004          	PIO2BIT4	EQU	4		; user 3 (input)		(in)	1
 249:	0005          	BLISLOWLINE	EQU	4AH		; Blink, slow, line
 269:	0060          	BLIFASTBLOK	EQU	60H		; Blink, fast, block
 270:	006A          	BLIFASTLINE	EQU	6AH		; Blink, fast, line
 271:	0020          	CURSOROFF	EQU	20H		; Off
 272:	0000          	FIXBLOCK	EQU	00H		; Fixed, block
 273:	000A          	CURSORON	EQU	0AH		; On
 274:			
 275:			; ---------------------------------------------------------------------
 276:			; LX390 FDC CONTROLLER:
 277:			; --------------------------------------------------------------	00F6          	MSCNT		EQU	246
 192:				; mmu
 193:	000D          	MMUTSTPAGE	EQU	0DH		; logical page used for sizing
 194:	D000          	MMUTSTADDR	EQU	MMUTSTPAGE<<12	; logical page used for sizing
 195:			
 196:			; Conventionally all bios/monitor images start at $F000.
 197:			; Except for special cases all code is copied to ram @ $F000.
 198:			; In this case eeprom page 0 is directly mapped into logical space
 199:			; by hardware so we can initialize the system at cold boot.
 200:			;
 201:			; We asPRNTDAT	EQU	CRTBASE+1	; PRINTER (output): PIO0 port B data register
 229:	0083          	CRTPRNTCNT	EQU	CRTBASE+3	; PRINTER (output): PIO0 port B control register
 230:								; STROBE is generated by hardware
 231:				; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
 232:	0084          	CRTRAM1DAT	EQU	CRTBASE+4	; RAM1 access: PIO1 port A data register
 233:	0086          	CRTRAM1CNT	EQU	CRTBASE+6	; RAM1 access: PIO1 port A control register
 234:				; Keyboard port (negated). Bit 7 is for strobe
 235:	0        	CLKSCLK		EQU	5		; DS1320 clock line		(out)	0
 250:	0006          	CLKIO		EQU	6		; DS1320 I/O line		(i/o)	1
 251:	0007          	CLKRST		EQU	7		; DS1320 RST line		(out)	0
 252:				; normal set for PIO2 (msb) 01011101 (lsb) that is hex $5D
 253:								; Other bits available to user
 254:				; RAM3 control chars/graphics attributes
 255:	008E          	CRTRAM3PORT	EQU	CRTBASE+14	; RAM3 port
 256:	0000          	CRTBLINKBIT	EQU	0		; Blink
 257:	0001          	CRTREVRSBIT	EQU	1		; Reverse
 258:	0002   -------
 278:	00D0          	FDCBASE		EQU	0D0H
 279:	00D0          	FDCCMDSTATR	EQU	FDCBASE		; Command and status register
 280:	00D1          	FDCTRAKREG	EQU	FDCBASE+1	; Track register
 281:	00D2          	FDCSECTREG	EQU	FDCBASE+2	; Sector register
 282:	00D7          	FDCDATAREG	EQU	FDCBASE+7	; Data register *** Verificare che sia $d7
 283:	00D6          	FDCDRVRCNT	EQU	FDCBASE+6	; Driver select/control register
 284:			;
 285:	0007          	FDCRESTC	EQU	00000111b	; 1771 restore (seek to trak 0) cmd
 28601          	PPUINI		EQU	01H		; 00000001 Upl Init byte
 308:	0005          	PPURDY		EQU	05H		; 00000101 Upl Ready
 309:	0007          	PPUACK		EQU	07H		; 00000111 Upl Acknowledge
 310:	0003          	PPUOKG		EQU	03H		; 00000011 Upl Ok Go
 311:			;
 312:			; virtual disks (PC-linked over parallel port)
 313:	0000          	VDRDSEC		EQU	0		; read sector command
 314:	0001          	VDWRSEC		EQU	1		; write sector command
 315:	000A          	VDBUFSZ		EQU	10		; 10 bytes block
 316:			; -------------------------N	EQU	4		;	image address	: 4 bytes
 336:	0004          	TSIZELEN	EQU	4		;	image size	: 4 bytes
 337:	0014          	TDESCLEN	EQU	20		;	description	: 20 bytes
 338:			; -- IDE --
 339:	00E0          	IDEPORTA	EQU	0E0H		; lower 8 bits of IDE interface
 340:	00E1          	IDEPORTB	EQU	0E1H		; upper 8 bits of IDE interface
 341:	00E2          	IDEPORTC	EQU	0E2H		; control lines for IDE interface
 342:	00E3          	IDEPORTCTRL	EQU	0E3H		; 8255 configuration port
 343:			
 344:	0092          	READCFG8255	EQU	1T	EQU	IDECS0LINE + IDEA1LINE
 359:	000B          	REGSECTOR	EQU	IDECS0LINE + IDEA1LINE + IDEA0LINE
 360:	000C          	REGCYLLSB	EQU	IDECS0LINE + IDEA2LINE
 361:	000D          	REGCYLMSB	EQU	IDECS0LINE + IDEA2LINE + IDEA0LINE
 362:	000E          	REGSHD		EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE		;(0EH)
 363:	000F          	REGCOMMAND	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE	;(0FH)
 364:	000F          	REGSTATUS	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
 365:	0016          	REGCONTROL	EQU	I:	0017          	FDCSEEKC	EQU	00010111b	; seek cmd
 287:	0088          	FDCREADC	EQU	10001000b	; read cmd
 288:	00A8          	FDCWRITC	EQU	10101000b	; write cmd
 289:	00D0          	FDCRESET	EQU	11010000b	; fdc reset immediate cmd
 290:			;
 291:			; ---------------------------------------------------------------------
 292:			; LX389: PARALLEL INTERFACE
 293:			; ---------------------------------------------------------------------
 294:			; alternate printer port
 295:	0003          	ALTPRNPRT	EQU	03H
 2--------------------------------------------
 317:			; MULTF-BOARD: MMU, IDE, SERIAL, CTC
 318:			; ---------------------------------------------------------------------
 319:			; -- I/O --
 320:	0020          	MMUPORT		EQU	20H
 321:	0021          	MENAPRT		EQU	21H
 322:			; -- Map --
 323:	00C0          	EEPAGE0		EQU	0C0H		; page 0 of eeprom
 324:	F000          	EEPSTA		EQU	0F000H		; eeprom location after MMU reset
 325:	00EF          	MMTPAPAG	EQU	(EEPSTA>>8)-1	; TPA top page (256 bytes pages)
 326:	00FF 0010010b	; Set 8255 IDEportC to output, IDEportA/B input
 345:	0080          	WRITECFG8255	EQU	10000000b	; Set all three 8255 ports to output mode
 346:			;IDE control lines for use with IDEportC.
 347:	0001          	IDEA0LINE	EQU	01H		; direct from 8255 to IDE interface
 348:	0002          	IDEA1LINE	EQU	02H		; direct from 8255 to IDE interface
 349:	0004          	IDEA2LINE	EQU	04H		; direct from 8255 to IDE interface
 350:	0008          	IDECS0LINE	EQU	08H		; inverter between 8255 and IDE interface
 351DECS1LINE + IDEA2LINE + IDEA1LINE
 366:	0016          	REGASTATUS	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
 367:			;IDE Command Constants.
 368:	0010          	CMDRECAL	EQU	010H
 369:	0020          	CMDREAD		EQU	020H
 370:	0030          	CMDWRITE	EQU	030H
 371:	0091          	CMDINIT		EQU	091H
 372:	00EC          	CMDID		EQU	0ECH
 373:	00E0          	CMDSPINDOWN	EQU	0E0H
 374:	00E1          	CMDSPINUP	EQU	0E1H
 375:			; -- 16C550 UARTS --
 376:	00C0          	UART0BASE	EQU	0C0H		; Port base address for 0
 37796:			;
 297:			; parallel port PC link
 298:	0003          	PPDATAP		EQU	03H		; Data port
 299:	0002          	PPCNTRP		EQU	02H		; Control port
 300:	0000          	PPSTROB		EQU	0		; Strobe bit
 301:	0001          	PPAKSTB		EQU	1		; Acknowledge/Stop bit
 302:			;
 303:	0000          	PPDINI		EQU	00H		; 00000000 Dnl Init byte
 304:	0004          	PPDRDY		EQU	04H		; 00000100 Dnl Ready
 305:	0006          	PPDSTP		EQU	06H		; 00000110 Dnl Stop
 306:	0002          	PPDOKG		EQU	02H		; 00000010 Dnl Ok Go
 307:	00         	IMTPAG		EQU	0FFH		; eeprom page with image table
 327:	0400          	IMTSIZ		EQU	1024		; size
 328:	E000          	RAMTBL		EQU	0E000H		; ram table location
 329:	0030          	TBLBLK		EQU	48		; block size
 330:	0014          	MAXBLK		EQU	20		; max images
 331:	03C0          	RTBSIZ		EQU	TBLBLK * MAXBLK	; real table size
 332:								; A table block is:
 333:	0008          	TNAMELEN	EQU	8		;	name		: 8 bytes
 334:	0002          	TPAGELEN	EQU	2		;	page offset	: 2 bytes
 335:	0004          	TIADDRLE:	0010          	IDECS1LINE	EQU	10H		; inverter between 8255 and IDE interface
 352:	0020          	IDEWRLINE	EQU	20H		; inverter between 8255 and IDE interface
 353:	0040          	IDERDLINE	EQU	40H		; inverter between 8255 and IDE interface
 354:	0080          	IDERSTLINE	EQU	80H		; inverter between 8255 and IDE interface
 355:			;Symbolic constants for the IDE Drive registers
 356:	0008          	REGDATA		EQU	IDECS0LINE
 357:	0009          	REGERR		EQU	IDECS0LINE + IDEA0LINE
 358:	000A          	REGSECCN:	00C8          	UART1BASE	EQU	0C8H		; Port base address for 1
 378:	00C0          	UART0		EQU	UART0BASE	; Select UART 0
 379:	00C8          	UART1		EQU	UART1BASE	; Select UART 1
 380:	0000          	R0RXTX		EQU	0		; (r/w) RXD/TXD Transmit/Receive Buffer
 381:	0000          	R0BRDL		EQU	0		; (r/w) DLL  if bit 7 of LCR is set: Baud Rate Divisor LSB
 382:	0001          	R1IER		EQU	1		; (r/w) IER - Interrupt Enable Register
 383:	0001          	R1BRDM		EQU	1		; (r/w) DLM if bit 7 of LCR is set: Baud Rate Divis01          	UART115K2	EQU	01		; = 1,843,200 / ( 16 x 115,200 )
 400:			
 401:	0006          	U0DEFSPEED	EQU	UART19K2	; UART 0 default speed
 402:	000C          	U1DEFSPEED	EQU	UART9600	; UART 1 default speed
 403:			; -- Z80CTC --
 404:	00E8          	CTCBASE		EQU	0E8H
 405:	00E8          	CTCCHAN0	EQU	CTCBASE+0	; Channel 1 - Free
 406:	00E9          	CTCCHAN1	EQU	CTCBASE+1	; Channel 2 - System Timer
 407:	00EA          	CTCCHAN2	EQU	CTCBASE+2	; Channel 3 - UART 1 Interrupt
 408:	00EB          	CTCCHAN3	EQprom running inside it
 424:			
 425:			;
 426:			; MMU organization
 427:			;
 428:			; MMU manage 16 4kb pages in Z80 address space (logical)
 429:			; It can assign any of 256 4k pages (physical) from its
 430:			; 1Mb address space.
 431:			;
 432:			; To load phisycal page XXh to logical page (in CPU address space) Y,
 433:			; you should consider that MMU is at a fixed address 20h and that
 434:			; logical 4K page Y is derived in the MMU by the usage of A12,A13,A14
 435:			; and A15 address lines dur---------
 465:			; Production / Testing
 466:			
 467:	FFFF          	BBDEBUG	EQU	TRUE
 468:			
 469:			
 470:			;-------------------------------------
 471:			; Segments, pages locations
 472:			
 473:	FFFF          	IF	BBDEBUG
 474:			
 475:	0004          	BBIMGP	EQU	04H		; Image location (DEBUG)
 476:	000E          	BBAPPP	EQU	0EH
 477:	000F          	BBPAG	EQU	0FH		; Base page location
 478:			
 479:			ELSE
 485:			ENDIF
 486:			
 487:	000D          	TRNPAG	EQU	0DH		; Page used for transient MMU ops
 4or MSB
 384:	0002          	R2IIR		EQU	2		; (r)   IIR - Interrupt Identification Register
 385:	0002          	R2FCR		EQU	2		; (w)   FCR - FIFO Control Register
 386:	0003          	R3LCR		EQU	3		; (r/w) LCR - Line Control Register
 387:	0004          	R4MCR		EQU	4		; (r/w) MCR - Modem Control Register
 388:	0005          	R5LSR		EQU	5		; (r)   LSR - Line Status Register
 389:	0006          	R6MSR		EQU	6		; (r)   MSR - Modem Status Register
 390:	0007          	R7SPR		EQU	7		; (r/w) SPR - Scratch Pad RegistU	CTCBASE+3	; Channel 4 - UART 0 Interrupt
 409:	0020          	CTC0TCHI	EQU	32		; hi speed chan. 0 tc: 4Mhz / 256 / 32 = 488.28 Hz
 410:	0005          	CTC1TC100HZ	EQU	5		; lo speed chan. 1 tc: 488.28 Hz / 5 = ~ 97.6 Hz
 411:	000A          	CTC1TC50HZ	EQU	10		; lo speed chan. 1 tc: 488.28 Hz / 10 = ~ 48.8 Hz
 412:	0013          	CTC1TC25HZ	EQU	19		; lo speed chan. 1 tc: 488.28 Hz / 19 = ~ 25 Hz
 413:	0030          	CTC1TC10HZ	EQU	48		; lo speed chan. 1 tc: 488.28 Hz / 48 = ~ 10 Hz
 414:	00F4          	CTC1ing an I/O instruction.
 436:			;
 437:			; So to address phys. ram page 00h at the top of logical space page Fh
 438:			; you need to have Fh * on top address lines * because this address
 439:			; is the index to MMU page.
 440:			;
 441:			; So:
 442:			;
 443:			; 	LD	A,00h		<--- phis. page number	00xxxh (4k page)
 444:			; 	LD	B,F0h		<--- log. page number 	 Fxxxh (cpu page)
 445:			; 	LD	C,20h		<--- MMU I/O address
 446:			; 	OUT	(C),A
 447:			; 	RET
 448:			;
 449:			; The OUT instruction place:
 450:88:	F000          	BBBASE	EQU	BBPAG << 12	; non resident base address
 489:	FC00          	BBCOMN	EQU	BBBASE + 0C00H	; resident portion address
 490:			
 491:	F000          	SYSBASE EQU	BBBASE		; use this to have 60K TPA
 492:			; SYSBASE EQU	BBCOMN		; use this to have 63K TPA
 493:			
 494:			;-------------------------------------
**** srlr1.asm ****
   8:			
   9:	000A          	LF	EQU	0AH
  10:	000D          	CR	EQU	0DH
  11:	0008          	BS	EQU	08H		;Back space (required for sector display)
  12:	0007er
 391:				; speeds:
 392:	0060          	UART1200	EQU	96		; = 1,843,200 / ( 16 x 1200 )
 393:	0030          	UART2400	EQU	48		; = 1,843,200 / ( 16 x 2400 )
 394:	0018          	UART4800	EQU	24		; = 1,843,200 / ( 16 x 4800 )
 395:	000C          	UART9600	EQU	12		; = 1,843,200 / ( 16 x 9600 )
 396:	0006          	UART19K2	EQU	06		; = 1,843,200 / ( 16 x 19,200 )
 397:	0003          	UART38K4	EQU	03		; = 1,843,200 / ( 16 x 38,400 )
 398:	0002          	UART57K6	EQU	02		; = 1,843,200 / ( 16 x 57,600 )
 399:	00TC2HZ	EQU	244		; lo speed chan. 1 tc: 488.28 Hz / 244 = ~ 2 Hz
 415:	0013          	SYSHERTZ	EQU	CTC1TC25HZ	; System timer hertz
 416:			; -- EEPROM --
 417:	0001          	EEP29EE		EQU	01H		; type 29EE020
 418:	0002          	EEP29XE		EQU	02H		; type 29LE020 or 29VE020
 419:	0004          	EEP29C		EQU	04H		; type 29C020
 420:	0008          	EEPUNSUPP	EQU	08H		; unsupported
 421:	0010          	EEPROGLOCK	EQU	10H		; programming locked
 422:				;
 423:	0080          	EERINEPROM	EQU	80H		; tried to program ee			; A on data lines D0-D7
 451:			; Fh (from B register) on A12-A15
 452:			; on port 20h (C register)
 453:			;
 454:			;
 455:			; Memory is organized as follow:
 456:			;
 457:			;	Slot 1	-> RAM	  -> 512k from 00000h to 7ffffh (mandatory)
 458:			;	Slot 2	-> RAM	  -> 128k from 80000h to 9ffffh (option 1)
 459:			;	Slot 2	-> RAM    -> 256k from 80000h to bffffh (option 2)
 460:			;	Slot 3	-> EEPROM -> 256k from c0000h to fffffh (mandatory)
 461:			;
 462:			
 463:			
 464:			;----------------------------          	BELL	EQU	07H
  13:	0009          	TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
  14:	001B          	ESC	EQU	1BH
  15:	001C          	CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
  16:							;on other video cards)
  17:	0001          	RDCON	EQU	1		;For CP/M I/O
  18:	0002          	WRCON	EQU	2
  19:	0009          	PRINT	EQU	9
  20:	000B          	CONST	EQU	11		;CONSOLE STAT
  21:	0005          	BDOS	EQU	5
  22:			
  23:	0000          	FALSE	EQU	0
  24
  60:	012C  4F6B2E0D	MSINITOK	DB 'Ok.',CR,LF,'$'
	      0A24
  61:	0132  4661696C	MSINITNOK	DB 'Failure',CR,LF,'$'
	      7572650D
	      0A24
  62:			;
  63:			;-------------------------------------------------------------------------------
  64:			
  65:	013C          	SER_ON:		DS	1	; serial on/off
  66:	013D          	UART_FAIL:	DS	1	; UART has failed detection flag
  67:	013E          	SER_BAUD:	DS	1	; specify desired UART com rate in bps
  68:			
  69:				include uartctc.inc.asm
**** uartctc.inc.asm:				LD	C,A
  42:				IN	A,(C)
  43:				endm
  44:			
  45:			WRUREG	macro	uregister
  46:				LD	A,(SUART)
  47:				ADD	A,uregister
  48:				LD	C,A
  49:				OUT	(C),B
  50:				endm
  51:			
  52:			RDUREG	macro	uregister
  53:				LD	A,(SUART)
  54:				ADD	A,uregister
  55:				LD	C,A
  56:				IN	A,(C)
  57:				endm
  58:			
  59:			DESEQ	macro	p1,p2
  60:				LD	DE,[p1 << 8] + p2
  61:				endm
  62:			
  63:			; 	EXTERN	FSTAT, FOUT
  64:			
  65:			; ;;
  66:			; ;; Select UART for following operations
  67:			; or is defective
 105:	017D  C2CE01  		JP	NZ,INIUNOK
 106:			
 107:	0180  0680    		LD      B, $80
 108:	0182          		WRUREG	R3LCR			; enable baud rate divisor registers
 109:	018A  3ADB02  		LD	A,(SUART)		; initialize baud rate.
 110:	018D  FEC0    		CP	UART0			; which uart ?
 111:	018F  2006    		JR	NZ,INIU1
 112:	0191  3A2B00  		LD	A,(UART0BR)		; uart 0
 113:	0194  47      		LD	B,A
 114:	0195  1804    		JR	INIU2
 115:	0197  3A2A00  	INIU1:	LD	A,(UART1BR)		; uart 1
 116:	019A  47      		LD	B,A
 117:	24:	FFFF          	TRUE	EQU	-1
  25:			
  26:	0000          	QUIT	EQU	0
  27:			
  28:	0100          		ORG	$100
  29:			
  30:			; 	LD	A,U0DEFSPEED		; uart 0 init
  31:			; 	LD	(UART0BR),A
  32:			; 	CALL	INIUART0
  33:	0100  3E0C    		LD	A,UART9600		; uart 1 init
  34:	0102  322A00  		LD	(UART1BR),A
  35:	0105  CD4801  		CALL	INIUART1
  36:			
  37:			; 	LD	C,'@'
  38:			; TRASM:	CALL	TXCHAR0
  39:			; 	CALL	TXCHAR1
  40:			; 	CALL	BBCONOUT
  41:			; 	INC	C
  42:			; 	LD	A,C
  43:			; 	CP	'z'
  44:			; 	JR ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) Monitor
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; UARTS AND CTC management
   9:			; ---------------------------------------------------------------------
  10:			
  11:			
  12:	0000          	ANSIDRV	EQU	FALSE			; set TRUE to enable ANSI console driver
  13:			
  14:			;------- UARTS Section -	; ;;
  68:			; ;; A = Selected chip
  69:			; ;;
  70:			;
  71:			; SELUART:
  72:			; 	LD	(UARTSEL),A
  73:			; 	RET
  74:			
  75:			;;
  76:			;; Select UART for following operations
  77:			;;
  78:			;; A = Selected chip
  79:			;;
  80:			
  81:	013F          	INIUART0:
  82:	013F  3EC0    		LD	A,UART0
  83:	0141  32DB02  		LD	(SUART),A
  84:	0144  CD5101  		CALL	DOINIUART
  85:	0147  C9      		RET
  86:			
  87:	0148          	INIUART1:
  88:	0148  3EC8    		LD	A,UART1
  89:	014A  32DB02  		LD	(SUA019B          	INIU2:	WRUREG	R0BRDL			; write lsb divisor register
 118:	01A3  0600    		LD	B,$0
 119:	01A5          		WRUREG	R1BRDM			; write msb divisor register (alwyas 0 for us)
 120:			
 121:	01AD  0603    		LD	B,00000011B		; setup 8 bit, 1 stop, no parity
 122:								; 7 6 5 4 3 2 1 0
 123:								;             +------ 11 = 8 bit word length
 124:								;           +-------- 0 = 1 stop bit
 125:								;         +---------- 0 = no parity
 126:								;       +------------ 0 = odd parity (n/a)
 127:		NZ,TRASM
  45:			; 	LD	C,'@'
  46:			; 	JR	TRASM
  47:			
  48:	0108  CD0602  	RECE:	CALL	RXCHAR1
  49:	010B  FE03    		CP	3
  50:	010D  CA0000  		JP	Z,0
  51:	0110  4F      		LD	C,A
  52:	0111  CD9FFD  		CALL	BBCONOUT
  53:	0114  18F2    		JR	RECE
  54:			
  55:			
  56:			
  57:			;-------------------------------------------------------------------------------
  58:			
  59:	0116  496E6974	MSINIT		DB 'Initalising UART...',CR,LF,'$'
	      616C6973
	      696E6720
	      55415254
	      2E2E2E0D
	      0A--------
  15:			
  16:			
  17:			WRUREG0	macro	uregister
  18:				LD	A,UART0
  19:				ADD	A,uregister
  20:				LD	C,A
  21:				OUT	(C),B
  22:				endm
  23:			
  24:			RDUREG0	macro	uregister
  25:				LD	A,UART0
  26:				ADD	A,uregister
  27:				LD	C,A
  28:				IN	A,(C)
  29:				endm
  30:			
  31:			WRUREG1	macro	uregister
  32:				LD	A,UART1
  33:				ADD	A,uregister
  34:				LD	C,A
  35:				OUT	(C),B
  36:				endm
  37:			
  38:			RDUREG1	macro	uregister
  39:				LD	A,UART1
  40:				ADD	A,uregister
  41RT),A
  90:	014D  CD5101  		CALL	DOINIUART
  91:	0150  C9      		RET
  92:			
  93:	0151          	DOINIUART:
  94:	0151  C5      		PUSH	BC
  95:	0152  06AA    		LD	B,$AA
  96:	0154          		WRUREG	R7SPR
  97:	015C          		RDUREG	R7SPR
  98:	0164  FEAA    		CP	$AA			; test if you could store aa
  99:	0166  C2CE01  		JP	NZ,INIUNOK		; if not, the uart can't be found
 100:			
 101:	0169  0655    		LD	B,$55
 102:	016B          		WRUREG	R7SPR
 103:	0173          		RDUREG	R7SPR
 104:	017B  FE55    		CP	$55									;     +-------------- 0 = parity disabled (n/a)
 128:								;   +---------------- 0 = turn break off
 129:								; +------------------ 0 = disable divisor registers
 130:	01AF          		WRUREG	R3LCR
 131:	01B7  0607    		LD	B,00000111B		; 7 6 5 4 3 2 1 0
 132:								;               +---- 1 = enable FIFO and clear XMIT and RCVR FIFO queues
 133:								;             +------ 1 = clear RCVR FIFO
 134:								;           +-------- 1 = clear XMIT FIFO
 135:								;         +---------- 0 = RXRDY & TXR156:	01CF  3EFF    		LD	A,$FF
 157:	01D1  C9      		RET
 158:			
 159:			
 160:			;;
 161:			;; Sends a char over serial line 0
 162:			;;
 163:			;; C: output char
 164:			
 165:	FFFF          		IF NOT ANSIDRV
 166:	01D2          	TXCHAR0:
 167:				ELSE
 169:				ENDIF
 170:	01D2  79      		LD	A,C
 171:	01D3  C5      		PUSH	BC
 172:	01D4  F5      		PUSH	AF
 173:	01D5          	TXBUSY0:
 174:	01D5          		RDUREG0	R5LSR			; read status
 175:	01DC  CB6F    		BIT	5,A			; ready to send?
 176:	01DE  CAD501  		CB47    		BIT	0,A			; data available in rx buffer?
 214:	0210  28F5    		JR	Z,RXBUSY1		; loop until data is ready
 215:	0212          		RDUREG1	R0RXTX
 216:	0219  C1      		POP	BC
 217:	021A  C9      		RET
 218:			
 219:			;;
 220:			;; Receive a char from serial line 0
 221:			;;
 222:			;; A: return input char
 223:			
 224:	021B          	RXCHAR0:
 225:	021B  C5      		PUSH	BC
 226:	021C  DDE5    		PUSH	IX
 227:	021E  D5      		PUSH	DE
 228:	021F  E5      		PUSH	HL
 229:	0220  DD214B00		LD	IX,TMPBYTE
 23JR	Z,RXCHE1		; no
 258:	0255  FE61    		CP	'a'			; yes: is less then 'a' ?
 259:	0257  FA6102  		JP	M,RXCHE1		; yes: return, already ok
 260:	025A  FE7B    		CP	'{'			; no: then is greater than 'z' ?
 261:	025C  F26102  		JP	P,RXCHE1		; yes: do nothing
 262:	025F  CBAF    		RES	5,A			; no: convert uppercase...
 263:	0261          	RXCHE1:
 264:	FFFF          		IF 	NOT ANSIDRV
 265:	0261  E1      		POP	HL
 266:	0262  D1      		POP	DE
 267:	0263  DDE1    		POP	IX
 268:	0265  C1      		POP	BC
 269:	0266  C9   DY pins mode 0
 136:								;        +-------------- reserved (zero)
 137:								; +------------------ trigger level for FIFO interrupt
 138:								;	Bits      RCVR FIFO
 139:								;	 76     Trigger Level
 140:								;	 00        1 byte         <-- actually
 141:								;	 01        4 bytes
 142:								;	 10        8 bytes
 143:								;	 11       14 bytes
 144:	01B9          		WRUREG	R2FCR
 145:	01C1  0601    		LD	B,00000001B	        ; 7 6 5 4 3 2 1 0
 146:								;               +---- 1 = enable datJP	Z,TXBUSY0		; no, retry.
 177:	01E1  F1      		POP	AF
 178:	01E2  47      		LD	B,A
 179:	01E3          		WRUREG0	R0RXTX
 180:	01EA  C1      		POP	BC
 181:	01EB  C9      		RET
 182:			
 183:			;;
 184:			;; Sends a char over serial line 1
 185:			;;
 186:			;; C: output char
 187:			
 188:	01EC          	TXCHAR1:
 189:	01EC  79      		LD	A,C
 190:	01ED  C5      		PUSH	BC
 191:	01EE  F5      		PUSH	AF
 192:	01EF          	TXBUSY1:
 193:	01EF          		RDUREG1	R5LSR			; read status
 194:	01F6  CB6F    		BIT0:			
 231:	0000          		IF	ANSIDRV
 235:				ENDIF
 236:			
 237:	0224  DD7E00  	ESCNX:	LD	A,(IX)
 238:	0227  CB6F    		BIT	5,A			; test system interrupt status
 239:	0229  2014    		JR	NZ,RXCHAFIF		; enabled, uses queue
 240:	022B          	RXBUSY0:
 241:	022B          		RDUREG0	R5LSR			; read status
 242:	0232  CB47    		BIT	0,A			; data available in rx buffer?
 243:	0234  28F5    		JR	Z,RXBUSY0		; loop until data is ready
 244:	0236          		RDUREG0	R0RXTX
 245:	023D  180F    		JR	RXCHE
 246:	023F     		RET
 270:				ELSE
 412:				ENDIF
 413:			
 414:			
 415:			;;
 416:			;; Test UART status
 417:			;;
 418:			;; Returned flags:
 419:			;; RX status -> carry flag, TX status -> Z flag
 420:			;; C = 1: A character is available in the buffer.
 421:			;; Z = 1: A character can be sent.
 422:			
 423:			; USTATUS:
 424:			; 	PUSH	BC
 425:			; 	RDUREG	R5LSR			; read status
 426:			; 	RRCA                            ; rotate RX status into carry
 427:			; 	BIT     4, A                    ; check TX status (a available interrupt (and 16550 Timeout)
 147:								;             +------ 0 = disable Transmit Holding Register empty (THRE) interrupt
 148:								;           +-------- 0 = disable Receiver lines status interrupt
 149:								;         +---------- 0 = disable modem-status-change interrupt
 150:								; +------------------ reserved (zero)
 151:	01C3          		WRUREG	R1IER
 152:	01CB  C1      		POP	BC
 153:	01CC  AF      		XOR	A			; init ok
 154:	01CD  C9      		RET
 155:	01CE  C1      	INIUNOK:POP	BC
 	5,A			; ready to send?
 195:	01F8  CAEF01  		JP	Z,TXBUSY1		; no, retry.
 196:	01FB  F1      		POP	AF
 197:	01FC  47      		LD	B,A
 198:	01FD          		WRUREG1	R0RXTX
 199:	0204  C1      		POP	BC
 200:	0205  C9      		RET
 201:			
 202:			
 203:			
 204:			;;
 205:			;; Receive a char from serial line 1
 206:			;;
 207:			;; A: return input char
 208:			
 209:	0206          	RXCHAR1:
 210:	0206  C5      		PUSH	BC
 211:	0207          	RXBUSY1:
 212:	0207          		RDUREG1	R5LSR			; read status
 213:	020E          	RXCHAFIF:
 247:	023F  DD210F00		LD	IX,FIFOU0
 248:	0243          	RXCHAFLP:
 249:	0243  CDB5FD  		CALL	FSTAT			; queue status
 250:	0246  28FB    		JR	Z,RXCHAFLP		; loop until char is ready
 251:	0248  F3      		DI
 252:	0249  CDE1FD  		CALL	FOUT			; get a character from the queue
 253:	024C  FB      		EI
 254:	024D  79      		LD	A,C 			; and put it in correct register
 255:	024E  214C00  	RXCHE:	LD	HL,MIOBYTE
 256:	0251  CB5E    		BIT	3,(HL)			; yes: transform to uppercase ?
 257:	0253  280C    		after rot!)
 428:			; 	POP	BC
 429:			; 	RET
 430:			
 431:			;;
 432:			;; Test UART 0 status
 433:			;;
 434:			;; The code above is clearly better, BUT not suitable for BDOS
 435:			;; return codes...
 436:			;;
 437:			;; Returned value:
 438:			;; A =  0: No character in queue
 439:			;; A = FF: A character is available
 440:			
 441:	0267          	USTATUS0:
 442:	0267  3A4B00  		LD	A,(TMPBYTE)
 443:	026A  CB6F    		BIT	5,A			; test system interrupt status
 444:	026C  200F    		JR	NZ,USTAFIF		; enablePOP	BC
 474:	029A  2002    		JR	NZ,USTAT1
 475:	029C  AF      		XOR	A
 476:	029D  C9      		RET
 477:	029E  3EFF    	USTAT1:	LD	A,$FF
 478:	02A0  C9      		RET
 479:			
 480:			
 481:	0000          		IF ANSIDRV			; ANSI driver for serial console
 902:				ENDIF
 903:			
 904:			;------- CTC Section ---------
 905:			
 906:			; NOTE: system interrupts are not enabled here. Look at resident portion
 907:			;       of the BIOS
 908:			
 909:			;;
 910:			;; initialize Z80CTC
 911:			;;
 912:			
 913:	02A1      annel 2 - UART 1 interrupt handler
 937:	02B0  3ED7    		LD	A,11010111B		; 7 6 5 4 3 2 1 0
 938:								;               +---- 1 = command flag
 939:								;             +------ 1 = channel reset
 940:								;           +-------- 1 = time constant follow
 941:								;         +---------- 0 = n/a in counter mode
 942:								;       +------------ 1 = rise edge clock
 943:								;     +-------------- 0 = n/a in counter mode
 944:								;   +---------------- 1 = select counter mode
 945:								; +--------er/prescaler (feed channel 1)
 966:	02C1  3E27    		LD	A,00100111B		; 7 6 5 4 3 2 1 0
 967:								;               +---- 1 = command flag
 968:								;             +------ 1 = channel reset
 969:								;           +-------- 1 = time constant follow
 970:								;         +---------- 0 = start immediate
 971:								;       +------------ 0 = no trigger
 972:								;     +-------------- 1 = prescale 256
 973:								;   +---------------- 0 = select timer mode
 974:								; +------------------ 0 = disable d, uses queue
 445:	026E  C5      		PUSH	BC
 446:	026F          		RDUREG0	R5LSR			; read status
 447:	0276  CB47    		BIT	0,A			; data available in rx buffer?
 448:	0278  C1      		POP	BC
 449:	0279  2011    		JR	NZ,USTAT0
 450:	027B  AF      		XOR	A
 451:	027C  C9      		RET
 452:	027D          	USTAFIF:
 453:	027D  DDE5    		PUSH	IX
 454:	027F  DD210F00		LD	IX,FIFOU0
 455:	0283  CDB5FD  	USTAF1:	CALL	FSTAT			; check on the status of the queue
 456:	0286  DDE1    		POP	IX
 457:	0288  2002    		JR	NZ,USTAT0    	INICTC:
 914:				; First resets all four channels
 915:	02A1  CDCD02  		CALL	RESCTC
 916:			
 917:				; CTC interrupt vector
 918:	02A4  3EF0    		LD	A,$F0			; vec is at FFF0
 919:	02A6  D3E8    		OUT	(CTCCHAN0),A
 920:			
 921:				; Channel 3 - UART 0 interrupt handler
 922:	02A8  3ED7    		LD	A,11010111B		; 7 6 5 4 3 2 1 0
 923:								;               +---- 1 = command flag
 924:								;             +------ 1 = channel reset
 925:								;           +-------- 1 = time constant follow
 926:								; ---------- 1 = enable interrupts
 946:	02B2  D3EA    		OUT	(CTCCHAN2),A
 947:	02B4  3E01    		LD	A,1			; time constant set to 1. At first interrupt request
 948:								; form the UART will route it to the CPU
 949:	02B6  D3EA    		OUT	(CTCCHAN2),A
 950:			
 951:				; Channel 1 - lo speed system timer
 952:	02B8  3ED7    		LD	A,11010111B		; 7 6 5 4 3 2 1 0
 953:								;               +---- 1 = command flag
 954:								;             +------ 1 = channel reset
 955:								;           +-------- 1 = time consinterrupts
 975:	02C3  D3E8    		OUT	(CTCCHAN0),A
 976:	02C5  3A2900  		LD	A,(CTC0TC)			; time constant set to 32. 4Mhz / 256 / 32 = 488.28Hz
 977:	02C8  D3E8    		OUT	(CTCCHAN0),A
 978:			
 979:	02CA  C9      		RET				; all done
 980:			
 981:			;;
 982:			;;
 983:			;;
 984:	02CB          	CTCUNLCK:
 985:	02CB  ED4D    		RETI
 986:			
 987:			;;
 988:			;; Resets CTC
 989:			;;
 990:	02CD          	RESCTC:
 991:	02CD  CDCB02  		CALL	CTCUNLCK
 992:	02D0  3E03    		LD	A,00000011B		; 7 6 5 4 3 2 1 0
 993:					; return if z-flag set
 458:	028A  AF      		XOR	A
 459:	028B  C9      		RET
 460:	028C  3EFF    	USTAT0:	LD	A,$FF
 461:	028E  C9      		RET
 462:			
 463:			;; Test UART 1 status
 464:			;;
 465:			;; Returned value:
 466:			;; A =  0: No character in queue
 467:			;; A = FF: A character is available
 468:			
 469:	028F          	USTATUS1:
 470:	028F  C5      		PUSH	BC
 471:	0290          		RDUREG1	R5LSR			; read status
 472:	0297  CB47    		BIT	0,A			; data available in rx buffer?
 473:	0299  C1      		        +---------- 0 = n/a in counter mode
 927:								;       +------------ 1 = rise edge clock
 928:								;     +-------------- 0 = n/a in counter mode
 929:								;   +---------------- 1 = select counter mode
 930:								; +------------------ 1 = enable interrupts
 931:	02AA  D3EB    		OUT	(CTCCHAN3),A
 932:	02AC  3E01    		LD	A,1			; time constant set to 1. At first interrupt request
 933:								; form the UART will route it to the CPU
 934:	02AE  D3EB    		OUT	(CTCCHAN3),A
 935:			
 936:				; Chtant follow
 956:								;         +---------- 0 = n/a in counter mode
 957:								;       +------------ 1 = rise edge clock
 958:								;     +-------------- 0 = n/a in counter mode
 959:								;   +---------------- 1 = select counter mode
 960:								; +------------------ 1 = enable interrupts
 961:	02BA  D3E9    		OUT	(CTCCHAN1),A
 962:	02BC  3A2800  		LD	A,(CTC1TC)		; time constant for system timer (from 100 to 2 Hz)
 963:	02BF  D3E9    		OUT	(CTCCHAN1),A
 964:			
 965:				; Channel 0 - hi speed tim					;               +---- 1 = command flag
 994:								;             +------ 1 = channel reset
 995:								; +------------------ 0 = n/a
 996:	02D2  D3E8    		OUT	(CTCCHAN0),A
 997:	02D4  D3E9    		OUT	(CTCCHAN1),A
 998:	02D6  D3EA    		OUT	(CTCCHAN2),A
 999:	02D8  D3EB    		OUT	(CTCCHAN3),A
1000:	02DA  C9      		RET
1001:			; -----------
1002:			
1003:	02DB  00      	SUART:	DEFB	0
1004:			
1005:			; -----------
**** srlr1.asm ****
  70:				include crtc.inc.asm
**** crtc.inc.asm ****
   1:			;
   2:			;=0  		LD	(CURPBUF),HL
  28:	0304  1829    		JR	CRSLOC
  29:			
  30:			;;
  31:			;; INICRT
  32:			;
  33:	0306          	INICRT:
  34:								; initialize PIOs
  35:	0306  3E8F    		LD	A,$8F			; 10-00-1111 mode ctrl word
  36:								; Mode 2 (I/O port A)
  37:	0308  D382    		OUT	(CRTRAM0CNT),A
  38:	030A  D386    		OUT	(CRTRAM1CNT),A
  39:	030C  D38A    		OUT	(CRTRAM2CNT),A
  40:	030E  CD1403  		CALL	INI6545			; init 6545
  41:	0311  C3AD03  		JP	CRTPRGEND		; go on...
  42:			
  43:			
  44:			;;
  45:		033A          	GCRSPOS:
  81:	033A  3E0E    		LD	A,$0E
  82:	033C  D38C    		OUT	(CRT6545ADST),A
  83:	033E  DB8D    		IN	A,(CRT6545DATA)
  84:	0340  67      		LD	H,A
  85:	0341  3E0F    		LD	A,$0F
  86:	0343  D38C    		OUT	(CRT6545ADST),A
  87:	0345  DB8D    		IN	A,(CRT6545DATA)
  88:	0347  6F      		LD	L,A
  89:	0348  23      		INC	HL
  90:	0349  1862    		JR	CRTPRGEND
  91:			
  92:			;;
  93:			;; SET DISPLAY START ADDRESS
  94:			;
  95:	034B          	SDPYSTA:
  96:	034B  3E0C    		LD	A,$0C
  97:	034DD    		OUT	(CRT6545DATA),A
 132:	0373  3E13    		LD	A,$13
 133:	0375  D38C    		OUT	(CRT6545ADST),A
 134:	0377  7D      		LD	A,L
 135:	0378  D38D    		OUT	(CRT6545DATA),A
 136:	037A  1831    		JR	CRTPRGEND
 137:			
 138:			;;
 139:			;; DBLANK
 140:			;; fill video ram (2k) with 0's
 141:			;
 142:	037C          	DBLANK:
 143:	037C  210000  		LD	HL,$0000
 144:	037F  223B00  		LD	(RAM0BUF),HL
 145:	0382  AF      		XOR	A
 146:	0383  323D00  		LD	(RAM2BUF),A
 147:			;;
 148:			;; CRTFILL - Fill video ram with ======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) Monitor
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; CRTC
   9:			; SY6545A-1 and PIOs for video ram access on LX529
  10:			; ---------------------------------------------------------------------
  11:			
  12:			;; 6545 initialization string
  13:	02DC          	CRTTAB1:
  14:	02DC  6F505728		DB	$6F,$50,$57,$28,$1A,0,$19,	;; INI6545 - initialize sy6545
  46:			;;
  47:	0314          	INI6545:
  48:	0314  21DC02  		LD	HL,CRTTAB1	; now read from eprom
  49:	0317  0600    		LD	B,$00
  50:	0319  78      		LD	A,B
  51:	031A  D38C    	ICTLP0:	OUT    (CRT6545ADST),A
  52:	031C  7E      		LD	A,(HL)
  53:	031D  D38D    		OUT	(CRT6545DATA),A
  54:	031F  23      		INC	HL
  55:	0320  04      		INC	B
  56:	0321  78      		LD	A,B
  57:	0322  FE14    		CP	$14
  58:	0324  20F4    		JR	NZ,ICTLP0
  59:	0326  210000  		LD	HL,$0000
  60:	0329   D38C    		OUT	(CRT6545ADST),A
  98:	034F  7C      		LD	A,H
  99:	0350  D38D    		OUT	(CRT6545DATA),A
 100:	0352  3E0D    		LD	A,$0D
 101:	0354  D38C    		OUT	(CRT6545ADST),A
 102:	0356  7D      		LD	A,L
 103:	0357  D38D    		OUT	(CRT6545DATA),A
 104:	0359  1852    		JR	CRTPRGEND
 105:			
 106:			
 107:			;;
 108:			;; DISMVC display char and move cursor
 109:			;
 110:	035B          	DISMVC:
 111:	035B  CDCF03  		CALL	DISPCH
 112:			; 	JP	SCRSPOS
 113:			
 114:				; fall through...
 115:			;;
 116:			;; Sram buffer chrs
 149:			;
 150:	0386          	CRTFILL:
 151:	0386  3EEF    		LD	A,$EF
 152:	0388  323E00  		LD	(RAM3BUF),A
 153:	038B  210000  		LD	HL,$0000
 154:	038E  224800  		LD	(CURPBUF),HL
 155:	0391  CDA103  		CALL	RSTDPY
 156:	0394  E5      	CFIL1:	PUSH	HL
 157:	0395  CDB203  		CALL	DISPGR
 158:	0398  E1      		POP	HL
 159:	0399  23      		INC	HL
 160:	039A  7C      		LD	A,H
 161:	039B  FE08    		CP	$08
 162:	039D  20F5    		JR	NZ,CFIL1
 163:	039F  1800    		JR	RSTDPY
 164:			
 165:			;;
 166:			;;$19,$48,$0B
	      1A001919
	      480B
  15:	02E6  000B0000		DB	0,$0B,0,0,0,0,0,0,0,0
	      00000000
	      0000
  16:			
  17:			;;
  18:			;; CRTCINI - init buffers,6545,test vram,clear,leave cursor at home
  19:			;;
  20:	02F0          	CRTCINI:
  21:	02F0  CD0603  		CALL	INICRT
  22:	02F3  CD7C03  		CALL	DBLANK
  23:	02F6  CDF106  		CALL	GIOINI			; init remaing hardware on the board
  24:	02F9  3EFF    		LD	A,$FF
  25:	02FB  323E00  		LD	(RAM3BUF),A
  26:	02FE  210000  		LD	HL,$0000
  27:	0301  22480 224800  		LD	(CURPBUF),HL
  61:	032C  CD4B03  		CALL	SDPYSTA
  62:			; 	JP	CRSLOC
  63:			
  64:			;	fall through...
  65:			
  66:			;;
  67:			;; CRSLOC - init CRT cursor at CURPBUF
  68:			;
  69:	032F          	CRSLOC:
  70:	032F  2A4800  		LD	HL,(CURPBUF)
  71:	0332  CD5E03  		CALL	SCRSPOS
  72:	0335  AF      		XOR	A
  73:	0336  324F00  		LD	(COLBUF),A		; save cursor position
  74:	0339  C9      		RET
  75:			
  76:			
  77:			;;
  78:			;; GET DISPLAY CURSOR POSITION and return in HL
  79:			;
  80:	ET DISPLAY CURSOR ADDRESS EXTENDED
 117:			;;
 118:	035E          	SCRSPOS:
 119:	035E  3E0E    		LD	A,$0E
 120:	0360  D38C    		OUT	(CRT6545ADST),A
 121:	0362  7C      		LD	A,H
 122:	0363  D38D    		OUT	(CRT6545DATA),A
 123:	0365  3E0F    		LD	A,$0F
 124:	0367  D38C    		OUT	(CRT6545ADST),A
 125:	0369  7D      		LD	A,L
 126:	036A  D38D    		OUT	(CRT6545DATA),A
 127:	036C          	SCRSPOS1:
 128:	036C  3E12    		LD	A,$12
 129:	036E  D38C    		OUT	(CRT6545ADST),A
 130:	0370  7C      		LD	A,H
 131:	0371  D38 RSTDPY - zeroes SY6545 higher register (R12 to R19)
 167:			;;
 168:	03A1          	RSTDPY:
 169:	03A1  0608    		LD	B,$08
 170:	03A3  78      	RDPY1:	LD	A,B
 171:	03A4  C60B    		ADD	A,$0B
 172:	03A6  D38C    		OUT	(CRT6545ADST),A
 173:	03A8  AF      		XOR	A
 174:	03A9  D38D    		OUT	(CRT6545DATA),A
 175:	03AB  10F6    		DJNZ	RDPY1
 176:			; 	JP	CRTPRGEND
 177:			
 178:				; fall through...
 179:			
 180:			;;
 181:			;; CRTPRGEND
 182:			;; resets 6545 register pointer
 183:			;
 184:	03AD          	CRTP   		BIT	7,A
 218:	03D4  28FA    		JR	Z,DGCLP0
 219:	03D6  F1      		POP	AF
 220:	03D7  D380    		OUT	(CRTRAM0DAT),A
 221:	03D9  3A3E00  		LD	A,(RAM3BUF)
 222:	03DC  D38E    		OUT	(CRTRAM3PORT),A
 223:	03DE  AF      		XOR	A
 224:	03DF  D38D    		OUT	(CRT6545DATA),A
 225:	03E1  C9      		RET
 226:			
 227:			
 228:			;;
 229:			;; BCONOUT print out the char in reg C
 230:			;; with full evaluation of control chars
 231:			;;
 232:			;; register clean: can be used as CP/M BIOS replacement
 233:			;;
 234:	03E6    		BIT	6,(HL)			; auto ctrl chars ??
 262:	0407  280A    		JR	Z,COJP2			; no
 263:	0409  FE40    		CP	$40			; yes: convert
 264:	040B  3806    		JR	C,COJP2
 265:	040D  FE60    		CP	$60
 266:	040F  3002    		JR	NC,COJP2
 267:	0411  D640    		SUB	$40
 268:	0413  CDCF03  	COJP2:	CALL	DISPCH			; display char
 269:				; move cursor right
 270:	0416          	MOVRGT:
 271:	0416  CD3A03  		CALL	GCRSPOS			; update cursor position
 272:	0419  CD5E03  		CALL	SCRSPOS
 273:	041C  3A4F00  		LD	A,(COLBUF)
 274:	041F 		CP	$70			; greater then 80 ?
 300:	0442  D0      		RET	NC			; yes: error
 301:	0443  D620    		SUB	$20			; no: ok
 302:	0445  322D00  		LD	(APPBUF),A		; store column
 303:	0448  CBC6    		SET	0,(HL)			; switch row/col flag
 304:	044A  C9      		RET
 305:	044B  FE39    	SETROW:	CP	$39			; greater than 24 ?
 306:	044D  D0      		RET	NC			; yes: error
 307:	044E  D61F    		SUB	$1F			; no: ok
 308:	0450  CB86    		RES	0,(HL)			; resets flags
 309:	0452  214C00  		LD	HL,MIOBYTE
 310:	0455  CBBE    		RES	7,(HL)RGEND:
 185:	03AD  3E1F    		LD	A,$1F
 186:	03AF  D38C    		OUT	(CRT6545ADST),A
 187:	03B1  C9      		RET
 188:			
 189:			;;
 190:			;; DISPGR - display in graphic mode (raw output)
 191:			;
 192:	03B2          	DISPGR:
 193:	03B2  DB8C    		IN	A,(CRT6545ADST)
 194:	03B4  CB7F    		BIT	7,A
 195:	03B6  28FA    		JR	Z,DISPGR
 196:	03B8  213B00  		LD	HL,RAM0BUF
 197:	03BB  7E      		LD	A,(HL)
 198:	03BC  D380    		OUT	(CRTRAM0DAT),A
 199:	03BE  23      		INC	HL
 200:	03BF  7E      		LD	A,(HL)
 201:	03C0  D382          	BCONOUT:
 235:	03E2  F5      		PUSH	AF
 236:	03E3  C5      		PUSH	BC
 237:	03E4  D5      		PUSH	DE
 238:	03E5  E5      		PUSH	HL
 239:				; force jump to register restore and exit in stack
 240:	03E6  217104  		LD	HL,BCEXIT
 241:	03E9  E5      		PUSH	HL
 242:				;
 243:	03EA  79      		LD	A,C
 244:	03EB  214C00  		LD	HL,MIOBYTE
 245:	03EE  CB7E    		BIT	7,(HL)			; alternate char processing ?
 246:	03F0  EB      		EX	DE,HL
 247:	03F1  2035    		JR	NZ,CONOU2		; yes: do alternate
 248:	03F3  FE20   3C      		INC	A
 275:	0420  FE50    		CP	$50
 276:	0422  2852    		JR	Z,LFEED			; go down if needed
 277:			;;
 278:	0424          	SAVCOLB:
 279:	0424  324F00  		LD	(COLBUF),A		; save cursor position
 280:	0427  C9      		RET
 281:	0428          	CONOU2:					; alternate processing....
 282:	0428  FE20    		CP	$20			; is a ctrl char ??
 283:	042A  300D    		JR	NC,CURADR		; no: will set cursor pos
 284:	042C  87      		ADD	A,A			; yes
 285:	042D  2600    		LD	H,0
 286:	042F  6F      		LD	L,A
 287:	0430  01B			; done reset
 311:	0457  47      		LD	B,A
 312:	0458  21B0FF  		LD	HL,$FFB0
 313:	045B  115000  		LD	DE,$0050
 314:	045E  19      	CUROFS:	ADD	HL,DE			; calc. new offset
 315:	045F  10FD    		DJNZ	CUROFS
 316:	0461  3A2D00  		LD	A,(APPBUF)
 317:	0464  324F00  		LD	(COLBUF),A
 318:	0467  5F      		LD	E,A
 319:	0468  19      		ADD	HL,DE
 320:	0469  EB      		EX	DE,HL
 321:	046A  2A4800  		LD	HL,(CURPBUF)
 322:	046D  19      		ADD	HL,DE
 323:	046E  C35E03  		JP	SCRSPOS			; update position
 324:	0471        4    		OUT	(CRTRAM1DAT),A
 202:	03C2  23      		INC	HL
 203:	03C3  7E      		LD	A,(HL)
 204:	03C4  D388    		OUT	(CRTRAM2DAT),A
 205:	03C6  3A3E00  		LD	A,(RAM3BUF)
 206:	03C9  D38E    		OUT	(CRTRAM3PORT),A
 207:	03CB  AF      		XOR	A
 208:	03CC  D38D    		OUT	(CRT6545DATA),A
 209:	03CE  C9      		RET
 210:			
 211:			;;
 212:			;; DISPCH - Display in text mode (raw output)
 213:			;;
 214:	03CF          	DISPCH:
 215:	03CF  F5      		PUSH	AF
 216:	03D0  DB8C    	DGCLP0:	IN	A,(CRT6545ADST)
 217:	03D2  CB7F   		CP	$20			; no: is less then 0x20 (space) ?
 249:	03F5  300D    		JR	NC,COJP1		; no: go further
 250:	03F7  87      		ADD	A,A			; yes: is a special char
 251:	03F8  2600    		LD	H,0
 252:	03FA  6F      		LD	L,A
 253:	03FB  017106  		LD	BC,IOCVEC
 254:	03FE  09      		ADD	HL,BC
 255:	03FF  7E      		LD	A,(HL)
 256:	0400  23      		INC	HL
 257:	0401  66      		LD	H,(HL)
 258:	0402  6F      		LD	L,A
 259:	0403  E9      		JP	(HL)			; jump to IOCVEC handler
 260:	0404  EB      	COJP1:	EX	DE,HL
 261:	0405  CB7106  		LD	BC,IOCVEC2
 288:	0433  09      		ADD	HL,BC
 289:	0434  7E      		LD	A,(HL)
 290:	0435  23      		INC	HL
 291:	0436  66      		LD	H,(HL)
 292:	0437  6F      		LD	L,A
 293:	0438  E9      		JP	(HL)			; jump to service routine... (IOCVEC2)
 294:			;; cursor addressing service routine
 295:			;; address is ESC + (COL # + 32) + (ROW # + 32) (then need a NUL to terminate...)
 296:	0439  214B00  	CURADR:	LD	HL,TMPBYTE
 297:	043C  CB46    		BIT	0,(HL)
 298:	043E  200B    		JR	NZ,SETROW
 299:	0440  FE70      	BCEXIT:
 325:	0471  E1      		POP	HL
 326:	0472  D1      		POP	DE
 327:	0473  C1      		POP	BC
 328:	0474  F1      		POP	AF
 329:	0475  C9      		RET
 330:			;;
 331:			;; LFEED: down one line, scroll, home, clreol
 332:			;
 333:	0476          	LFEED:
 334:	0476  AF      		XOR	A
 335:	0477  324F00  		LD	(COLBUF),A
 336:	047A  CDB404  	LFEED1:	CALL	SCRTST
 337:	047D  D8      		RET	C
 338:	047E  214C00  		LD	HL,MIOBYTE
 339:	0481  CB56    		BIT	2,(HL)
 340:	0483  1130F8  		LD	DE,$F830
 341:	0486  CD3A03        		LD	A,L
 375:	04C0  FECF    		CP	$CF
 376:	04C2  C9      		RET
 377:			;;
 378:			;; CLRSCR - clear screen (ASCII mode)
 379:			;
 380:	04C3          	CLRSCR:
 381:	04C3  210000  		LD	HL,$0000
 382:	04C6  AF      		XOR	A
 383:	04C7  324F00  		LD	(COLBUF),A
 384:	04CA  2F      		CPL
 385:	04CB  323E00  		LD	(RAM3BUF),A
 386:	04CE  224800  		LD	(CURPBUF),HL
 387:	04D1  CD5E03  		CALL	SCRSPOS
 388:	04D4  CD4B03  		CALL	SDPYSTA
 389:	04D7  E5      		PUSH	HL
 390:	04D8  3E20    	CLSNC:	LD	A,$20
 391:	04DA		JR	CURSETMODE
 417:	04FF          	SCURON:
 418:			; 	LD	L,$0A           ; (0 00 01010) cursor on
 419:	04FF  1803    		JR	CURSET
 420:	0501          	CURSETMODE:
 421:	0501  E5      		PUSH	HL
 422:	0502  1805    		JR	CURSET1
 423:			
 424:			;;
 425:			;; Setup cursor. (user mode)
 426:			;;
 427:	0504          	CURSET:
 428:	0504  E5      		PUSH	HL
 429:	0505  3A4A00  		LD	A,(CURSSHP)
 430:	0508  6F      		LD	L,A
 431:	0509          	CURSET1:
 432:	0509  3E0A    		LD	A,$0A
 433:	050B  D38C    		OUT	(CRTR	NZ,MOVLFTDND		; set ND
 468:	0528  CD3705  		CALL	MOVLFTND		; destructive
 469:	052B  3E20    		LD	A,' '
 470:	052D  CDCF03  		CALL	DISPCH			; display char
 471:	0530  CD1604  		CALL	MOVRGT
 472:	0533  CD3705  		CALL	MOVLFTND
 473:	0536  C9      		RET
 474:			
 475:			;;
 476:			;; cursor left, non destructive only
 477:			;;
 478:	0537          	MOVLFTND:
 479:	0537  214C00  		LD	HL,MIOBYTE
 480:	053A  7E      		LD	A,(HL)
 481:	053B  F5      	MLFTND:	PUSH	AF
 482:	053C  CBE6    		SET	4,(HL)
 483:	053E  C		CALL	GCRSPOS
 342:	0489  2B      		DEC	HL
 343:	048A  2804    		JR	Z,MDJMP0
 344:	048C  19      		ADD	HL,DE
 345:	048D  C35E03  		JP	SCRSPOS
 346:	0490  E5      	MDJMP0:	PUSH	HL
 347:	0491  CD5606  		CALL	CLRLIN
 348:	0494  2A4800  		LD	HL,(CURPBUF)
 349:	0497  115000  		LD	DE,$0050
 350:	049A  19      		ADD	HL,DE
 351:	049B  112008  		LD	DE,$0820
 352:	049E  E5      		PUSH	HL
 353:	049F  ED52    		SBC	HL,DE
 354:	04A1  E1      		POP	HL
 355:	04A2  3802    		JR	C,MDJMP1
 356:	04A4  CB9C    		RES	3,H
 357:  CDCF03  		CALL	DISPCH
 392:	04DD  23      		INC	HL
 393:	04DE  7C      		LD	A,H
 394:	04DF  FE08    		CP	$08
 395:	04E1  20F5    		JR	NZ,CLSNC
 396:	04E3  E1      		POP	HL
 397:	04E4  C35E03  		JP	SCRSPOS
 398:			
 399:	04E7          	CURBLB:
 400:	04E7  2E40    		LD	L,$40           ; (0 10 00000) 1/16 blink scan 0
 401:	04E9  1816    		JR	CURSETMODE
 402:	04EB          	CURBLL:
 403:	04EB  2E4A    		LD	L,$4A           ; (0 10 01010) 1/16 blink scan 10
 404:	04ED  1812    		JR	CURSETMODE
 405:	04EF       6545ADST),A
 434:	050D  7D      		LD	A,L
 435:	050E  D38D    		OUT	(CRT6545DATA),A
 436:	0510  E1      		POP	HL
 437:	0511  C3AD03  		JP	CRTPRGEND
 438:			
 439:			;;
 440:			;; IOCNULL (a void routine) from here a list of routines to handle
 441:			;; console char output
 442:			;
 443:	0514          	IOCNULL:
 444:	0514  C9      		RET				; null entry. start of control routines vector
 445:								; for primary (non-escaped) mode
 446:			;
 447:	0515          	UCASEMOD:
 448:	0515  EB      		EX	DE,HL
 449:D4405  		CALL	MOVLFTDND
 484:	0541  F1      		POP	AF
 485:	0542  77      		LD	(HL),A
 486:	0543  C9      		RET
 487:			
 488:			;;
 489:			;; cursor left
 490:			;;
 491:	0544          	MOVLFTDND:
 492:	0544  CD3A03  		CALL	GCRSPOS
 493:	0547  2B      		DEC	HL
 494:	0548  ED5B4800		LD	DE,(CURPBUF)
 495:	054C  AF      		XOR	A
 496:	054D  ED52    		SBC	HL,DE
 497:	054F  BC      		CP	H
 498:	0550  2002    		JR	NZ,MOVLFT1
 499:	0552  BD      		CP	L
 500:	0553  C8      		RET	Z
 501:	0554          	MOVLFT1:
 502:	04A6  224800  	MDJMP1:	LD	(CURPBUF),HL
 358:	04A9  CD4B03  		CALL	SDPYSTA
 359:	04AC  E1      		POP	HL
 360:	04AD  3802    		JR	C,MEJP
 361:	04AF  CB9C    		RES	3,H
 362:	04B1  C35E03  	MEJP:	JP	SCRSPOS
 363:			
 364:			;;
 365:			;; SCRTST - Verify if we need video scroll
 366:			;
 367:	04B4          	SCRTST:
 368:	04B4  ED5B4800		LD	DE,(CURPBUF)
 369:	04B8  AF      		XOR	A
 370:	04B9  ED52    		SBC	HL,DE
 371:	04BB  7C      		LD	A,H
 372:	04BC  FE07    		CP	$07
 373:	04BE  D8      		RET	C
 374:	04BF  7D   	CURBFB:
 406:	04EF  2E60    		LD	L,$60           ; (0 11 00000) 1/32 blink scan 0
 407:	04F1  180E    		JR	CURSETMODE
 408:	04F3          	CURBFL:
 409:	04F3  2E6A    		LD	L,$6A           ; (0 11 01010) 1/32 blink scan 10
 410:	04F5  180A    		JR	CURSETMODE
 411:	04F7          	SCUROF:
 412:	04F7  2E20    		LD	L,$20           ; (0 01 00000) cursor off
 413:	04F9  1806    		JR	CURSETMODE
 414:	04FB          	CURFXB:
 415:	04FB  2E00    		LD	L,$00           ; (0 00 00000) fixed scan 0
 416:	04FD  1802    	0516  CBDE    		SET	3,(HL)
 450:	0518  C9      		RET
 451:	0519          	LCASEMOD:
 452:	0519  EB      		EX	DE,HL
 453:	051A  CB9E    		RES	3,(HL)
 454:	051C  C9      		RET
 455:			;;
 456:			;; SNDBEEP - sound beep
 457:	051D          	SNDBEEP:
 458:	051D  D38F    		OUT	(CRTBEEPPORT),A
 459:	051F  C9      		RET
 460:			;;
 461:			;; backspace
 462:			;;
 463:	0520          	BAKSPC:
 464:	0520  214C00  		LD	HL,MIOBYTE
 465:	0523  7E      		LD	A,(HL)
 466:	0524  CB66    		BIT	4,(HL)
 467:	0526  201C    		J	0554  2B      		DEC	HL
 503:	0555  19      		ADD	HL,DE
 504:	0556  CD5E03  		CALL	SCRSPOS
 505:	0559  E5      		PUSH	HL
 506:	055A  3A4F00  		LD	A,(COLBUF)
 507:	055D  3D      		DEC	A
 508:	055E  FEFF    		CP	$FF
 509:	0560  2002    		JR	NZ,MOVLFT2
 510:	0562  3E4F    		LD	A,$4F
 511:	0564          	MOVLFT2:
 512:	0564  324F00  		LD	(COLBUF),A
 513:	0567  214C00  		LD	HL,MIOBYTE
 514:	056A  CB66    		BIT	4,(HL)
 515:	056C  E1      		POP	HL
 516:	056D  C0      		RET	NZ
 517:	056E  3E20    		LD	A,$20
 518:	03  		CALL	GCRSPOS
 554:	059A  2B      		DEC	HL
 555:	059B  EB      		EX	DE,HL
 556:	059C  ED52    		SBC	HL,DE
 557:	059E  E5      		PUSH	HL
 558:	059F  C1      		POP	BC
 559:	05A0  CD5906  	CLRJ0:	CALL	CLRLIN1
 560:	05A3  EB      		EX	DE,HL
 561:	05A4  C35E03  		JP	SCRSPOS
 562:			;;
 563:			;; CLREOL - clear to end of line
 564:			;
 565:	05A7          	CLREOL:
 566:	05A7  3A4F00  		LD	A,(COLBUF)
 567:	05AA  47      		LD	B,A
 568:	05AB  3E50    		LD	A,$50
 569:	05AD  90      		SUB	B
 570:	05AE  0600    		L 19      		ADD	HL,DE
 605:	05D1  EB      		EX	DE,HL
 606:	05D2  2A4800  		LD	HL,(CURPBUF)
 607:	05D5  EB      		EX	DE,HL
 608:	05D6  AF      		XOR	A
 609:	05D7  ED52    		SBC	HL,DE
 610:	05D9  2F      		CPL
 611:	05DA  BC      		CP	H
 612:	05DB  19      		ADD	HL,DE
 613:	05DC  C8      		RET	Z
 614:	05DD  C35E03  		JP	SCRSPOS
 615:	05E0          	RASCFLTR:
 616:	05E0  EB      		EX	DE,HL
 617:	05E1  CBB6    		RES	6,(HL)
 618:	05E3  C9      		RET
 619:	05E4          	NDBKSP:
 620:	05E4  EB      		EX	DE,HL
 62154:	0615  C9      		RET
 655:	0616          	BLINKON:
 656:	0616  213E00  		LD	HL,RAM3BUF
 657:	0619  CB86    		RES	0,(HL)
 658:	061B  C9      		RET
 659:	061C          	REVON:
 660:	061C  213E00  		LD	HL,RAM3BUF
 661:	061F  CB8E    		RES	1,(HL)
 662:	0621  C9      		RET
 663:	0622          	UNDERON:
 664:	0622  213E00  		LD	HL,RAM3BUF
 665:	0625  CB96    		RES	2,(HL)
 666:	0627  C9      		RET
 667:	0628          	HLIGHTON:
 668:	0628  213E00  		LD	HL,RAM3BUF
 669:	062B  CB9E    		RES	3,(HL)
 670:	062D  C9 570  C35B03  		JP	DISMVC
 519:			; 	JP	DISPCH
 520:			;;
 521:			;; CHOME - move cursor at col 0
 522:			;
 523:	0573          	CHOME:
 524:	0573  214F00  		LD	HL,COLBUF
 525:	0576  5E      		LD	E,(HL)
 526:	0577  AF      		XOR	A
 527:	0578  77      		LD	(HL),A
 528:	0579  57      		LD	D,A
 529:	057A  CD3A03  		CALL	GCRSPOS
 530:	057D  2B      		DEC	HL
 531:	057E  ED52    		SBC	HL,DE
 532:	0580  CD5E03  		CALL	SCRSPOS
 533:	0583  C9      		RET
 534:			
 535:			;; IOCCR - handle carriage return (0x0d)
 536:	D	B,$00
 571:	05B0  4F      		LD	C,A
 572:	05B1  CD3A03  		CALL	GCRSPOS
 573:	05B4  2B      		DEC	HL
 574:	05B5  EB      		EX	DE,HL
 575:	05B6  18E8    		JR	CLRJ0
 576:			;;
 577:	05B8          	SCROLLOFF:
 578:	05B8  EB      		EX	DE,HL
 579:	05B9  CBD6    		SET	2,(HL)
 580:	05BB  C9      		RET
 581:	05BC          	SCROLLON:
 582:	05BC  EB      		EX	DE,HL
 583:	05BD  CB96    		RES	2,(HL)
 584:	05BF  C9      		RET
 585:	05C0          	SIOCESC:
 586:	05C0  EB      		EX	DE,HL
 587:	05C1  CBFE    		SET	7,(HL)
 :	05E5  CBE6    		SET	4,(HL)
 622:	05E7  C9      		RET
 623:	05E8          	DBKSP:
 624:	05E8  EB      		EX	DE,HL
 625:	05E9  CBA6    		RES	4,(HL)
 626:	05EB  C9      		RET
 627:	05EC          	BLINKOFF:
 628:	05EC  213E00  		LD	HL,RAM3BUF
 629:	05EF  CBC6    		SET	0,(HL)
 630:	05F1  C9      		RET
 631:	05F2          	REVOFF:
 632:	05F2  213E00  		LD	HL,RAM3BUF
 633:	05F5  CBCE    		SET	1,(HL)
 634:	05F7  C9      		RET
 635:	05F8          	UNDEROFF:
 636:	05F8  213E00  		LD	HL,RAM3BUF
 637:	05FB  CBD6    		     		RET
 671:	062E          	REDOFF:
 672:	062E  213E00  		LD	HL,RAM3BUF
 673:	0631  CBAE    		RES	5,(HL)
 674:	0633  C9      		RET
 675:	0634          	GREENOFF:
 676:	0634  213E00  		LD	HL,RAM3BUF
 677:	0637  CBB6    		RES	6,(HL)
 678:	0639  C9      		RET
 679:	063A          	BLUEOFF:
 680:	063A  213E00  		LD	HL,RAM3BUF
 681:	063D  CBBE    		RES	7,(HL)
 682:	063F  C9      		RET
 683:			;;
 684:			;; MOVDWN - cursor down one line
 685:			;
 686:	0640          	MOVDWN:
 687:	0640  CD3A03  		CALL	GCRSPOS
		;; should position the cursor at col 0
 537:			;
 538:	0584          	IOCCR:
 539:	0584  EB      		EX	DE,HL
 540:	0585  CB5E    		BIT	3,(HL)
 541:	0587  2803    		JR	Z,IOCCR1
 542:	0589  CDA705  		CALL	CLREOL
 543:	058C  18E5    	IOCCR1:	JR	CHOME
 544:			;;
 545:			;; clear to end of page
 546:			;;
 547:	058E          	CLREOP:
 548:	058E  AF      		XOR	A
 549:	058F  2A4800  		LD	HL,(CURPBUF)
 550:	0592  11D007  		LD	DE,$07D0
 551:	0595  19      		ADD	HL,DE
 552:	0596  EB      		EX	DE,HL
 553:	0597  CD3A0588:	05C3  C9      		RET
 589:			;;
 590:			;; RESATTR - reset all attributes
 591:			;
 592:	05C4          	RESATTR:
 593:	05C4  3EFF    		LD	A,$FF
 594:	05C6  323E00  		LD	(RAM3BUF),A
 595:	05C9  C9      		RET
 596:			
 597:			;;
 598:			;; IOCNULL (a void routine) from here a list of routines to handle
 599:			;; console char output while in alternate processing (ESC prefixed ctrl chars)
 600:			;
 601:	05CA          	MOVUP:
 602:	05CA  CD3A03  		CALL	GCRSPOS
 603:	05CD  11AFFF  		LD	DE,$FFAF
 604:	05D0 SET	2,(HL)
 638:	05FD  C9      		RET
 639:	05FE          	HLIGHTOFF:
 640:	05FE  213E00  		LD	HL,RAM3BUF
 641:	0601  CBDE    		SET	3,(HL)
 642:	0603  C9      		RET
 643:	0604          	REDON:
 644:	0604  213E00  		LD	HL,RAM3BUF
 645:	0607  CBEE    		SET	5,(HL)
 646:	0609  C9      		RET
 647:	060A          	GREENON:
 648:	060A  213E00  		LD	HL,RAM3BUF
 649:	060D  CBF6    		SET	6,(HL)
 650:	060F  C9      		RET
 651:	0610          	BLUEON:
 652:	0610  213E00  		LD	HL,RAM3BUF
 653:	0613  CBFE    		SET	7,(HL)
 6 688:	0643  2B      		DEC	HL
 689:	0644  115000  		LD	DE,$0050
 690:	0647  19      		ADD	HL,DE
 691:	0648  CD5E03  		CALL	SCRSPOS
 692:	064B  C37A04  		JP	LFEED1
 693:			;;
 694:	064E          	RIOCESC:
 695:	064E  EB      		EX	DE,HL
 696:	064F  CBBE    		RES	7,(HL)
 697:	0651  C9      		RET
 698:			;
 699:	0652          	SASCFLTR:
 700:	0652  EB      		EX	DE,HL
 701:	0653  CBF6    		SET	6,(HL)
 702:	0655  C9      		RET
 703:			
 704:			;;
 705:			;; CLRLIN - clear current line
 706:			;
 707:	0656         			; ENQ 0x05 (^E)  cursor on
 734:	067D  2F03    		DW	CRSLOC			; ACK 0x06 (^F)  locate cursor at CURPBUF
 735:	067F  1D05    		DW	SNDBEEP			; BEL 0x07 (^G)  beep
 736:	0681  2005    		DW	BAKSPC			; BS  0x08 (^H)  cursor left (destr. and non destr.)
 737:	0683  1405    		DW	IOCNULL			; HT  0x09 (^I)  no-op
 738:	0685  4006    		DW	MOVDWN			; LF  0x0a (^J)  cursor down one line
 739:	0687  7305    		DW	CHOME			; VT  0x0b (^K)  cursor @ column 0
 740:	0689  C304    		DW	CLRSCR			; FF  0x0c (^L)  page down (clng
 756:	06A9  1405    		DW	IOCNULL			; FS  0x1c (^\)  no-op
 757:	06AB  1405    		DW	IOCNULL			; GS  0x1d (^])  no-op
 758:	06AD  1405    		DW	IOCNULL			; RS  0x1e (^^)  disabled (no-op)
 759:	06AF  1405    		DW	IOCNULL			; US  0x1f (^_)  no-op
 760:			
 761:			;; This table define the offsets to jump to control routines
 762:			;; for alternate (escaped) mode
 763:			
 764:	06B1          	IOCVEC2:
 765:	06B1  4E06    		DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
 766:	06B3  EC05    		DD3  3406    		DW	GREENOFF		; DC1 0x11 (^Q)  res bit 6 RAM3BUF (green)
 783:	06D5  E704    		DW	CURBLB			; DC2 0x12 (^R)  cursor blink slow block
 784:	06D7  EB04    		DW	CURBLL			; DC3 0x13 (^S)  cursor blink slow line
 785:	06D9  1405    		DW	IOCNULL			; DC4 0x14 (^T)  no-op
 786:	06DB  1405    		DW	IOCNULL			; NAK 0x15 (^U)  no-op
 787:	06DD  1405    		DW	IOCNULL			; SYN 0x16 (^V)  no-op
 788:	06DF  5206    		DW	SASCFLTR		; ETB 0x17 (^W)  set ascii filter
 789:	06E1  E005    		DW	RASCFLTR		; CAN 0x18 (^X) 	CLRLIN:
 708:	0656  015000  		LD	BC,$0050
 709:	0659          	CLRLIN1:
 710:	0659  3A3E00  		LD	A,(RAM3BUF)
 711:	065C  F5      		PUSH	AF
 712:	065D  3EFF    		LD	A,$FF
 713:	065F  323E00  		LD	(RAM3BUF),A
 714:	0662  3E20    	CLRLP1:	LD	A,$20
 715:	0664  CDCF03  		CALL	DISPCH
 716:	0667  0B      		DEC	BC
 717:	0668  78      		LD	A,B
 718:	0669  B1      		OR	C
 719:	066A  20F6    		JR	NZ,CLRLP1
 720:	066C  F1      		POP	AF
 721:	066D  323E00  		LD	(RAM3BUF),A
 722:	0670  C9      		RET
 723:			
 724:			;;ear screen)
 741:	068B  8405    		DW	IOCCR			; CR  0x0d (^M)  provess CR
 742:	068D  8E05    		DW	CLREOP			; SO  0x0e (^N)  clear to EOP
 743:	068F  A705    		DW	CLREOL			; SI  0x0f (^O)  clear to EOL
 744:	0691  1405    		DW	IOCNULL			; DLE 0x10 (^P)  no-op
 745:	0693  C405    		DW	RESATTR			; DC1 0x11 (^Q)  reset all attributes
 746:	0695  F002    		DW	CRTCINI			; DC2 0x12 (^R)  hard crt reset and clear
 747:	0697  1405    		DW	IOCNULL			; DC3 0x13 (^S)  no-op
 748:	0699  1405    		DW	IOCNULL			; DC4 0x14W	BLINKOFF		; SOH 0x01 (^A)  BLINK OFF
 767:	06B5  1606    		DW	BLINKON			; STX 0x02 (^B)  BLINK ON
 768:	06B7  F805    		DW	UNDEROFF		; ETX 0x03 (^C)  UNDER OFF
 769:	06B9  2206    		DW	UNDERON			; EOT 0x04 (^D)  UNDER ON
 770:	06BB  FE05    		DW	HLIGHTOFF		; ENQ 0x05 (^E)  HLIGHT OFF
 771:	06BD  2806    		DW	HLIGHTON		; ACK 0x06 (^F)  HLIGHT ON
 772:	06BF  1405    		DW	IOCNULL			; BEL 0x07 (^G)  no-op
 773:	06C1  1405    		DW	IOCNULL			; BS  0x08 (^H)  no-op
 774:	06C3  1405    		DW	IOCNULL			; HT  0x09 (  reset ascii filter
 790:	06E3  E405    		DW	NDBKSP			; EM  0x19 (^Y)  set non destructive BS
 791:	06E5  E805    		DW	DBKSP			; SUB 0x1a (^Z)  set destructive BS
 792:	06E7  1C06    		DW	REVON			; ESC 0x1b (^[)  REVERSE ON
 793:	06E9  F205    		DW	REVOFF			; FS  0x1c (^\)  REVERSE OFF
 794:	06EB  1006    		DW	BLUEON			; GS  0x1d (^])  set bit 7 RAM3BUF (blue)
 795:	06ED  3A06    		DW	BLUEOFF			; RS  0x1e (^^)  res bit 7 RAM3BUF (blue)
 796:	06EF  1405    		DW	IOCNULL			; US  0x1f (^_)  no-op
 797:			
**** This table define the offsets to jump to control routines
 725:			;; for primary (non-escaped) mode
 726:			
 727:	0671          	IOCVEC:
 728:	0671  4E06    		DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
 729:	0673  1505    		DW	UCASEMOD		; SOH 0x01 (^A)  uppercase mode
 730:	0675  1905    		DW	LCASEMOD		; STX 0x02 (^B)  normal case mode
 731:	0677  1405    		DW	IOCNULL			; ETX 0x00 (^C)  no-op
 732:	0679  F704    		DW	SCUROF			; EOT 0x04 (^D)  cursor off
 733:	067B  FF04    		DW	SCURON (^T)  no-op
 749:	069B  CA05    		DW	MOVUP			; NAK 0x15 (^U)  cursor up one line
 750:	069D  B805    		DW	SCROLLOFF		; SYN 0x16 (^V)  scroll off
 751:	069F  BC05    		DW	SCROLLON		; ETB 0x17 (^W)  scroll on
 752:	06A1  3705    		DW	MOVLFTND		; CAN 0x18 (^X)  cursor left (non destr. only)
 753:	06A3  1604    		DW	MOVRGT			; EM  0x19 (^Y)  cursor right
 754:	06A5  4006    		DW	MOVDWN			; SUB 0x1a (^Z)  cursor down one line
 755:	06A7  C005    		DW	SIOCESC			; ESC 0x1b (^[)  activate alternate output processi^I)  no-op
 775:	06C5  1405    		DW	IOCNULL			; LF  0x0a (^J)  no-op
 776:	06C7  1405    		DW	IOCNULL			; VT  0x0b (^K)  no-op
 777:	06C9  7C03    		DW	DBLANK			; FF  0x0c (^L)  blank screen
 778:	06CB  4E06    		DW	RIOCESC			; CR  0x0d (^M)  clear alternate output processing
 779:	06CD  0406    		DW	REDON			; SO  0x0e (^N)  set bit 5 RAM3BUF (red)
 780:	06CF  2E06    		DW	REDOFF			; SI  0x0f (^O)  res bit 5 RAM3BUF (red)
 781:	06D1  0A06    		DW	GREENON			; DLE 0x10 (^P)  set bit 6 RAM3BUF (green)
 782:	06 srlr1.asm ****
  71:				include genio.inc.asm
**** genio.inc.asm ****
   1:			;
   2:			;=======================================================================
   3:			;
   4:			; Modular Z80 DarkStar (NE Z80) Monitor
   5:			;
   6:			;=======================================================================
   7:			;
   8:			; Generic I/O ports
   9:			; ---------------------------------------------------------------------
  10:			
  11:	06F1          	GIOINI:
  12:	06F1  3ECF    		LD	A,$CF			; 11-00-1111clock line)
  32:								;          ||------- b6 in  (ds1320 i/o line)
  33:								;          |-------- b7 out (ds1320 RST line)
  34:	0705  D38B    		OUT	(CRTSERVCNT),A		; send to PIO2
  35:	0707  DB89    		IN	A,(CRTSERVDAT)		; read data port PIO2
  36:	0709  CBBF    		RES	CLKRST,A		; ensure DS1320 RST line is low (active)
  37:	070B  CB8F    		RES	1,A			; Modo 40/80 colonne (80)
  38:	070D  D389    		OUT	(CRTSERVDAT),A		; send to PIO2
  39:	070F  C9      		RET
  40:			
  41:			;;
  42:			;; PRNCHR - sendc+    curset           504     r2fcr          =   2     
bbcomn         =fc00+    curset1          509     r2iir          =   2+    
bbconin        =fd94+    cursetmode       501     r3lcr          =   3     
bbconout       =fd9f     cursoroff      =  20+    r4mcr          =   4+    
bbconst        =fdaa+    cursoron       =   a+    r5lsr          =   5     
bbcpboot       =fcc3+    cursshp        =  4a     r6msr          =   6+    
bbcrtcini      =fc03+    dbksp            5e8     r7spr          =   7          =   1+    redoff           62e     
bbflopio       =fc93+    eep29xe        =   2+    redon            604     
bbfread        =fc87+    eepage0        =  c0+    regastatus     =  16+    
bbfwrite       =fc8d+    eeproglock     =  10+    regcommand     =   f+    
bbhdboot       =fd0b+    eepsta         =f000     regcontrol     =  16+    
bbhdgeo        =fd05+    eepunsupp      =   8+    regcyllsb      =   c+    
bbhdinit       =fced+    eerineprom     =  80+    regcylmsb      =   d+    
bbhdrd          mode ctrl word
  13:								; Mode 3 (bit mode port B)
  14:	06F3  D383    		OUT	(CRTPRNTCNT),A		; send to PIO0
  15:	06F5  08      		EX	AF,AF'
  16:	06F6  AF      		XOR	A			; bit mask 00000000 (all outputs)
  17:	06F7  D383    		OUT	(CRTPRNTCNT),A		; send to PIO0
  18:	06F9  08      		EX	AF,AF'			; reload mode 3 ctrl word
  19:	06FA  D387    		OUT	(CRTKEYBCNT),A		; send to PIO1
  20:	06FC  08      		EX	AF,AF'
  21:	06FD  3D      		DEC	A			; load bit mask 11111111 (all inputs)
  22:	06FE  D387    		OUT	(CR a char to printer port (from C)
  43:			;
  44:	0710          	PRNCHR:
  45:	0710  DB89    		IN	A,(CRTSERVDAT) 
  46:	0712  CB47    		BIT	PRNTBUSYBIT,A
  47:	0714  20FA    		JR	NZ,PRNCHR
  48:	0716  79      		LD	A,C
  49:	0717  D381    		OUT	(CRTPRNTDAT),A
  50:	0719  C9      		RET
  51:			
**** srlr1.asm ****
  72:			
  73:	071A          		END



Statistics:

   532	symbols
  1559	bytes

    20	macro calls
   325	macro bytes
     0	invented symbols



Symbol Table:

altprnprt      =   3+    curbfb        
bbcrtfill      =fc09+    dblank           37c     ram0buf        =  3b     
bbcstck        =   d+    delay          =fd85+    ram1buf        =  3c     
bbcurset       =fc21+    deseq            127+    ram2buf        =  3d     
bbdebug        =ffff     dgclp0           3d0     ram3buf        =  3e     
bbdiv16        =fcdb+    dismvc           35b     ramtbl         =e000+    
bbdmaset       =fcb7+    dispch           3cf     rascfltr         5e0     
bbdprmset      =fd17+    dispgr           3b2     rdcon=fcff+    esc            =  1b+    regdata        =   8+    
bbhdwr         =fcf9+    escnx            224+    regerr         =   9+    
bbimgp         =   4+    false          =   0     regseccnt      =   a+    
bbinictc       =fc57+    fdcbase        =  d0     regsector      =   b+    
bbjtobnk       =fc00+    fdccmdstatr    =  d0+    regshd         =   e+    
bbldpart       =fd11+    fdcdatareg     =  d7+    regstatus      =   f+    
bbmul16        =fce1+    fdcdrvrcnt     =  d6+    resattr          5c4 TKEYBCNT),A		; send to PIO1
  23:	0700  08      		EX	AF,AF'
  24:	0701  D38B    		OUT	(CRTSERVCNT),A		; reload mode 3 ctrl word
  25:	0703  3E5D    		LD	A,$5D			; bit mask 01011101
  26:								;          ||||||||- b0 in  (printer busy line)
  27:								;          |||||||-- b1 out (40/80 col. mode)
  28:								;          ||||||--- b2 in  (unassigned)
  29:								;          |||||---- b3 in  (unassigned)
  30:								;          ||||----- b4 in  (unassigned)
  31:								;          ||------- b5 out (ds1320    4ef+    prntbusybit    =   0     
ansidrv        =   0     curbfl           4f3+    prvtop         =  4f     
appbuf         =  2d     curblb           4e7     quit           =   0+    
bakspc           520     curbll           4eb     r0brdl         =   0     
bbappp         =   e+    curfxb           4fb+    r0rxtx         =   0     
bbbase         =f000     curofs           45e     r1brdm         =   1     
bbcalret       =fd5a+    curpbuf        =  48     r1ier          =   1     
bbcbank        =             =   1+    
bbdriveid      =fcf3+    dly1           =fd89+    rdpy1            3a3     
bbdsksel       =fcbd+    dly2           =fd87+    rdureg            f5     
bbeidck        =fd23+    doiniuart        151     rdureg0           31     
bbepmngr       =fd1d+    dostx          =fe81+    rdureg1           92     
bbexec         =fd29+    dselbf         =  4e     readcfg8255    =  92+    
bbfdrvsel      =fcd5+    eep29c         =   4+    rece             108     
bbfhome        =fc81+    eep29ee       
bboffcal       =fce7+    fdcreadc       =  88+    resctc           2cd     
bbpag          =   f     fdcreset       =  d0+    revoff           5f2     
bbprcvblk      =fc6f+    fdcrestc       =   7+    revon            61c     
bbprnchr       =fc99+    fdcsectreg     =  d2+    riocesc          64e     
bbpsndblk      =fc63+    fdcseekc       =  17+    rldrom         =fe97+    
bbrdtime       =fca5+    fdctrakreg     =  d1+    rsrvbuf        =  2f     
bbrdvdsk       =fc75+    fdcwritc       =  a8+    r    =fcc9+    fsekbuf        =  3f     savcolb          424+    
bbvoid         =fd6a+    fstat          =fdb5     sconin         =fc2d+    
bbwrvdsk       =fc7b+    ftrkbuf        =  46     sconout        =fc27+    
bcexit           471     gcrspos          33a     sconst         =fc33+    
bconout          3e2+    gioini           6f1     scrolloff        5b8     
bdos           =   5+    greenoff         634     scrollon         5bc     
bell           =   7+    greenon          60a     scrspos          erdline      =  40+    suart            2db     
clear          =  1c+    iderstline     =  80+    sysbase        =f000+    
clkio          =   6+    idewrline      =  20+    syscmlo        =fed2+    
clkrst         =   7     imtpag         =  ff+    syscom         =fc00+    
clksclk        =   5+    imtsiz         = 400+    syshertz       =  13+    
clreol           5a7     ini6545          314     sytimr         =fe19+    
clreop           58e     inicrt           306     tab            =   9+    
clrj0  b1     txbusy0          1d5     
cojp1            404     kbdbyte        =  4d     txbusy1          1ef     
cojp2            413     keybstrbbit    =   7+    txchar0          1d2+    
colbuf         =  4f     lcasemod         519     txchar1          1ec+    
conou2           428     lf             =   a     u0defspeed     =   6+    
const          =   b+    lfeed            476     u0isr          =fe25+    
copsys         =  2c     lfeed1           47a     u1defspeed     =   c+    
cr             =   d   st7sp1        =  38     
bbresctc       =fc5d+    fdrvbuf        =  45     rst7sp2        =  39+    
bbsecset       =fcb1+    ff             =   c+    rst7sp3        =  3a+    
bbsidset       =fccf+    fifblok        =   b     rstdpy           3a1     
bbstack        =fed2+    fifoend        =  25+    rtbsiz         = 3c0+    
bbstbase       =feae+    fifokb         =  1a     rxbusy0          22b     
bbsttim        =fc9f+    fifosto        =   f     rxbusy1          207     
bbtrkset       =fcab+    fifou035e     
bldoffs        =3000+    hlightoff        5fe     scrspos1         36c+    
blifastblok    =  60+    hlighton         628     scrtst           4b4     
blifastline    =  6a+    hmempag        =   b+    scurof           4f7     
blinkoff         5ec     ictlp0           31a     scuron           4ff     
blinkon          616     idea0line      =   1     sdpysta          34b     
blislowblok    =  40+    idea1line      =   2     ser_baud         13e+    
blislowline    =  4a+    idea2line      =   4            5a0     inictc           2a1+    tblblk         =  30     
clrlin           656     iniu1            197     tdesclen       =  14+    
clrlin1          659     iniu2            19b     tiaddrlen      =   4+    
clrlp1           662     iniuart0         13f+    timrcon        =  27     
clrscr           4c3     iniuart1         148     tmpbyte        =  4b     
clsnc            4d8     iniunok          1ce     tnamelen       =   8+    
cmdid          =  ec+    intrdi         =fe0f+    tpa            maxblk         =  14     u1isr          =fe5b+    
crdureg        =fc27+    mdjmp0           490     u1nul          =fe72+    
crsloc           32f     mdjmp1           4a6     uart0          =  c0     
crt6545adst    =  8c     mejp             4b1     uart0base      =  c0     
crt6545data    =  8d     menaprt        =  21+    uart0br        =  2b     
crtbase        =  80     miobyte        =  4c     uart1          =  c8     
crtbeepport    =  8f     mlftnd           53b+    uart115k2      =   1+    
crt         =   f     rxchafif         23f     
bbu0ini        =fc39+    fifsize        =   8+    rxchaflp         243     
bbu1ini        =fc51+    fin            =fdc4+    rxchar0          21b+    
bbu1rx         =fc45+    fixblock       =   0+    rxchar1          206     
bbu1st         =fc4b+    fout           =fde1     rxche            24e     
bbu1tx         =fc3f+    frdpbuf        =  41     rxche1           261     
bbuplchr       =fc69+    fsecbuf        =  43     sascfltr         652     
bbvcpmbt      ser_on           13c+    
blueoff          63a     idecs0line     =   8     setrow           44b     
blueon           610     idecs1line     =  10     sintvec        =fff0+    
bs             =   8+    ideporta       =  e0+    siocesc          5c0     
btpasiz        =   6+    ideportb       =  e1+    sndbeep          51d     
cdisk          =   4+    ideportc       =  e2+    srxrsm         =fe7f+    
cfil1            394     ideportctrl    =  e3+    srxstp         =fe7b+    
chome            573     id  = 100+    
cmdinit        =  91+    intren         =fdfe+    tpagelen       =   2+    
cmdread        =  20+    iobyte         =   3+    trnpag         =   d+    
cmdrecal       =  10+    ioccr            584     true           =ffff     
cmdspindown    =  e0+    ioccr1           58c     tsizelen       =   4+    
cmdspinup      =  e1+    iocnull          514     tx0            =fe89+    
cmdwrite       =  30+    iocvec           671     tx01           =fe8b+    
cnfbyte        =  26+    iocvec2          6blinkbit    =   0+    mmgetp         =fd78+    uart1200       =  60+    
crtcini          2f0     mmpmap         =fd6b+    uart19k2       =   6     
crtfill          386+    mmtpapag       =  ef+    uart1base      =  c8     
crthilitbit    =   3+    mmuport        =  20+    uart1br        =  2a     
crtkeybcnt     =  87     mmutstaddr     =d000+    uart2400       =  30+    
crtkeybdat     =  85+    mmutstpage     =   d     uart38k4       =   3+    
crtmodebit     =   4+    monmaj         =  33+    uart4800 c     ndbksp           5e4     ustat1           29e     
crtunderbit    =   2+    pio2bit2       =   2+    ustatus0         267+    
crtwidthbit    =   1+    pio2bit3       =   3+    ustatus1         28f+    
ctc0tc         =  29     pio2bit4       =   4+    vconin         =fc15+    
ctc0tchi       =  20+    ppakstb        =   1+    vconout        =fc0f+    
ctc1tc         =  28     ppcntrp        =   2+    vconst         =fc1b+    
ctc1tc100hz    =   5+    ppdatap        =   3+    vdbufsz        =   a+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
;;
;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
;;


SRL1BASE	EQU	$C0
SRL2BASE	EQU	$C8

; UART 16C550 1

UART0		EQU	SRL1BASE+0	; DATA IN/OUT
UART1		EQU	SRL1BASE+1	; CHECK RX
UART2		EQU	SRL1BASE+2	; INTERRUPTS
UART3		EQU	SRL1BASE+3	; LINE CONTROL
UART4		EQU	SRL1BASE+4	; MODEM CONTROL
UART5		EQU	SRL1BASE+5	; LINE STATUS
UART6		EQU	SRL1BASE+6	; MODEM STATUS
UART7		EQU	SRL1BASE+7	; SCRATCH REG.

; UART 16C550 2

; UART0		EQU	SRL2BASE+0	; DATA IN/OUT
; UART1		EQU	SRL2BASE+1	; CHECK RX
; UART2		EQU	SRL      =  18+    
crtprgend        3ad     monmin         =  34+    uart57k6       =   2+    
crtprntcnt     =  83     movdwn           640     uart9600       =   c     
crtprntdat     =  81     movlft1          554     uart_fail        13d+    
crtram0cnt     =  82     movlft2          564     uastav         =fea2+    
crtram0dat     =  80     movlftdnd        544     uastkb         =fea4+    
crtram1cnt     =  86     movlftnd         537     ucasemod         515     
crtram1dat     =  84     movrgt        
ctc1tc10hz     =  30+    ppdini         =   0+    vdrdsec        =   0+    
ctc1tc25hz     =  13     ppdokg         =   2+    vdwrsec        =   1+    
ctc1tc2hz      =  f4+    ppdrdy         =   4+    voidisr        =fe22+    
ctc1tc50hz     =   a+    ppdstp         =   6+    wrcon          =   2+    
ctcbase        =  e8     ppstrob        =   0+    writecfg8255   =  80+    
ctcchan0       =  e8     ppuack         =   7+    wrureg            c2     
ctcchan1       =  e9     ppuini         =   1+    wrure                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                2BASE+2	; INTERRUPTS
; UART3		EQU	SRL2BASE+3	; LINE CONTROL
; UART4		EQU	SRL2BASE+4	; MODEM CONTROL
; UART5		EQU	SRL2BASE+5	; LINE STATUS
; UART6		EQU	SRL2BASE+6	; MODEM STATUS
; UART7		EQU	SRL2BASE+7	; SCRATCH REG.



LF	EQU	0AH
CR	EQU	0DH
BS	EQU	08H		;Back space (required for sector display)
BELL	EQU	07H
TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
ESC	EQU	1BH
CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
				;on other video cards)
RDCON	EQU	1		;For CP/M I/O   416     uisre          =fe50+    
crtram2cnt     =  8a     movup            5ca     uisri          =fe35+    
crtram2dat     =  88     mscnt          =  f6+    underoff         5f8     
crtram3port    =  8e     msinit           116+    underon          622     
crtrevrsbit    =   1+    msinitnok        132+    ustaf1           283+    
crtservcnt     =  8b     msinitok         12c+    ustafif          27d     
crtservdat     =  89     mzmac          =   1+    ustat0           28c     
crttab1          2dg0            0     
ctcchan2       =  ea     ppuokg         =   3+    wrureg1           61     
ctcchan3       =  eb     ppurdy         =   5+    xofc           =  13+    
ctcunlck         2cb     print          =   9+    xonc           =  11+    
curadr           439     prnchr           710     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
WRCON	EQU	2
PRINT	EQU	9
CONST	EQU	11		;CONSOLE STAT
BDOS	EQU	5

FALSE	EQU	0
TRUE	EQU	-1

QUIT	EQU	0

	ORG	$100

INITIALIZE:

; initialize UART related functions and variables

	LD	A,0
	LD	(SER_ON),A	; Initialize "Serial On" flag
				; assume it is off until UART
				; is autodetected
	LD	A,1
	LD	(UART_FAIL),A	; Initialize "UART FAIL" flag
				; assume it has failed until UART
				; is autodetected as working

	LD	DE,MSINIT
	CALL	PSTRING

; 	LD	A,$01		; specify baud rate 1200 bps (1200,8,None,1)
	LD	A,$05		:
;	PUSH	AF
RX_BUSYLP:
	IN	A,(UART5)		; READ Line Status Register
	BIT	0,A			; TEST IF DATA IN RECEIVE BUFFER
	JP	Z,RX_BUSYLP		; LOOP UNTIL DATA IS READY
	IN	A,(UART0)		; THEN READ THE CHAR FROM THE UART
;	LD	B,A			; put received data character in B
					; register and pass back to user
RX_END_CHAR:
	RET

;*******************************************************
;*	MESSAGE PRINT ROUTINE
;*******************************************************

TMSG:
;TX_SER:
;	PUSH	AF
;	LD	A,(SER_ON)		; IF COM IS OFF
;	CP	0	,A
	JP	UART_OK

INITUART_FAIL:				; Handle if initialize UART fails
	LD	A,1
	LD	(UART_FAIL),A
	HALT


UART_OK:
	LD	A,0
	LD	(UART_FAIL),A		; UART OK FOUND
	LD	A,(SER_BAUD)
	CP	1
	JP	Z,UART1200
	CP	2
	JP	Z,UART2400
	CP	3
	JP	Z,UART4800
	CP	4
	JP	Z,UART9600
	CP	5
	JP	Z,UART19K2
	CP	6
	JP	Z,UART38K4
	CP	7
	JP	Z,UART57K6
	CP	8
	JP	Z,UART115K2
					; IF NOTHING IS DEFINED 1200 WILL BE USED..


UART1200:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,96			;  = 1,843,200 / ( 16 x 1200 )
	OUT	(UART0),A		;
	LD	A,00H		;
	LD	A,0
	OUT	(UART1),A		;
	LD	A,3
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART38K4:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,03
	OUT	(UART0),A		; = 1,843,200 / ( 16 x 38,400 )
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART57K6:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,02
	OUT	(UART0),A		; = 1,843,200 / ( 16 x 57,600 )
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART; specify baud rate 9600 bps (9600,8,None,1)
	LD	(SER_BAUD),A	;
	CALL	INIT_UART	; WITH NO FLOW CONTROL on terminal!!

	LD	A,(UART_FAIL)
	OR	A
	JR	Z,PNT1

	LD	DE,MSINITNOK
	CALL	PSTRING
	JP	QUIT

PNT1:
	LD	DE,MSINITOK
	CALL	PSTRING

PNT2:
	LD	B,'@'
PNT2A:
	CALL	ZCSTS
	OR	A
	JP	NZ,QUIT

	INC	B
	LD	A,B
	CALL	TOUT
	PUSH	BC
	PUSH	AF
	LD	C,B
	CALL	ZCO
	LD	C,CR
	CALL	ZCO
	POP	AF
	POP	BC
	CP	'z'
	JR	NZ,PNT2A
	LD	B,'@'
	JR	PNT2A

	JP	QUIT


;-------------------------------------------------------------
;
;
;
TOUT:
;		;
;	JP	Z,TX_END
TX_SERLP:
	LD	A,(HL)			; GET CHARACTER TO A
	CP	'$'			; TEST FOR END BYTE
	JP	Z,TX_END		; JUMP IF END BYTE IS FOUND
;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY

;TX_BUSY:
	PUSH   AF
TX_BUSYLP_MSG:
	IN	A,(UART5)		; READ Line Status Register
	BIT	5,A			; TEST IF UART IS READY TO SEND
	JP	Z,TX_BUSYLP_MSG		; IF NOT REPEAT
	POP	AF
	OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
	INC	HL			; INC POINTER, TO NEXT CHAR
	JP	TX_SERLP		; TRANSMIT LOOP
TX_END:
	RET

	;**********************************
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit

;	LD	A,03H
;	OUT	(UART4),A		; Force DTR and RTS

	JP	INITRET			; 0 parity, reset DLAP FLAG
UART2400:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,48			; = 1,843,200 / ( 16 x 2400 )
	OUT	(UART0),A		;
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART4800:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,24			; = 1,843,200 / ( 16 x 4800 )
	OUT	(UART0),A		;
	3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART115K2:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,01
	OUT	(UART0),A		; = 1,843,200 / ( 16 x 115,200 )
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
					; 0 parity, reset DLAP FLAG
INITRET:
	RET


ZCSTS:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,CONST
	CALL	BDOS		;Returns with 1 in [A] if character at keyboard
	POP	HL
	POP	DE
	POP	BC
	CP	1
	RET

;
ZCO:	;Write character that is in [C]
	PUSH	AF
	PUSHTX_SER_CHAR:
;	PUSH	AF
;	LD	A,(SER_ON)		; IF COM IS OFF
;	CP	0			;
;	JP	Z,TX_END_CHAR
;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY

TX_BUSY:
	PUSH   AF
TX_BUSYLP:
	IN	A,(UART5)		; READ Line Status Register
	BIT	5,A			; TEST IF UART IS READY TO SEND
	JP	Z,TX_BUSYLP		; IF NOT REPEAT
	POP	AF
	OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
TX_END_CHAR:
	RET			;DONE


TIN:
;RX_SER_CHAR:
;	PUSH	AF
;	LD	A,(SER_ON)		; IF COM IS OFF
;	CP	0			;
;	JP	Z,RX_END_CHAR
;	CALL	RX_BUSY			; WAIT FOR UART TO GET READY

;RX_BUSY********************************
;*	INIT_UART
;*	Function	: Init serial port  8250, 16C450, OR 16C550
;*			9600 Baud, 8 bit, 1 stopbit, 0 parity
;*	Output		: none
;*	call		: PAUSE
;*	tested		: 2 Feb 2007
;******************************************************************

INIT_UART:
	LD	A,$AA
	OUT	(UART7),A
	IN	A,(UART7)
	CP	$AA	; TEST IF YOU COULD STORE AA
	JP	NZ,INITUART_FAIL	; IF NOT, THE UART CAN'T BE FOUND
	LD	A,$55
	OUT	(UART7),A		;
	IN	A,(UART7)
	CP	$55			;
	JP	NZ,INITUART_FAIL
	LD	A,$01
	LD	(SER_ON)LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART9600:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,12			; = 1,843,200 / ( 16 x 9600 )
	OUT	(UART0),A		; Set BAUD rate til 9600
	LD	A,00H
	OUT	(UART1),A		; Set BAUD rate til 9600
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART19K2:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,06			; = 1,843,200 / ( 16 x 19,200 )
	OUT	(UART0),A	BC
	PUSH	DE
	PUSH	HL
	LD	E,C
	LD	C,WRCON
	CALL	BDOS
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET

ZCI:	;Return keyboard character in [A]
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,RDCON
	CALL	BDOS
	POP	HL
	POP	DE
	POP	BC
	RET
;
;
;	;Print a string in [DE] up to '$'
PSTRING:
	LD	C,PRINT
	JP	BDOS		;PRINT MESSAGE,

;
;-------------------------------------------------------------------------------

MSINIT		DB 'Initalising UART...',CR,LF,'$'
MSINITOK	DB 'Ok.',CR,LF,'$'
MSINITNOK	DB 'Failure',CR,LF,'$'
; MSINIT		DB 'Initalising U> 2Ѕ>2ѕ—Н’>2їН:ѕ·(	іН’Г  ­Н’@Нi·В  xНSЕхHНwНwсБюz г@ЯГ  хЫЕЛoКTсУАЙЫЕЛGК_ЫАЙ~ю$К~хЫЕЛoКpсУА#ГiЙ>ЄУЗЫЗюЄВќ>UУЗЫЗюUВќ>2ЅГЈ>2ѕv> 2ѕ:їюКУюКжюКщюКюКюК2юКEюКX>ЂУГ>`УА> УБ>УГГh>ЂУГ>0УА> УБ>УГГh>ЂУГ>УА> УБ>УГГh>ЂУГ>УА> УБ>УГГh>ЂУГ>УА> УБ>УГГh>ЂУГ>УА> УБ>УГГh>ЂУГ>УА> УБ>УГГh>ЂУГ>УА> УБ>УГЙЕХеН бСБюЙхЕХеYН бСБсЙЕХеН бСБЙ	Г Initalising UART...
$Ok.
$Failure
$                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	SRL2BASE+6	; MODEM STATUS
  30:			; UART7		EQU	SRL2BASE+7	; SCRATCH REG.
  31:			
  32:			
  33:			
  34:	000A          	LF	EQU	0AH
  35:	000D          	CR	EQU	0DH
  36:	0008          	BS	EQU	08H		;Back space (required for sector display)
  37:	0007          	BELL	EQU	07H
  38:	0009          	TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
  39:	001B          	ESC	EQU	1BH
  40:	001C          	CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
  41:							;on other viART...',CR,LF,'$'
; MSINIT		DB 'Initalising UART...',CR,LF,'$'
; MSINIT		DB 'Initalising UART...',CR,LF,'$'
;
;-------------------------------------------------------------------------------

SER_ON:		DS	1	; serial on/off
UART_FAIL:	DS	1	; UART has failed detection flag
SER_BAUD:	DS	1	; specify desired UART com rate in bps

	END


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      1:			
   2:			;;
   3:			;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
   4:			;;
   5:			
   6:			
   7:	00C0          	SRL1BASE	EQU	$C0
   8:	00C8          	SRL2BASE	EQU	$C8
   9:			
  10:			; UART 16C550 1
  11:			
  12:	00C0          	UART0		EQU	SRL1BASE+0	; DATA IN/OUT
  13:	00C1          	UART1		EQU	SRL1BASE+1	; CHECK RX
  14:	00C2          	UART2		EQU	SRL1BASE+2	; INTERRUPTS
  15:	00C3          	UART3		EQU	SRL1BASE+3	; LINE CONTROL
  16:	00C4          	UART4		EQU	SRL1BASE+4	; MODEM CONTROdeo cards)
  42:	0001          	RDCON	EQU	1		;For CP/M I/O
  43:	0002          	WRCON	EQU	2
  44:	0009          	PRINT	EQU	9
  45:	000B          	CONST	EQU	11		;CONSOLE STAT
  46:	0005          	BDOS	EQU	5
  47:			
  48:	0000          	FALSE	EQU	0
  49:	FFFF          	TRUE	EQU	-1
  50:			
  51:	0000          	QUIT	EQU	0
  52:			
  53:	0100          		ORG	$100
  54:			
  55:	0100          	INITIALIZE:
  56:			
  57:			; initialize UART related functions and variables
  58:			
  59:	0100  3E00    		LD	A,0
  6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                L
  17:	00C5          	UART5		EQU	SRL1BASE+5	; LINE STATUS
  18:	00C6          	UART6		EQU	SRL1BASE+6	; MODEM STATUS
  19:	00C7          	UART7		EQU	SRL1BASE+7	; SCRATCH REG.
  20:			
  21:			; UART 16C550 2
  22:			
  23:			; UART0		EQU	SRL2BASE+0	; DATA IN/OUT
  24:			; UART1		EQU	SRL2BASE+1	; CHECK RX
  25:			; UART2		EQU	SRL2BASE+2	; INTERRUPTS
  26:			; UART3		EQU	SRL2BASE+3	; LINE CONTROL
  27:			; UART4		EQU	SRL2BASE+4	; MODEM CONTROL
  28:			; UART5		EQU	SRL2BASE+5	; LINE STATUS
  29:			; UART6		EQU0:	0102  32BD02  		LD	(SER_ON),A	; Initialize "Serial On" flag
  61:							; assume it is off until UART
  62:							; is autodetected
  63:	0105  3E01    		LD	A,1
  64:	0107  32BE02  		LD	(UART_FAIL),A	; Initialize "UART FAIL" flag
  65:							; assume it has failed until UART
  66:							; is autodetected as working
  67:			
  68:	010A  119702  		LD	DE,MSINIT
  69:	010D  CD9202  		CALL	PSTRING
  70:			
  71:			; 	LD	A,$01		; specify baud rate 1200 bps (1200,8,None,1)
  72:	0110  3E05    		LD	A,$05		; spec 		CP	'z'
 107:	014A  20E3    		JR	NZ,PNT2A
 108:	014C  0640    		LD	B,'@'
 109:	014E  18DF    		JR	PNT2A
 110:			
 111:	0150  C30000  		JP	QUIT
 112:			
 113:			
 114:			;-------------------------------------------------------------
 115:			;
 116:			;
 117:			;
 118:	0153          	TOUT:
 119:			;TX_SER_CHAR:
 120:			;	PUSH	AF
 121:			;	LD	A,(SER_ON)		; IF COM IS OFF
 122:			;	CP	0			;
 123:			;	JP	Z,TX_END_CHAR
 124:			;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY
 125:			
 126:	0153          	TX_BUSY:
  in B
 154:								; register and pass back to user
 155:	0168          	RX_END_CHAR:
 156:	0168  C9      		RET
 157:			
 158:			;*******************************************************
 159:			;*	MESSAGE PRINT ROUTINE
 160:			;*******************************************************
 161:			
 162:	0169          	TMSG:
 163:			;TX_SER:
 164:			;	PUSH	AF
 165:			;	LD	A,(SER_ON)		; IF COM IS OFF
 166:			;	CP	0			;
 167:			;	JP	Z,TX_END
 168:	0169          	TX_SERLP:
 169:	0169  7E      		LD	A,(HL)			; GET CHAR7
 194:			;******************************************************************
 195:			
 196:	017F          	INIT_UART:
 197:	017F  3EAA    		LD	A,$AA
 198:	0181  D3C7    		OUT	(UART7),A
 199:	0183  DBC7    		IN	A,(UART7)
 200:	0185  FEAA    		CP	$AA	; TEST IF YOU COULD STORE AA
 201:	0187  C29D01  		JP	NZ,INITUART_FAIL	; IF NOT, THE UART CAN'T BE FOUND
 202:	018A  3E55    		LD	A,$55
 203:	018C  D3C7    		OUT	(UART7),A		;
 204:	018E  DBC7    		IN	A,(UART7)
 205:	0190  FE55    		CP	$55			;
 206:	0192  C29D01 ify baud rate 9600 bps (9600,8,None,1)
  73:	0112  32BF02  		LD	(SER_BAUD),A	;
  74:	0115  CD7F01  		CALL	INIT_UART	; WITH NO FLOW CONTROL on terminal!!
  75:			
  76:	0118  3ABE02  		LD	A,(UART_FAIL)
  77:	011B  B7      		OR	A
  78:	011C  2809    		JR	Z,PNT1
  79:			
  80:	011E  11B302  		LD	DE,MSINITNOK
  81:	0121  CD9202  		CALL	PSTRING
  82:	0124  C30000  		JP	QUIT
  83:			
  84:	0127          	PNT1:
  85:	0127  11AD02  		LD	DE,MSINITOK
  86:	012A  CD9202  		CALL	PSTRING
  87:			
  88:	012D          	PN127:	0153  F5      		PUSH   AF
 128:	0154          	TX_BUSYLP:
 129:	0154  DBC5    		IN	A,(UART5)		; READ Line Status Register
 130:	0156  CB6F    		BIT	5,A			; TEST IF UART IS READY TO SEND
 131:	0158  CA5401  		JP	Z,TX_BUSYLP		; IF NOT REPEAT
 132:	015B  F1      		POP	AF
 133:	015C  D3C0    		OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
 134:	015E          	TX_END_CHAR:
 135:	015E  C9      		RET			;DONE
 136:			
 137:			
 138:	015F          	TIN:
 139:			;RX_SER_CHAR:
 140:			;	PUSH	AF
 141:			;	LD	A,(SERACTER TO A
 170:	016A  FE24    		CP	'$'			; TEST FOR END BYTE
 171:	016C  CA7E01  		JP	Z,TX_END		; JUMP IF END BYTE IS FOUND
 172:			;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY
 173:			
 174:			;TX_BUSY:
 175:	016F  F5      		PUSH   AF
 176:	0170          	TX_BUSYLP_MSG:
 177:	0170  DBC5    		IN	A,(UART5)		; READ Line Status Register
 178:	0172  CB6F    		BIT	5,A			; TEST IF UART IS READY TO SEND
 179:	0174  CA7001  		JP	Z,TX_BUSYLP_MSG		; IF NOT REPEAT
 180:	0177  F1      		POP	AF
 181:	0178  D3C0    		O 		JP	NZ,INITUART_FAIL
 207:	0195  3E01    		LD	A,$01
 208:	0197  32BD02  		LD	(SER_ON),A
 209:	019A  C3A301  		JP	UART_OK
 210:			
 211:	019D          	INITUART_FAIL:				; Handle if initialize UART fails
 212:	019D  3E01    		LD	A,1
 213:	019F  32BE02  		LD	(UART_FAIL),A
 214:	01A2  76      		HALT
 215:			
 216:			
 217:	01A3          	UART_OK:
 218:	01A3  3E00    		LD	A,0
 219:	01A5  32BE02  		LD	(UART_FAIL),A		; UART OK FOUND
 220:	01A8  3ABF02  		LD	A,(SER_BAUD)
 221:	01AB  FE01    		CP	1
 222:	01AD  CAT2:
  89:	012D  0640    		LD	B,'@'
  90:	012F          	PNT2A:
  91:	012F  CD6902  		CALL	ZCSTS
  92:	0132  B7      		OR	A
  93:	0133  C20000  		JP	NZ,QUIT
  94:			
  95:	0136  04      		INC	B
  96:	0137  78      		LD	A,B
  97:	0138  CD5301  		CALL	TOUT
  98:	013B  C5      		PUSH	BC
  99:	013C  F5      		PUSH	AF
 100:	013D  48      		LD	C,B
 101:	013E  CD7702  		CALL	ZCO
 102:	0141  0E0D    		LD	C,CR
 103:	0143  CD7702  		CALL	ZCO
 104:	0146  F1      		POP	AF
 105:	0147  C1      		POP	BC
 106:	0148  FE7A   _ON)		; IF COM IS OFF
 142:			;	CP	0			;
 143:			;	JP	Z,RX_END_CHAR
 144:			;	CALL	RX_BUSY			; WAIT FOR UART TO GET READY
 145:			
 146:			;RX_BUSY:
 147:			;	PUSH	AF
 148:	015F          	RX_BUSYLP:
 149:	015F  DBC5    		IN	A,(UART5)		; READ Line Status Register
 150:	0161  CB47    		BIT	0,A			; TEST IF DATA IN RECEIVE BUFFER
 151:	0163  CA5F01  		JP	Z,RX_BUSYLP		; LOOP UNTIL DATA IS READY
 152:	0166  DBC0    		IN	A,(UART0)		; THEN READ THE CHAR FROM THE UART
 153:			;	LD	B,A			; put received data characterUT	(UART0),A		; THEN WRITE THE CHAR TO UART
 182:	017A  23      		INC	HL			; INC POINTER, TO NEXT CHAR
 183:	017B  C36901  		JP	TX_SERLP		; TRANSMIT LOOP
 184:	017E          	TX_END:
 185:	017E  C9      		RET
 186:			
 187:				;******************************************************************
 188:			;*	INIT_UART
 189:			;*	Function	: Init serial port  8250, 16C450, OR 16C550
 190:			;*			9600 Baud, 8 bit, 1 stopbit, 0 parity
 191:			;*	Output		: none
 192:			;*	call		: PAUSE
 193:			;*	tested		: 2 Feb 200D301  		JP	Z,UART1200
 223:	01B0  FE02    		CP	2
 224:	01B2  CAE601  		JP	Z,UART2400
 225:	01B5  FE03    		CP	3
 226:	01B7  CAF901  		JP	Z,UART4800
 227:	01BA  FE04    		CP	4
 228:	01BC  CA0C02  		JP	Z,UART9600
 229:	01BF  FE05    		CP	5
 230:	01C1  CA1F02  		JP	Z,UART19K2
 231:	01C4  FE06    		CP	6
 232:	01C6  CA3202  		JP	Z,UART38K4
 233:	01C9  FE07    		CP	7
 234:	01CB  CA4502  		JP	Z,UART57K6
 235:	01CE  FE08    		CP	8
 236:	01D0  CA5802  		JP	Z,UART115K2
 237:								; IF NOTHING IS DEFINED 1200 WILL BT4800:
 265:	01F9  3E80    		LD	A,80H
 266:	01FB  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 267:	01FD  3E18    		LD	A,24			; = 1,843,200 / ( 16 x 4800 )
 268:	01FF  D3C0    		OUT	(UART0),A		;
 269:	0201  3E00    		LD	A,00H
 270:	0203  D3C1    		OUT	(UART1),A		;
 271:	0205  3E03    		LD	A,03H
 272:	0207  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 273:	0209  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 274:	020C          	UART9600:
 275:	020C  3E80    		LD	A,80H
 276:	020E  D3C3    		OUT	(UA 3E00    		LD	A,00H
 298:	023C  D3C1    		OUT	(UART1),A		;
 299:	023E  3E03    		LD	A,03H
 300:	0240  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 301:	0242  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 302:	0245  3E80    	UART57K6:	LD	A,80H
 303:	0247  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 304:	0249  3E02    		LD	A,02
 305:	024B  D3C0    		OUT	(UART0),A		; = 1,843,200 / ( 16 x 57,600 )
 306:	024D  3E00    		LD	A,00H
 307:	024F  D3C1    		OUT	(UART1),A		;
 308:	0251  3E03    		LD	A,03H
 e character that is in [C]
 338:	0277  F5      		PUSH	AF
 339:	0278  C5      		PUSH	BC
 340:	0279  D5      		PUSH	DE
 341:	027A  E5      		PUSH	HL
 342:	027B  59      		LD	E,C
 343:	027C  0E02    		LD	C,WRCON
 344:	027E  CD0500  		CALL	BDOS
 345:	0281  E1      		POP	HL
 346:	0282  D1      		POP	DE
 347:	0283  C1      		POP	BC
 348:	0284  F1      		POP	AF
 349:	0285  C9      		RET
 350:			
 351:	0286          	ZCI:	;Return keyboard character in [A]
 352:	0286  C5      		PUSH	BC
 353:	0287  D5      		PUSH	DE
E USED..
 238:			
 239:			
 240:	01D3          	UART1200:
 241:	01D3  3E80    		LD	A,80H
 242:	01D5  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 243:	01D7  3E60    		LD	A,96			;  = 1,843,200 / ( 16 x 1200 )
 244:	01D9  D3C0    		OUT	(UART0),A		;
 245:	01DB  3E00    		LD	A,00H
 246:	01DD  D3C1    		OUT	(UART1),A		;
 247:	01DF  3E03    		LD	A,03H
 248:	01E1  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 249:			
 250:			;	LD	A,03H
 251:			;	OUT	(UART4),A		; Force DTR and RTS
 252:			
 253:	01E3  C36802  RT3),A		; SET DLAB FLAG
 277:	0210  3E0C    		LD	A,12			; = 1,843,200 / ( 16 x 9600 )
 278:	0212  D3C0    		OUT	(UART0),A		; Set BAUD rate til 9600
 279:	0214  3E00    		LD	A,00H
 280:	0216  D3C1    		OUT	(UART1),A		; Set BAUD rate til 9600
 281:	0218  3E03    		LD	A,03H
 282:	021A  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 283:	021C  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 284:	021F  3E80    	UART19K2:	LD	A,80H
 285:	0221  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 286:	0223  3E06   309:	0253  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 310:	0255  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 311:	0258  3E80    	UART115K2:	LD	A,80H
 312:	025A  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 313:	025C  3E01    		LD	A,01
 314:	025E  D3C0    		OUT	(UART0),A		; = 1,843,200 / ( 16 x 115,200 )
 315:	0260  3E00    		LD	A,00H
 316:	0262  D3C1    		OUT	(UART1),A		;
 317:	0264  3E03    		LD	A,03H
 318:	0266  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 319:								; 0 parity,  354:	0288  E5      		PUSH	HL
 355:	0289  0E01    		LD	C,RDCON
 356:	028B  CD0500  		CALL	BDOS
 357:	028E  E1      		POP	HL
 358:	028F  D1      		POP	DE
 359:	0290  C1      		POP	BC
 360:	0291  C9      		RET
 361:			;
 362:			;
 363:			;	;Print a string in [DE] up to '$'
 364:	0292          	PSTRING:
 365:	0292  0E09    		LD	C,PRINT
 366:	0294  C30500  		JP	BDOS		;PRINT MESSAGE,
 367:			
 368:			;
 369:			;-------------------------------------------------------------------------------
 370:			
 371:	0297  4		JP	INITRET			; 0 parity, reset DLAP FLAG
 254:	01E6          	UART2400:
 255:	01E6  3E80    		LD	A,80H
 256:	01E8  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 257:	01EA  3E30    		LD	A,48			; = 1,843,200 / ( 16 x 2400 )
 258:	01EC  D3C0    		OUT	(UART0),A		;
 259:	01EE  3E00    		LD	A,00H
 260:	01F0  D3C1    		OUT	(UART1),A		;
 261:	01F2  3E03    		LD	A,03H
 262:	01F4  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 263:	01F6  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 264:	01F9          	UAR 		LD	A,06			; = 1,843,200 / ( 16 x 19,200 )
 287:	0225  D3C0    		OUT	(UART0),A		;
 288:	0227  3E00    		LD	A,0
 289:	0229  D3C1    		OUT	(UART1),A		;
 290:	022B  3E03    		LD	A,3
 291:	022D  D3C3    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 292:	022F  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 293:	0232  3E80    	UART38K4:	LD	A,80H
 294:	0234  D3C3    		OUT	(UART3),A		; SET DLAB FLAG
 295:	0236  3E03    		LD	A,03
 296:	0238  D3C0    		OUT	(UART0),A		; = 1,843,200 / ( 16 x 38,400 )
 297:	023A reset DLAP FLAG
 320:	0268          	INITRET:
 321:	0268  C9      		RET
 322:			
 323:			
 324:	0269          	ZCSTS:
 325:	0269  C5      		PUSH	BC
 326:	026A  D5      		PUSH	DE
 327:	026B  E5      		PUSH	HL
 328:	026C  0E0B    		LD	C,CONST
 329:	026E  CD0500  		CALL	BDOS		;Returns with 1 in [A] if character at keyboard
 330:	0271  E1      		POP	HL
 331:	0272  D1      		POP	DE
 332:	0273  C1      		POP	BC
 333:	0274  FE01    		CP	1
 334:	0276  C9      		RET
 335:			
 336:			;
 337:	0277          	ZCO:	;Writ96E6974	MSINIT		DB 'Initalising UART...',CR,LF,'$'
	      616C6973
	      696E6720
	      55415254
	      2E2E2E0D
	      0A24
 372:	02AD  4F6B2E0D	MSINITOK	DB 'Ok.',CR,LF,'$'
	      0A24
 373:	02B3  4661696C	MSINITNOK	DB 'Failure',CR,LF,'$'
	      7572650D
	      0A24
 374:			; MSINIT		DB 'Initalising UART...',CR,LF,'$'
 375:			; MSINIT		DB 'Initalising UART...',CR,LF,'$'
 376:			; MSINIT		DB 'Initalising UART...',CR,LF,'$'
 377:			;
 378:			;----------------------------------------------------------------       1f9     
initialize       100+    tin              15f+    uart5          =  c5+    
initret          268     tmsg             169+    uart57k6         245     
inituart_fail    19d     tout             153     uart6          =  c6+    
lf             =   a+    true           =ffff+    uart7          =  c7+    
msinit           297     tx_busy          153+    uart9600         20c     
msinitnok        2b3     tx_busylp        154     uart_fail        2be     
msinitok         2ad     tx_busylp_msg  
;;
;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
;;


SRL1BASE	EQU	$C0
SRL2BASE	EQU	$C8

; UART 16C550 1

; UART0:		EQU	SRL1BASE+0	; DATA IN/OUT
; UART1:		EQU	SRL1BASE+1	; CHECK RX
; UART2:		EQU	SRL1BASE+2	; INTERRUPTS
; UART3:		EQU	SRL1BASE+3	; LINE CONTROL
; UART4:		EQU	SRL1BASE+4	; MODEM CONTROL
; UART5:		EQU	SRL1BASE+5	; LINE STATUS
; UART6:		EQU	SRL1BASE+6	; MODEM STATUS
; UART7:		EQU	SRL1BASE+7	; SCRATCH REG.

; UART 16C550 2

UART0		EQU	SRL2BASE+0	; DATA IN/OUT
UART1		EQU	SRL2BASE+1	; CHECKLD	A,$04		; specify baud rate 9600 bps (9600,8,None,1)
	LD	(SER_BAUD),A	; 
	CALL	INIT_UART	; WITH NO FLOW CONTROL on terminal!!

	LD	A,(UART_FAIL)
	OR	A
	JR	Z,PNT1

	LD	DE,MSINITNOK
	CALL	PSTRING
	JP	QUIT

PNT1:
	LD	DE,MSINITOK
	CALL	PSTRING

PNT2:
	LD	B,'@'
PNT2A:
	CALL	ZCSTS
	OR	A
	JP	NZ,QUIT

	INC	B
	LD	A,B
	CALL	TOUT
	PUSH	BC
	PUSH	AF
	LD	C,B
	CALL	ZCO
	LD	C,CR
	CALL	ZCO
	POP	AF
	POP	BC
	CP	'Z'
	JR	NZ,PNT2A
	LD	B,'@'
	JR	PNT2A
	
	JP	QUIT


;-------------------------------------------------------------
;---------------
 379:			
 380:	02BD .. 02BD 00	SER_ON:		DS	1	; serial on/off
 381:	02BE .. 02BE 00	UART_FAIL:	DS	1	; UART has failed detection flag
 382:	02BF .. 02BF 00	SER_BAUD:	DS	1	; specify desired UART com rate in bps
 383:			
 384:	02C0          		END



Statistics:

     5	passes
     0	jr promotions
    62	symbols
     0	bytes



Symbol Table:

bdos           =   5+    quit           =   0+    uart115k2        258     
bell           =   7+    rdcon          =   1+    uart1200         1d3     
bs    170     uart_ok          1a3     
pnt1             127     tx_end           17e     wrcon          =   2+    
pnt2             12d+    tx_end_char      15e+    zci              286+    
pnt2a            12f     tx_serlp         169     zco              277     
print          =   9+    uart0          =  c0+    zcsts            269     
pstring          292     uart1          =  c1+    
                                                                                                                          RX
UART2		EQU	SRL2BASE+2	; INTERRUPTS
UART3		EQU	SRL2BASE+3	; LINE CONTROL
UART4		EQU	SRL2BASE+4	; MODEM CONTROL
UART5		EQU	SRL2BASE+5	; LINE STATUS
UART6		EQU	SRL2BASE+6	; MODEM STATUS
UART7		EQU	SRL2BASE+7	; SCRATCH REG.



LF	EQU	0AH
CR	EQU	0DH
BS	EQU	08H		;Back space (required for sector display)
BELL	EQU	07H
TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
ESC	EQU	1BH
CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
				;on other video cards)
RDCON	EQU	1		;For 
;
;
TOUT:
;TX_SER_CHAR:
;	PUSH	AF
;	LD	A,(SER_ON)		; IF COM IS OFF
;	CP	0			; 
;	JP	Z,TX_END_CHAR
;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY

TX_BUSY:
	PUSH   AF
TX_BUSYLP:
	IN	A,(UART5)		; READ Line Status Register
	BIT	5,A			; TEST IF UART IS READY TO SEND
	JP	Z,TX_BUSYLP		; IF NOT REPEAT
	POP	AF
	OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
TX_END_CHAR:
	RET			;DONE


TIN:
;RX_SER_CHAR:
;	PUSH	AF
;	LD	A,(SER_ON)		; IF COM IS OFF
;	CP	0			; 
;	JP	Z,RX_END_CHAR
;	CALL	RX_BUSY			; WAIT FOR UART TO GET R           =   8+    rx_busylp        15f     uart19k2         21f     
clear          =  1c+    rx_end_char      168+    uart2          =  c2+    
const          =   b+    ser_baud         2bf     uart2400         1e6     
cr             =   d+    ser_on           2bd     uart3          =  c3+    
esc            =  1b+    srl1base       =  c0+    uart38k4         232     
false          =   0+    srl2base       =  c8+    uart4          =  c4+    
init_uart        17f     tab            =   9+    uart4800                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  CP/M I/O
WRCON	EQU	2
PRINT	EQU	9
CONST	EQU	11		;CONSOLE STAT
BDOS	EQU	5

FALSE	EQU	0
TRUE	EQU	-1

QUIT	EQU	0

	ORG	$100
	
INITIALIZE:

; initialize UART related functions and variables

	LD	A,0
	LD	(SER_ON),A	; Initialize "Serial On" flag
				; assume it is off until UART
				; is autodetected
	LD	A,1
	LD	(UART_FAIL),A	; Initialize "UART FAIL" flag
				; assume it has failed until UART
				; is autodetected as working

	LD	DE,MSINIT
	CALL	PSTRING
	
; 	LD	A,$01		; specify baud rate 1200 bps (1200,8,None,1)
	EADY

;RX_BUSY:
;	PUSH	AF
RX_BUSYLP:
	IN	A,(UART5)		; READ Line Status Register
	BIT	0,A			; TEST IF DATA IN RECEIVE BUFFER
	JP	Z,RX_BUSYLP		; LOOP UNTIL DATA IS READY
	IN	A,(UART0)		; THEN READ THE CHAR FROM THE UART
;	LD	B,A			; put received data character in B
					; register and pass back to user
RX_END_CHAR:
	RET

;*******************************************************
;*	MESSAGE PRINT ROUTINE
;*******************************************************

TMSG:
;TX_SER:
;	PUSH	AF
;	LD	A,(SER_ON)		; IF COM ,$01
	LD	(SER_ON),A
	JP	UART_OK

INITUART_FAIL:				; Handle if initialize UART fails
	LD	A,1
	LD	(UART_FAIL),A
	HALT


UART_OK:
	LD	A,0
	LD	(UART_FAIL),A		; UART OK FOUND
	LD	A,(SER_BAUD)
	CP	1
	JP	Z,UART1200
	CP	2
	JP	Z,UART2400
	CP	3
	JP	Z,UART4800
	CP	4
	JP	Z,UART9600
	CP	5
	JP	Z,UART19K2
	CP	6
	JP	Z,UART38K4
	CP	7
	JP	Z,UART57K6
	CP	8
	JP	Z,UART115K2
					; IF NOTHING IS DEFINED 1200 WILL BE USED..


UART1200:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,96			;  = 1,843,200 / ( 16 x 1200 )
	OUT	(UART0 )
	OUT	(UART0),A		;
	LD	A,0
	OUT	(UART1),A		;
	LD	A,3
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART38K4:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,03
	OUT	(UART0),A		; = 1,843,200 / ( 16 x 38,400 )
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART57K6:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,02
	OUT	(UART0),A		; = 1,843,200 / ( 16 x 57,600 )
	LD	A,00H
	OUT	(UART1),A		;
	LSINIT		DB 'Initalising UART...',CR,LF,'$'
; MSINIT		DB 'Initalising UART...',CR,LF,'$'
; MSINIT		DB 'Initalising UART...',CR,LF,'$'
;
;-------------------------------------------------------------------------------
	
SER_ON:		DS	1	; serial on/off
UART_FAIL:	DS	1	; UART has failed detection flag
SER_BAUD:	DS	1	; specify desired UART com rate in bps

	END

	                                                                                                                                                          IS OFF
;	CP	0			; 
;	JP	Z,TX_END
TX_SERLP:
	LD	A,(HL)			; GET CHARACTER TO A
	CP	'$'			; TEST FOR END BYTE
	JP	Z,TX_END		; JUMP IF END BYTE IS FOUND
;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY

;TX_BUSY:
	PUSH   AF
TX_BUSYLP_MSG:
	IN	A,(UART5)		; READ Line Status Register
	BIT	5,A			; TEST IF UART IS READY TO SEND
	JP	Z,TX_BUSYLP_MSG		; IF NOT REPEAT
	POP	AF
	OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
	INC	HL			; INC POINTER, TO NEXT CHAR
	JP	TX_SERLP		; TRANSMIT LOOP
TX_END:
	RET

	;*******************0),A		;
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit

;	LD	A,03H
;	OUT	(UART4),A		; Force DTR and RTS

	JP	INITRET			; 0 parity, reset DLAP FLAG
UART2400:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,48			; = 1,843,200 / ( 16 x 2400 )
	OUT	(UART0),A		;
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART4800:
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,24			; = 1,843,200 / ( 16 x 4800 )
	OD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART115K2:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,01
	OUT	(UART0),A		; = 1,843,200 / ( 16 x 115,200 )
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
					; 0 parity, reset DLAP FLAG
INITRET:
	RET


ZCSTS:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,CONST
	CALL	BDOS		;Returns with 1 in [A] if character at keyboard
	POP	HL
	POP	DE
	POP	BC
	CP	1
	RET	
	
; 
ZCO:	;Write character that is                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ***********************************************
;*	INIT_UART
;*	Function	: Init serial port  8250, 16C450, OR 16C550
;*			9600 Baud, 8 bit, 1 stopbit, 0 parity
;*	Output		: none
;*	call		: PAUSE
;*	tested		: 2 Feb 2007
;******************************************************************

INIT_UART:
	LD	A,$AA
	OUT	(UART7),A
	IN	A,(UART7)
	CP	$AA	; TEST IF YOU COULD STORE AA
	JP	NZ,INITUART_FAIL	; IF NOT, THE UART CAN'T BE FOUND
	LD	A,$55
	OUT	(UART7),A		; 
	IN	A,(UART7)
	CP	$55			; 
	JP	NZ,INITUART_FAIL
	LD	AUT	(UART0),A		;
	LD	A,00H
	OUT	(UART1),A		;
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART9600:	
	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,12			; = 1,843,200 / ( 16 x 9600 )
	OUT	(UART0),A		; Set BAUD rate til 9600
	LD	A,00H
	OUT	(UART1),A		; Set BAUD rate til 9600
	LD	A,03H
	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
	JP	INITRET			; 0 parity, reset DLAP FLAG
UART19K2:	LD	A,80H
	OUT	(UART3),A		; SET DLAB FLAG
	LD	A,06			; = 1,843,200 / ( 16 x 19,20in [C]
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	E,C
	LD	C,WRCON
	CALL	BDOS
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET	

ZCI:	;Return keyboard character in [A]
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,RDCON
	CALL	BDOS
	POP	HL
	POP	DE
	POP	BC
	RET	
;
;
;	;Print a string in [DE] up to '$'
PSTRING:
	LD	C,PRINT
	JP	BDOS		;PRINT MESSAGE, 

;
;-------------------------------------------------------------------------------

MSINIT		DB 'Initalising UART...',CR,LF,'$'
MSINITOK	DB 'Ok.',CR,LF,'$'
MSINITNOK	DB 'Failure',CR,LF,'$'
; M> 2Ѕ>2ѕ—Н’>2їН:ѕ·(	іН’Г  ­Н’@Нi·В  xНSЕхHНwНwсБюZ г@ЯГ  хЫНЛoКTсУИЙЫНЛGК_ЫИЙ~ю$К~хЫНЛoКpсУИ#ГiЙ>ЄУПЫПюЄВќ>UУПЫПюUВќ>2ЅГЈ>2ѕv> 2ѕ:їюКУюКжюКщюКюКюК2юКEюКX>ЂУЛ>`УИ> УЙ>УЛГh>ЂУЛ>0УИ> УЙ>УЛГh>ЂУЛ>УИ> УЙ>УЛГh>ЂУЛ>УИ> УЙ>УЛГh>ЂУЛ>УИ> УЙ>УЛГh>ЂУЛ>УИ> УЙ>УЛГh>ЂУЛ>УИ> УЙ>УЛГh>ЂУЛ>УИ> УЙ>УЛЙЕХеН бСБюЙхЕХеYН бСБсЙЕХеН бСБЙ	Г Initalising UART...
$Ok.
$Failure
$                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   L2BASE+6	; MODEM STATUS
  30:	00CF          	UART7		EQU	SRL2BASE+7	; SCRATCH REG.
  31:			
  32:			
  33:			
  34:	000A          	LF	EQU	0AH
  35:	000D          	CR	EQU	0DH
  36:	0008          	BS	EQU	08H		;Back space (required for sector display)
  37:	0007          	BELL	EQU	07H
  38:	0009          	TAB	EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
  39:	001B          	ESC	EQU	1BH
  40:	001C          	CLEAR	EQU	1CH		;SD Systems Video Board, Clear to EOL. (Use 80 spaces if EOL not available
  41:							;on 04		; specify baud rate 9600 bps (9600,8,None,1)
  73:	0112  32BF02  		LD	(SER_BAUD),A	; 
  74:	0115  CD7F01  		CALL	INIT_UART	; WITH NO FLOW CONTROL on terminal!!
  75:			
  76:	0118  3ABE02  		LD	A,(UART_FAIL)
  77:	011B  B7      		OR	A
  78:	011C  2809    		JR	Z,PNT1
  79:			
  80:	011E  11B302  		LD	DE,MSINITNOK
  81:	0121  CD9202  		CALL	PSTRING
  82:	0124  C30000  		JP	QUIT
  83:			
  84:	0127          	PNT1:
  85:	0127  11AD02  		LD	DE,MSINITOK
  86:	012A  CD9202  		CALL	PSTRING
  87:			
  88:	012D                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     1:			
   2:			;;
   3:			;; Serial ports test for NEZ80 (Darkstar) MultiF-Board
   4:			;;
   5:			
   6:			
   7:	00C0          	SRL1BASE	EQU	$C0
   8:	00C8          	SRL2BASE	EQU	$C8
   9:			
  10:			; UART 16C550 1
  11:			
  12:			; UART0:		EQU	SRL1BASE+0	; DATA IN/OUT
  13:			; UART1:		EQU	SRL1BASE+1	; CHECK RX
  14:			; UART2:		EQU	SRL1BASE+2	; INTERRUPTS
  15:			; UART3:		EQU	SRL1BASE+3	; LINE CONTROL
  16:			; UART4:		EQU	SRL1BASE+4	; MODEM CONTROL
  17:			; UART5:		EQU	SRL1BASE+5	; LINE STATUS
 other video cards)
  42:	0001          	RDCON	EQU	1		;For CP/M I/O
  43:	0002          	WRCON	EQU	2
  44:	0009          	PRINT	EQU	9
  45:	000B          	CONST	EQU	11		;CONSOLE STAT
  46:	0005          	BDOS	EQU	5
  47:			
  48:	0000          	FALSE	EQU	0
  49:	FFFF          	TRUE	EQU	-1
  50:			
  51:	0000          	QUIT	EQU	0
  52:			
  53:	0100          		ORG	$100
  54:				
  55:	0100          	INITIALIZE:
  56:			
  57:			; initialize UART related functions and variables
  58:			
  59:	0100  3E00    		L        	PNT2:
  89:	012D  0640    		LD	B,'@'
  90:	012F          	PNT2A:
  91:	012F  CD6902  		CALL	ZCSTS
  92:	0132  B7      		OR	A
  93:	0133  C20000  		JP	NZ,QUIT
  94:			
  95:	0136  04      		INC	B
  96:	0137  78      		LD	A,B
  97:	0138  CD5301  		CALL	TOUT
  98:	013B  C5      		PUSH	BC
  99:	013C  F5      		PUSH	AF
 100:	013D  48      		LD	C,B
 101:	013E  CD7702  		CALL	ZCO
 102:	0141  0E0D    		LD	C,CR
 103:	0143  CD7702  		CALL	ZCO
 104:	0146  F1      		POP	AF
 105:	0147  C1      		POP	BC
 106:	01                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 18:			; UART6:		EQU	SRL1BASE+6	; MODEM STATUS
  19:			; UART7:		EQU	SRL1BASE+7	; SCRATCH REG.
  20:			
  21:			; UART 16C550 2
  22:			
  23:	00C8          	UART0		EQU	SRL2BASE+0	; DATA IN/OUT
  24:	00C9          	UART1		EQU	SRL2BASE+1	; CHECK RX
  25:	00CA          	UART2		EQU	SRL2BASE+2	; INTERRUPTS
  26:	00CB          	UART3		EQU	SRL2BASE+3	; LINE CONTROL
  27:	00CC          	UART4		EQU	SRL2BASE+4	; MODEM CONTROL
  28:	00CD          	UART5		EQU	SRL2BASE+5	; LINE STATUS
  29:	00CE          	UART6		EQU	SRD	A,0
  60:	0102  32BD02  		LD	(SER_ON),A	; Initialize "Serial On" flag
  61:							; assume it is off until UART
  62:							; is autodetected
  63:	0105  3E01    		LD	A,1
  64:	0107  32BE02  		LD	(UART_FAIL),A	; Initialize "UART FAIL" flag
  65:							; assume it has failed until UART
  66:							; is autodetected as working
  67:			
  68:	010A  119702  		LD	DE,MSINIT
  69:	010D  CD9202  		CALL	PSTRING
  70:				
  71:			; 	LD	A,$01		; specify baud rate 1200 bps (1200,8,None,1)
  72:	0110  3E04    		LD	A,$48  FE5A    		CP	'Z'
 107:	014A  20E3    		JR	NZ,PNT2A
 108:	014C  0640    		LD	B,'@'
 109:	014E  18DF    		JR	PNT2A
 110:				
 111:	0150  C30000  		JP	QUIT
 112:			
 113:			
 114:			;-------------------------------------------------------------
 115:			;
 116:			;
 117:			;
 118:	0153          	TOUT:
 119:			;TX_SER_CHAR:
 120:			;	PUSH	AF
 121:			;	LD	A,(SER_ON)		; IF COM IS OFF
 122:			;	CP	0			; 
 123:			;	JP	Z,TX_END_CHAR
 124:			;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY
 125:			
 126:	0153        data character in B
 154:								; register and pass back to user
 155:	0168          	RX_END_CHAR:
 156:	0168  C9      		RET
 157:			
 158:			;*******************************************************
 159:			;*	MESSAGE PRINT ROUTINE
 160:			;*******************************************************
 161:			
 162:	0169          	TMSG:
 163:			;TX_SER:
 164:			;	PUSH	AF
 165:			;	LD	A,(SER_ON)		; IF COM IS OFF
 166:			;	CP	0			; 
 167:			;	JP	Z,TX_END
 168:	0169          	TX_SERLP:
 169:	0169  7E      		LD	A,(Hed		: 2 Feb 2007
 194:			;******************************************************************
 195:			
 196:	017F          	INIT_UART:
 197:	017F  3EAA    		LD	A,$AA
 198:	0181  D3CF    		OUT	(UART7),A
 199:	0183  DBCF    		IN	A,(UART7)
 200:	0185  FEAA    		CP	$AA	; TEST IF YOU COULD STORE AA
 201:	0187  C29D01  		JP	NZ,INITUART_FAIL	; IF NOT, THE UART CAN'T BE FOUND
 202:	018A  3E55    		LD	A,$55
 203:	018C  D3CF    		OUT	(UART7),A		; 
 204:	018E  DBCF    		IN	A,(UART7)
 205:	0190  FE55    		CP	$55			; 
 2FINED 1200 WILL BE USED..
 238:			
 239:			
 240:	01D3          	UART1200:
 241:	01D3  3E80    		LD	A,80H
 242:	01D5  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 243:	01D7  3E60    		LD	A,96			;  = 1,843,200 / ( 16 x 1200 )
 244:	01D9  D3C8    		OUT	(UART0),A		;
 245:	01DB  3E00    		LD	A,00H
 246:	01DD  D3C9    		OUT	(UART1),A		;
 247:	01DF  3E03    		LD	A,03H
 248:	01E1  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 249:			
 250:			;	LD	A,03H
 251:			;	OUT	(UART4),A		; Force DTR and RTS
 252:			
 25  	TX_BUSY:
 127:	0153  F5      		PUSH   AF
 128:	0154          	TX_BUSYLP:
 129:	0154  DBCD    		IN	A,(UART5)		; READ Line Status Register
 130:	0156  CB6F    		BIT	5,A			; TEST IF UART IS READY TO SEND
 131:	0158  CA5401  		JP	Z,TX_BUSYLP		; IF NOT REPEAT
 132:	015B  F1      		POP	AF
 133:	015C  D3C8    		OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
 134:	015E          	TX_END_CHAR:
 135:	015E  C9      		RET			;DONE
 136:			
 137:			
 138:	015F          	TIN:
 139:			;RX_SER_CHAR:
 140:			;	PUSH	AF
 141:	L)			; GET CHARACTER TO A
 170:	016A  FE24    		CP	'$'			; TEST FOR END BYTE
 171:	016C  CA7E01  		JP	Z,TX_END		; JUMP IF END BYTE IS FOUND
 172:			;	CALL	TX_BUSY			; WAIT FOR UART TO GET READY
 173:			
 174:			;TX_BUSY:
 175:	016F  F5      		PUSH   AF
 176:	0170          	TX_BUSYLP_MSG:
 177:	0170  DBCD    		IN	A,(UART5)		; READ Line Status Register
 178:	0172  CB6F    		BIT	5,A			; TEST IF UART IS READY TO SEND
 179:	0174  CA7001  		JP	Z,TX_BUSYLP_MSG		; IF NOT REPEAT
 180:	0177  F1      		POP	AF
 181:	0106:	0192  C29D01  		JP	NZ,INITUART_FAIL
 207:	0195  3E01    		LD	A,$01
 208:	0197  32BD02  		LD	(SER_ON),A
 209:	019A  C3A301  		JP	UART_OK
 210:			
 211:	019D          	INITUART_FAIL:				; Handle if initialize UART fails
 212:	019D  3E01    		LD	A,1
 213:	019F  32BE02  		LD	(UART_FAIL),A
 214:	01A2  76      		HALT
 215:			
 216:			
 217:	01A3          	UART_OK:
 218:	01A3  3E00    		LD	A,0
 219:	01A5  32BE02  		LD	(UART_FAIL),A		; UART OK FOUND
 220:	01A8  3ABF02  		LD	A,(SER_BAUD)
 221:	01AB  FE01    		CP3:	01E3  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 254:	01E6          	UART2400:
 255:	01E6  3E80    		LD	A,80H
 256:	01E8  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 257:	01EA  3E30    		LD	A,48			; = 1,843,200 / ( 16 x 2400 )
 258:	01EC  D3C8    		OUT	(UART0),A		;
 259:	01EE  3E00    		LD	A,00H
 260:	01F0  D3C9    		OUT	(UART1),A		;
 261:	01F2  3E03    		LD	A,03H
 262:	01F4  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 263:	01F6  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 264:	0		;	LD	A,(SER_ON)		; IF COM IS OFF
 142:			;	CP	0			; 
 143:			;	JP	Z,RX_END_CHAR
 144:			;	CALL	RX_BUSY			; WAIT FOR UART TO GET READY
 145:			
 146:			;RX_BUSY:
 147:			;	PUSH	AF
 148:	015F          	RX_BUSYLP:
 149:	015F  DBCD    		IN	A,(UART5)		; READ Line Status Register
 150:	0161  CB47    		BIT	0,A			; TEST IF DATA IN RECEIVE BUFFER
 151:	0163  CA5F01  		JP	Z,RX_BUSYLP		; LOOP UNTIL DATA IS READY
 152:	0166  DBC8    		IN	A,(UART0)		; THEN READ THE CHAR FROM THE UART
 153:			;	LD	B,A			; put received 78  D3C8    		OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
 182:	017A  23      		INC	HL			; INC POINTER, TO NEXT CHAR
 183:	017B  C36901  		JP	TX_SERLP		; TRANSMIT LOOP
 184:	017E          	TX_END:
 185:	017E  C9      		RET
 186:			
 187:				;******************************************************************
 188:			;*	INIT_UART
 189:			;*	Function	: Init serial port  8250, 16C450, OR 16C550
 190:			;*			9600 Baud, 8 bit, 1 stopbit, 0 parity
 191:			;*	Output		: none
 192:			;*	call		: PAUSE
 193:			;*	test	1
 222:	01AD  CAD301  		JP	Z,UART1200
 223:	01B0  FE02    		CP	2
 224:	01B2  CAE601  		JP	Z,UART2400
 225:	01B5  FE03    		CP	3
 226:	01B7  CAF901  		JP	Z,UART4800
 227:	01BA  FE04    		CP	4
 228:	01BC  CA0C02  		JP	Z,UART9600
 229:	01BF  FE05    		CP	5
 230:	01C1  CA1F02  		JP	Z,UART19K2
 231:	01C4  FE06    		CP	6
 232:	01C6  CA3202  		JP	Z,UART38K4
 233:	01C9  FE07    		CP	7
 234:	01CB  CA4502  		JP	Z,UART57K6
 235:	01CE  FE08    		CP	8
 236:	01D0  CA5802  		JP	Z,UART115K2
 237:								; IF NOTHING IS DE1F9          	UART4800:
 265:	01F9  3E80    		LD	A,80H
 266:	01FB  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 267:	01FD  3E18    		LD	A,24			; = 1,843,200 / ( 16 x 4800 )
 268:	01FF  D3C8    		OUT	(UART0),A		;
 269:	0201  3E00    		LD	A,00H
 270:	0203  D3C9    		OUT	(UART1),A		;
 271:	0205  3E03    		LD	A,03H
 272:	0207  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 273:	0209  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 274:	020C          	UART9600:	
 275:	020C  3E80    		LD	A,80H
 276:	020E ,400 )
 297:	023A  3E00    		LD	A,00H
 298:	023C  D3C9    		OUT	(UART1),A		;
 299:	023E  3E03    		LD	A,03H
 300:	0240  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 301:	0242  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 302:	0245  3E80    	UART57K6:	LD	A,80H
 303:	0247  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 304:	0249  3E02    		LD	A,02
 305:	024B  D3C8    		OUT	(UART0),A		; = 1,843,200 / ( 16 x 57,600 )
 306:	024D  3E00    		LD	A,00H
 307:	024F  D3C9    		OUT	(UART1),A		;
 308:	0251  3E          	ZCO:	;Write character that is in [C]
 338:	0277  F5      		PUSH	AF
 339:	0278  C5      		PUSH	BC
 340:	0279  D5      		PUSH	DE
 341:	027A  E5      		PUSH	HL
 342:	027B  59      		LD	E,C
 343:	027C  0E02    		LD	C,WRCON
 344:	027E  CD0500  		CALL	BDOS
 345:	0281  E1      		POP	HL
 346:	0282  D1      		POP	DE
 347:	0283  C1      		POP	BC
 348:	0284  F1      		POP	AF
 349:	0285  C9      		RET	
 350:			
 351:	0286          	ZCI:	;Return keyboard character in [A]
 352:	0286  C5      		PUSH	BC
 353:	02---------------------------------------
 379:				
 380:	02BD          	SER_ON:		DS	1	; serial on/off
 381:	02BE          	UART_FAIL:	DS	1	; UART has failed detection flag
 382:	02BF          	SER_BAUD:	DS	1	; specify desired UART com rate in bps
 383:			
 384:	02C0          		END



Statistics:

    62	symbols
   445	bytes



Symbol Table:

bdos           =   5     quit           =   0     uart115k2        258     
bell           =   7+    rdcon          =   1     uart1200         1d3     
bs             =  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 277:	0210  3E0C    		LD	A,12			; = 1,843,200 / ( 16 x 9600 )
 278:	0212  D3C8    		OUT	(UART0),A		; Set BAUD rate til 9600
 279:	0214  3E00    		LD	A,00H
 280:	0216  D3C9    		OUT	(UART1),A		; Set BAUD rate til 9600
 281:	0218  3E03    		LD	A,03H
 282:	021A  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 283:	021C  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 284:	021F  3E80    	UART19K2:	LD	A,80H
 285:	0221  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 03    		LD	A,03H
 309:	0253  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 310:	0255  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 311:	0258  3E80    	UART115K2:	LD	A,80H
 312:	025A  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 313:	025C  3E01    		LD	A,01
 314:	025E  D3C8    		OUT	(UART0),A		; = 1,843,200 / ( 16 x 115,200 )
 315:	0260  3E00    		LD	A,00H
 316:	0262  D3C9    		OUT	(UART1),A		;
 317:	0264  3E03    		LD	A,03H
 318:	0266  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 319:		87  D5      		PUSH	DE
 354:	0288  E5      		PUSH	HL
 355:	0289  0E01    		LD	C,RDCON
 356:	028B  CD0500  		CALL	BDOS
 357:	028E  E1      		POP	HL
 358:	028F  D1      		POP	DE
 359:	0290  C1      		POP	BC
 360:	0291  C9      		RET	
 361:			;
 362:			;
 363:			;	;Print a string in [DE] up to '$'
 364:	0292          	PSTRING:
 365:	0292  0E09    		LD	C,PRINT
 366:	0294  C30500  		JP	BDOS		;PRINT MESSAGE, 
 367:			
 368:			;
 369:			;------------------------------------------------------------------------------  8+    rx_busylp        15f     uart19k2         21f     
clear          =  1c+    rx_end_char      168+    uart2          =  ca+    
const          =   b     ser_baud         2bf     uart2400         1e6     
cr             =   d     ser_on           2bd     uart3          =  cb     
esc            =  1b+    srl1base       =  c0+    uart38k4         232     
false          =   0+    srl2base       =  c8     uart4          =  cc+    
init_uart        17f     tab            =   9+    uart4800         1f9   286:	0223  3E06    		LD	A,06			; = 1,843,200 / ( 16 x 19,200 )
 287:	0225  D3C8    		OUT	(UART0),A		;
 288:	0227  3E00    		LD	A,0
 289:	0229  D3C9    		OUT	(UART1),A		;
 290:	022B  3E03    		LD	A,3
 291:	022D  D3CB    		OUT	(UART3),A		; Set 8 bit data, 1 stopbit
 292:	022F  C36802  		JP	INITRET			; 0 parity, reset DLAP FLAG
 293:	0232  3E80    	UART38K4:	LD	A,80H
 294:	0234  D3CB    		OUT	(UART3),A		; SET DLAB FLAG
 295:	0236  3E03    		LD	A,03
 296:	0238  D3C8    		OUT	(UART0),A		; = 1,843,200 / ( 16 x 38						; 0 parity, reset DLAP FLAG
 320:	0268          	INITRET:
 321:	0268  C9      		RET
 322:			
 323:			
 324:	0269          	ZCSTS:
 325:	0269  C5      		PUSH	BC
 326:	026A  D5      		PUSH	DE
 327:	026B  E5      		PUSH	HL
 328:	026C  0E0B    		LD	C,CONST
 329:	026E  CD0500  		CALL	BDOS		;Returns with 1 in [A] if character at keyboard
 330:	0271  E1      		POP	HL
 331:	0272  D1      		POP	DE
 332:	0273  C1      		POP	BC
 333:	0274  FE01    		CP	1
 334:	0276  C9      		RET	
 335:				
 336:			; 
 337:	0277-
 370:			
 371:	0297  496E6974	MSINIT		DB 'Initalising UART...',CR,LF,'$'
	      616C6973
	      696E6720
	      55415254
	      2E2E2E0D
	      0A24
 372:	02AD  4F6B2E0D	MSINITOK	DB 'Ok.',CR,LF,'$'
	      0A24
 373:	02B3  4661696C	MSINITNOK	DB 'Failure',CR,LF,'$'
	      7572650D
	      0A24
 374:			; MSINIT		DB 'Initalising UART...',CR,LF,'$'
 375:			; MSINIT		DB 'Initalising UART...',CR,LF,'$'
 376:			; MSINIT		DB 'Initalising UART...',CR,LF,'$'
 377:			;
 378:			;----------------------------------------  
initialize       100+    tin              15f+    uart5          =  cd     
initret          268     tmsg             169+    uart57k6         245     
inituart_fail    19d     tout             153     uart6          =  ce+    
lf             =   a     true           =ffff+    uart7          =  cf     
msinit           297     tx_busy          153+    uart9600         20c     
msinitnok        2b3     tx_busylp        154     uart_fail        2be     
msinitok         2ad     tx_busylp_msg    170     uar;
;=======================================================================
;
; Modular Z80 DarkStar (NE Z80) Monitor
;
;=======================================================================
;
; UARTS AND CTC management
; ---------------------------------------------------------------------


ANSIDRV	EQU	FALSE			; set TRUE to enable ANSI console driver

;------- UARTS Section ---------


WRUREG0	macro	uregister
	LD	A,UART0
	ADD	A,uregister
	LD	C,A
	OUT	(C),B
	endm

RDUREG0	macro	uregister
	LD	A,UART0
	ADD	ers
	LD	A,(SUART)		; initialize baud rate.
	CP	UART0			; which uart ?
	JR	NZ,INIU1
	LD	A,(UART0BR)		; uart 0
	LD	B,A
	JR	INIU2
INIU1:	LD	A,(UART1BR)		; uart 1
	LD	B,A
INIU2:	WRUREG	R0BRDL			; write lsb divisor register
	LD	B,$0
	WRUREG	R1BRDM			; write msb divisor register (alwyas 0 for us)

	LD	B,00000011B		; setup 8 bit, 1 stop, no parity
					; 7 6 5 4 3 2 1 0
					;             +------ 11 = 8 bit word length
					;           +-------- 0 = 1 stop bit
					;         +---------- 0 = no parity
					;       ceiver lines status interrupt
					;         +---------- 0 = disable modem-status-change interrupt
					; +------------------ reserved (zero)
	WRUREG	R1IER
	POP	BC
	XOR	A			; init ok
	RET
INIUNOK:POP	BC
	LD	A,$FF
	RET


;;
;; Sends a char over serial line 0
;;
;; C: output char

	IF NOT ANSIDRV
TXCHAR0:
	ELSE
DOTXCHAR:
	ENDIF
	LD	A,C
	PUSH	BC
	PUSH	AF
TXBUSY0:
	RDUREG0	R5LSR			; read status
	BIT	5,A			; ready to send?
	JP	Z,TXBUSY0		; no, retry.
	POP	AF
	LD	B,A
	WRUREG0	R0RXTX
	POP	BC
	RET

;;
;; Sends a cht_ok          1a3     
pnt1             127     tx_end           17e     wrcon          =   2     
pnt2             12d+    tx_end_char      15e+    zci              286+    
pnt2a            12f     tx_serlp         169     zco              277     
print          =   9     uart0          =  c8     zcsts            269     
pstring          292     uart1          =  c9     
                                                                                                                                      A,uregister
	LD	C,A
	IN	A,(C)
	endm

WRUREG1	macro	uregister
	LD	A,UART1
	ADD	A,uregister
	LD	C,A
	OUT	(C),B
	endm

RDUREG1	macro	uregister
	LD	A,UART1
	ADD	A,uregister
	LD	C,A
	IN	A,(C)
	endm

WRUREG	macro	uregister
	LD	A,(SUART)
	ADD	A,uregister
	LD	C,A
	OUT	(C),B
	endm

RDUREG	macro	uregister
	LD	A,(SUART)
	ADD	A,uregister
	LD	C,A
	IN	A,(C)
	endm

DESEQ	macro	p1,p2
	LD	DE,[p1 << 8] + p2
	endm

; 	EXTERN	FSTAT, FOUT

; ;;
; ;; Select UART for following operations
; ;;
; ;; A = Selected chip
; ;;
;
; SELUA+------------ 0 = odd parity (n/a)
					;     +-------------- 0 = parity disabled (n/a)
					;   +---------------- 0 = turn break off
					; +------------------ 0 = disable divisor registers
	WRUREG	R3LCR
	LD	B,00000111B		; 7 6 5 4 3 2 1 0
					;               +---- 1 = enable FIFO and clear XMIT and RCVR FIFO queues
					;             +------ 1 = clear RCVR FIFO
					;           +-------- 1 = clear XMIT FIFO
					;         +---------- 0 = RXRDY & TXRDY pins mode 0
					;        +-------------- reserved (zear over serial line 1
;;
;; C: output char

TXCHAR1:
	LD	A,C
	PUSH	BC
	PUSH	AF
TXBUSY1:
	RDUREG1	R5LSR			; read status
	BIT	5,A			; ready to send?
	JP	Z,TXBUSY1		; no, retry.
	POP	AF
	LD	B,A
	WRUREG1	R0RXTX
	POP	BC
	RET



;;
;; Receive a char from serial line 1
;;
;; A: return input char

RXCHAR1:
	PUSH	BC
RXBUSY1:
	RDUREG1	R5LSR			; read status
	BIT	0,A			; data available in rx buffer?
	JR	Z,RXBUSY1		; loop until data is ready
	RDUREG1	R0RXTX
	POP	BC
	RET

;;
;; Receive a char from serial line 0
;;
;; A:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 RT:
; 	LD	(UARTSEL),A
; 	RET

;;
;; Select UART for following operations
;;
;; A = Selected chip
;;

INIUART0:
	LD	A,UART0
	LD	(SUART),A
	CALL	DOINIUART
	RET

INIUART1:
	LD	A,UART1
	LD	(SUART),A
	CALL	DOINIUART
	RET

DOINIUART:
	PUSH	BC
	LD	B,$AA
	WRUREG	R7SPR
	RDUREG	R7SPR
	CP	$AA			; test if you could store aa
	JP	NZ,INIUNOK		; if not, the uart can't be found

	LD	B,$55
	WRUREG	R7SPR
	RDUREG	R7SPR
	CP	$55			; or is defective
	JP	NZ,INIUNOK

	LD      B, $80
	WRUREG	R3LCR			; enable baud rate divisor registro)
					; +------------------ trigger level for FIFO interrupt
					;	Bits      RCVR FIFO
					;	 76     Trigger Level
					;	 00        1 byte         <-- actually
					;	 01        4 bytes
					;	 10        8 bytes
					;	 11       14 bytes
	WRUREG	R2FCR
	LD	B,00000001B	        ; 7 6 5 4 3 2 1 0
					;               +---- 1 = enable data available interrupt (and 16550 Timeout)
					;             +------ 0 = disable Transmit Holding Register empty (THRE) interrupt
					;           +-------- 0 = disable Rereturn input char

RXCHAR0:
	PUSH	BC
	PUSH	IX
	PUSH	DE
	PUSH	HL
	LD	IX,TMPBYTE

	IF	ANSIDRV
	LD	DE,(ALINKS)
	BIT	3,(IX)			; two byte seq pending
	JP	NZ,RXEXSB
	ENDIF

ESCNX:	LD	A,(IX)
	BIT	5,A			; test system interrupt status
	JR	NZ,RXCHAFIF		; enabled, uses queue
RXBUSY0:
	RDUREG0	R5LSR			; read status
	BIT	0,A			; data available in rx buffer?
	JR	Z,RXBUSY0		; loop until data is ready
	RDUREG0	R0RXTX
	JR	RXCHE
RXCHAFIF:
	LD	IX,FIFOU0
RXCHAFLP:
	CALL	FSTAT			; queue status
	JR	Z,RXCHAFLP		; loop until char 0	R5LSR			; read status
	BIT	0,A			; data available in rx buffer?
	JR	Z,RXEXESC		; no, user pressed ESC
	JP	ESCNX			; yes, go on
RXESCFIF:
	PUSH	IX
	LD	IX,FIFOU0
	CALL	FSTAT			; data available in queue?
	POP	IX
	JR	Z,RXEXESC		; no, user pressed ESC
	JP	ESCNX			; yes, we have something to work on
	;
WTCSI:	RES	1,(IX)			; in CSI reset flags
	CP	'['			; is a CSI: ESC+[ ?
	JR	Z,GOCSI			; yes
	CP	'O'			; is a CSI: ESC+O ? (used by F1 ... F4)
	JR	NZ,RXEXIMM		; WRONG sequence
GOCSI:	;
	SET	2,(IX)			; CSI ok
	JP	ESenght
;; > Z = 1 found
CPSTR:	LD	A,(DE)			; get char from str1
	INC	DE			; index next and compare
	CPI
	RET	NZ			; no match
	RET	PO			; end of string
	JR	CPSTR

;;
;; string table lookup
;;
;; DE < test string, HL < table, BC < # strings in table
;; > Z = 1 match, HL > in string match + 1
TSTLP:	PUSH	DE			; saves
	PUSH	BC
	LD	(ALINKS),HL		; current string start (incl. head)
	INC	HL
	INC	HL			; skip linked address
	LD	B,0
	LD	C,(HL)			; current string length
	LD	A,C
	LD	(ALNGHT),A		; current string len
	INC	BUT not suitable for BDOS
;; return codes...
;;
;; Returned value:
;; A =  0: No character in queue
;; A = FF: A character is available

USTATUS0:
	LD	A,(TMPBYTE)
	BIT	5,A			; test system interrupt status
	JR	NZ,USTAFIF		; enabled, uses queue
	PUSH	BC
	RDUREG0	R5LSR			; read status
	BIT	0,A			; data available in rx buffer?
	POP	BC
	JR	NZ,USTAT0
	XOR	A
	RET
USTAFIF:
	PUSH	IX
	LD	IX,FIFOU0
USTAF1:	CALL	FSTAT			; check on the status of the queue
	POP	IX
	JR	NZ,USTAT0		; return if z-flag set
	XOR	A
	RET
USTAT0:is ready
	DI
	CALL	FOUT			; get a character from the queue
	EI
	LD	A,C 			; and put it in correct register
RXCHE:	LD	HL,MIOBYTE
	BIT	3,(HL)			; yes: transform to uppercase ?
	JR	Z,RXCHE1		; no
	CP	'a'			; yes: is less then 'a' ?
	JP	M,RXCHE1		; yes: return, already ok
	CP	'{'			; no: then is greater than 'z' ?
	JP	P,RXCHE1		; yes: do nothing
	RES	5,A			; no: convert uppercase...
RXCHE1:
	IF 	NOT ANSIDRV
	POP	HL
	POP	DE
	POP	IX
	POP	BC
	RET
	ELSE
	LD	IX,TMPBYTE		; point to flag byte
	BIT	4,(IX)			; driver diCNX			; wait for next chars
PRCSQ:	;
	LD	HL,ASQBUF		; setup string
	LD	B,(HL)
	INC	B
	LD	(HL),B
POSBF:	INC	HL
	DJNZ	POSBF			; position in buffer
	LD	(HL),A			; write
	INC	HL
	LD	(HL),0			; terminate
	LD	DE,ASQBUF+1		; init search
	LD	HL,ANSIKEYS
	LD	BC,NAKEYS
	CALL	TLOOK			; perform it
	JR	NZ,RXEXIMM		; unknown seq
	;				; found in table, but we need
	LD	DE,(ALINKS)		; to test for a partial match
	OR	A			; diff from string head
	SBC	HL,DE
	DEC	L
	DEC	L
	DEC	L			; include head
	LD	A,(ALNGHT)		; check for lenHL
	LD	A,(ASQBUF)
	LD	C,A			; test string len
	CALL	CPSTR			; do compare
	JR	Z,MATCH			; exit if found
	LD	HL,(ALINKS)
	LD	A,(ALNGHT)		; reload current string len
	ADD	A,3
	LD	C,A
	ADD	HL,BC			; add length, address next
	POP	BC			; restore count
	POP	DE			; restore test string
	DEC	BC			; update string count
	;
TLOOK:	LD	A,B			; table search entry point
	OR	C			; check count = 0
	JR	NZ,TSTLP		; search next if not
	INC	A			; not found z = 0
	RET
MATCH:	POP	BC
	POP	DE			; clear stack
	RET				; found !


ASQBU	LD	A,$FF
	RET

;; Test UART 1 status
;;
;; Returned value:
;; A =  0: No character in queue
;; A = FF: A character is available

USTATUS1:
	PUSH	BC
	RDUREG1	R5LSR			; read status
	BIT	0,A			; data available in rx buffer?
	POP	BC
	JR	NZ,USTAT1
	XOR	A
	RET
USTAT1:	LD	A,$FF
	RET


	IF ANSIDRV			; ANSI driver for serial console
;;
;; TXCHAR print out the char in reg C
;; with full evaluation of kegacy escape sequences
;; translated into ANSI equivalents for serial console
;;
;; register clean: can be used as Csabled ?
	JP	NZ,RXEXIMM		; yes exit
	BIT	2,(IX)			; in sequence job?
	JR	NZ,PRCSQ		; yes
	BIT	1,(IX)			; in CSI job?
	JR	NZ,WTCSI		; yes
	CP	ESC			; ESC ?
	JP	NZ,RXEXIMM		; no exit
	;
	SET	1,(IX)			; activate ANSI keys processing
	; may be that user pressed ESC and this is not a sequence...
	LD	DE,2			; wait 2 ms, trying to see if this is a user
	CALL	DELAY			; operation with the ESC key.
	BIT	5,(IX)			; now we see if other chars are already availables
	JR	NZ,RXESCFIF		; int enabled, test uses queue
	RDUREG
	SUB	L
	JP	NZ,ESCNX		; partial match, wait for more
	LD	A,(DE)			; got it!
	CP	ESC			; if ESC is a two byte seq
	JR	NZ,RXEXSB		; exit for single byte code
	SET	3,(IX)			; flag a two byte retcode
	JR	RXEXIMM
RXEXSB:	RES	3,(IX)			; clear two-byters flag
	XOR	A
	LD	(ASQBUF),A
	INC	DE
	LD	A,(DE)			; return code
	JR	RXEXIMM
RXEX0:
	POP	AF
	JR	RXEXIMM
RXEXESC:
	LD	A,ESC
RXEXIMM:
	RES	2,(IX)
	POP	HL
	POP	DE
RXEXNP:	POP	IX
	POP	BC
	RET

;;
;; Any lenght string compare
;;
;; DE, HL < strings addresses
;; BC < max lF:	DEFB	0
ASQSTR:	DEFS	4
ALINKS:	DEFW	0
ALNGHT:	DEFB	0

	ENDIF


;;
;; Test UART status
;;
;; Returned flags:
;; RX status -> carry flag, TX status -> Z flag
;; C = 1: A character is available in the buffer.
;; Z = 1: A character can be sent.

; USTATUS:
; 	PUSH	BC
; 	RDUREG	R5LSR			; read status
; 	RRCA                            ; rotate RX status into carry
; 	BIT     4, A                    ; check TX status (after rot!)
; 	POP	BC
; 	RET

;;
;; Test UART 0 status
;;
;; The code above is clearly better, P/M BIOS replacement
;;
TXCHAR0:
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	; force jump to register restore and exit in stack
	LD	HL,TXCEXIT
	PUSH	HL
	;
	LD	A,C
	LD	HL,TMPBYTE
	BIT	4,(HL)			; plain serial i/o ?
	JR	NZ,TXJP3		; yes. transmit as-is
	LD	HL,MIOBYTE
	BIT	7,(HL)			; alternate char processing ?
	EX	DE,HL
	JR	NZ,TXCOU2		; yes: do alternate
	CP	$20			; no: is less then 0x20 (space) ?
	JR	NC,TXJP1		; no: go further
	ADD	A,A			; yes: is a special char
	LD	H,0
	LD	L,A
	LD	BC,TXVEC1
	ADD	HL,BC
	LD	A,(HL)
	INer than 24 ?
	RET	NC			; yes: error
	SUB	$1F			; no: ok
	RES	0,(HL)			; resets flags
	LD	HL,MIOBYTE
	RES	7,(HL)			; done reset
	LD	D,A			; load row
	LD	E,';'
	CALL	SEQEMIT			; and send
	LD	A,(APPBUF)		; load column
	LD	D,A
	LD	E,'H'
	CALL	SEQPAR			; and send
	POP	HL			; clean stack
TXCEXIT:
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET

CSIEMIT:
	LD	B,2
	LD	HL,CSI
CSICH:	LD	C,(HL)
	CALL	DOTXCHAR
	INC	HL
	DJNZ	CSICH
	RET

SEQEMIT:
	CALL	CSIEMIT			; send CSI
SEQPAR:	LD	A,D			; sequence parameter in D
	CP	$FF			; null,tr.)
	DW	TXNULL			; HT  0x09 (^I)  no-op
	DW	TXLF			; LF  0x0a (^J)  cursor down one line
	DW	ACHOME			; VT  0x0b (^K)  cursor @ column 0
	DW	ACLS			; FF  0x0c (^L)  page down (clear screen)
	DW	TXCR			; CR  0x0d (^M)  provess CR
	DW	ACLEOP			; SO  0x0e (^N)  clear to EOP
	DW	ACLEOL			; SI  0x0f (^O)  clear to EOL
	DW	TXNULL			; DLE 0x10 (^P)  no-op
	DW	ARESATR			; DC1 0x11 (^Q)  reset all attributes
	DW	TXNULL			; DC2 0x12 (^R)  hard crt reset and clear
	DW	TXNULL			; DC3 0x13 (^S)  no-op
	DW	TXNULL			; DCL			; HT  0x09 (^I)  no-op
	DW	TXNULL			; LF  0x0a (^J)  no-op
	DW	TXNULL			; VT  0x0b (^K)  no-op
	DW	ACLS			; FF  0x0c (^L)  blank screen
	DW	RIOCESC			; CR  0x0d (^M)  clear alternate output processing
	DW	AREDON			; SO  0x0e (^N)  set bit 5 RAM3BUF (red)
	DW	AWHTON			; SI  0x0f (^O)  res bit 5 RAM3BUF (red)
	DW	AGRNON			; DLE 0x10 (^P)  set bit 6 RAM3BUF (green)
	DW	AWHTON			; DC1 0x11 (^Q)  res bit 6 RAM3BUF (green)
	DW	TXNULL			; DC2 0x12 (^R)  cursor blink slow block
	DW	TXNULL			; DC3 0x13 (^S)  curC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)			; jump to TXVEC1 handler
TXJP1:	EX	DE,HL
	BIT	6,(HL)			; auto ctrl chars ??
	JR	Z,TXJP2			; no
	CP	$40			; yes: convert
	JR	C,TXJP2
	CP	$60
	JR	NC,TXJP2
	SUB	$40
	JR	TXJP3
TXJP2:	CP	$C0			; is semigraphic ?
	JR	C,TXJP3			; no
	SUB	$C0			; to table offset
	LD	H,0
	LD	L,A
	LD	BC,EQCP437
	ADD	HL,BC
	LD	C,(HL)
TXJP3:	CALL	DOTXCHAR		; display char
	RET
TXCOU2:					; alternate processing....
	CP	$20			; is a ctrl char ??
	JR	NC,ACRADR		; no: will set cursor pos
	ADD	A,A			; yes
 skip it
	JR	Z,SEQCMD
	OR	A			; zero ?
	JR	Z,SEQZER
	LD	B,A			; convert to BCD
	XOR	A
SQDAA:	INC	A
	DAA
	DJNZ	SQDAA
	LD	D,A
	AND	$F0			; hi nibble
	SRL	A
	SRL	A
	SRL	A
	SRL	A
	ADD	A,'0'
	CALL	SEQCHR			; send over
	LD	A,D			; reload parameter
	AND	$0F			; lo nibble
SEQZER:	ADD	A,'0'
	CALL	SEQCHR
SEQCMD:	LD	A,E			; sequence command in E
	CP	$FF			; null, skip it
	JR	Z,SEQEND
	JR	SEQCHR			; ...and send this too
SEQEND:	RET

SEQCHR:	LD	C,A			; send
	CALL	DOTXCHAR
	RET

CSI:	DEFB	ESC,'['


;; This table define t4 0x14 (^T)  no-op
	DW	AMVUP			; NAK 0x15 (^U)  cursor up one line
	DW	TXNULL			; SYN 0x16 (^V)  scroll off
	DW	TXNULL			; ETB 0x17 (^W)  scroll on
	DW	AMVLFTND		; CAN 0x18 (^X)  cursor left (non destr. only)
	DW	AMVRGT			; EM  0x19 (^Y)  cursor right
	DW	AMVDWN			; SUB 0x1a (^Z)  cursor down one line
	DW	SIOCESC			; ESC 0x1b (^[)  activate alternate output processing
	DW	TXNULL			; FS  0x1c (^\)  no-op
	DW	TXNULL			; GS  0x1d (^])  no-op
	DW	TXNULL			; RS  0x1e (^^)  disabled (no-op)
	DW	TXNULL			; US  0x1sor blink slow line
	DW	TXNULL			; DC4 0x14 (^T)  no-op
	DW	TXNULL			; NAK 0x15 (^U)  no-op
	DW	TXNULL			; SYN 0x16 (^V)  no-op
	DW	SASCFLTR		; ETB 0x17 (^W)  set ascii filter
	DW	RASCFLTR		; CAN 0x18 (^X)  reset ascii filter
	DW	NDBKSP			; EM  0x19 (^Y)  set non destructive BS
	DW	DBKSP			; SUB 0x1a (^Z)  set destructive BS
	DW	AREVSON			; ESC 0x1b (^[)  REVERSE ON
	DW	AREVSOF			; FS  0x1c (^\)  REVERSE OFF
	DW	ABLUON			; GS  0x1d (^])  set bit 7 RAM3BUF (blue)
	DW	AWHTON			; RS  0x1e (^^)  res bit 7 RAM3B	LD	H,0
	LD	L,A
	LD	BC,TXVEC2
	ADD	HL,BC
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)			; jump to service routine... (TXVEC2)
;; cursor addressing service routine
;; address is ESC + (COL # + 32) + (ROW # + 32) (then need a NUL to terminate...)
;; will be: CSI (ESC,[) + row + ';' + col + 'H'
ACRADR:	LD	HL,TMPBYTE
	BIT	0,(HL)
	JR	NZ,ROWSET
	CP	$70			; greater then 80 ?
	RET	NC			; yes: error
	SUB	$1F			; no: ok
	LD	(APPBUF),A		; store column
	SET	0,(HL)			; switch row/col flag
	RET
ROWSET:	CP	$39			; greathe offsets to jump to translation routines
;; for primary (non-escaped) mode

TXVEC1:
	DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
	DW	UCASEMOD		; SOH 0x01 (^A)  uppercase mode
	DW	LCASEMOD		; STX 0x02 (^B)  normal case mode
	DW	TXNULL			; ETX 0x00 (^C)  no-op
	DW	ACUROF			; EOT 0x04 (^D)  cursor off
	DW	ACURON			; ENQ 0x05 (^E)  cursor on
	DW	TXNULL			; ACK 0x06 (^F)  locate cursor at CURPBUF
	DW	TXBEL			; BEL 0x07 (^G)  beep
	DW	AMVLFT			; BS  0x08 (^H)  cursor left (destr. and non desf (^_)  no-op

;; This table define the offsets to jump to translation routines
;; for alternate (escaped) mode

TXVEC2:
	DW	RIOCESC			; NUL 0x00 (^@)  clear alternate output processing
	DW	ABLNKOF			; SOH 0x01 (^A)  BLINK OFF
	DW	ABLNKON			; STX 0x02 (^B)  BLINK ON
	DW	AUNDROF			; ETX 0x03 (^C)  UNDER OFF
	DW	AUNDRON			; EOT 0x04 (^D)  UNDER ON
	DW	AHLITOF			; ENQ 0x05 (^E)  HLIGHT OFF
	DW	AHLITON			; ACK 0x06 (^F)  HLIGHT ON
	DW	TXNULL			; BEL 0x07 (^G)  no-op
	DW	TXNULL			; BS  0x08 (^H)  no-op
	DW	TXNULUF (blue)
	DW	TXNULL			; US  0x1f (^_)  no-op

;;
;; ANSI ESCapes specific routines
;;
;; no comments on code below but it should be quite intuitive

TXNULL:
	RET

TXCR:
	LD	C,CR
	JP	DOTXCHAR

TXLF:
	LD	C,LF
	JP	DOTXCHAR

TXBKSP:
	LD	C,$08
	JP	DOTXCHAR

TXBEL:
	LD	C,$07
	JP	DOTXCHAR

AMVLFT:
	LD	HL,MIOBYTE
	BIT	4,(HL)
	JR	NZ,AMVLFTND
	JR	TXBKSP

ACUROF:					; CSI ?25l
	DESEQ	$FF,'?'
	CALL	SEQEMIT
	DESEQ	25,'l'
	CALL	SEQPAR
	RET

ACURON:					; CSI ?25h
	DESEQ	$FF,'?'
	CALL	SEQEMIT
	DESEQ	25,'h'
	CALL	SEQPAR
'
	JR	DOSND1

DOSND1:	CALL	SEQEMIT
	RET

; keyboard translation table

NAKEYS	EQU	22

		; sequences emitted upon reception of valid
		; keyboard input and valid sequences expected
ANSIKEYS:	; on keyboard input
	DEFB	$00,$7F		; DEL
	DEFB	2,"3~"
	DEFB	$00,$16		; INS
	DEFB	2,"2~"
	DEFB	$00,$1D		; HOME
	DEFB	1,"H"
	DEFB	$00,$14		; END
	DEFB	1,"F"
	DEFB	$00,$13		; PGUP
	DEFB	2,"5~"
	DEFB	$00,$07		; PGDN
	DEFB	2,"6~"
	DEFB	$00,$15		; UP
	DEFB	1,"A"
	DEFB	$00,$1A		; DOWN
	DEFB	1,"B"
	DEFB	$00,$18		; LEFT
	DEFB	1,"ok at resident portion
;       of the BIOS

;;
;; initialize Z80CTC
;;

INICTC:
	; First resets all four channels
	CALL	RESCTC

	; CTC interrupt vector
	LD	A,$F0			; vec is at FFF0
	OUT	(CTCCHAN0),A

	; Channel 3 - UART 0 interrupt handler
	LD	A,11010111B		; 7 6 5 4 3 2 1 0
					;               +---- 1 = command flag
					;             +------ 1 = channel reset
					;           +-------- 1 = time constant follow
					;         +---------- 0 = n/a in counter mode
					;       +------------ 1 = rise edge clocg
					;             +------ 1 = channel reset
					;           +-------- 1 = time constant follow
					;         +---------- 0 = n/a in counter mode
					;       +------------ 1 = rise edge clock
					;     +-------------- 0 = n/a in counter mode
					;   +---------------- 1 = select counter mode
					; +------------------ 1 = enable interrupts
	OUT	(CTCCHAN1),A
	LD	A,(CTC1TC)		; time constant for system timer (from 100 to 2 Hz)
	OUT	(CTCCHAN1),A

	; Channel 0 - hi speed timer/prescaler (feed channel 1)
	L	RET

AMVLFTND:
	DESEQ	$FF,'D'			; CSI n D
	JR	DOSND1

AMVDWN:
	DESEQ	$FF,'B'			; CSI n B
	JR	DOSND1

AMVUP:
	DESEQ	$FF,'A'			; CSI n A
	JR	DOSND1

AMVRGT:
	DESEQ	$FF,'C'			; CSI n C
	JR	DOSND1

ACHOME:					; CSI 0 G
	DESEQ	0,'G'
	JR	DOSND1

ACLS:					; CSI 2 J
	DESEQ	2,'J'
	CALL	SEQEMIT
	DESEQ	$FF,'H'
	JR	DOSND1

ACLEOP:					; CSI 0 J
	DESEQ	0,'J'
	JR	DOSND1

ACLEOL:					; CSI 0 K
	DESEQ	0,'K'
	JR	DOSND1

ARESATR:				; CSI 0 m
	DESEQ	0,'m'
	JR	DOSND1

ABLNKOF:				; CSI 25 m
	DESEQ	25,'m'
	JR	DOSND1

ABLNKOD"
	DEFB	$00,$19		; RIGHT
	DEFB	1,"C"
	DEFB	$1B,'A'		; F1 ...
	DEFB	1,"P"
	DEFB	$1B,'B'
	DEFB	1,"Q"
	DEFB	$1B,'C'
	DEFB	1,"R"
	DEFB	$1B,'D'
	DEFB	1,"S"
	DEFB	$1B,'E'
	DEFB	3,"15~"
	DEFB	$1B,'F'
	DEFB	3,"17~"
	DEFB	$1B,'G'
	DEFB	3,"18~"
	DEFB	$1B,'H'
	DEFB	3,"19~"
	DEFB	$1B,'I'
	DEFB	3,"20~"
	DEFB	$1B,'J'
	DEFB	3,"21~"
	DEFB	$1B,'K'
	DEFB	3,"23~"
	DEFB	$1B,'L'		; ... F12
	DEFB	3,"24~"

	; This table definex (possible) equivalence from NEZ80 character ROMs
	; and Code Page 437.
	; Note that final rendering onk
					;     +-------------- 0 = n/a in counter mode
					;   +---------------- 1 = select counter mode
					; +------------------ 1 = enable interrupts
	OUT	(CTCCHAN3),A
	LD	A,1			; time constant set to 1. At first interrupt request
					; form the UART will route it to the CPU
	OUT	(CTCCHAN3),A

	; Channel 2 - UART 1 interrupt handler
	LD	A,11010111B		; 7 6 5 4 3 2 1 0
					;               +---- 1 = command flag
					;             +------ 1 = channel reset
					;           +-------- 1 = time constant follD	A,00100111B		; 7 6 5 4 3 2 1 0
					;               +---- 1 = command flag
					;             +------ 1 = channel reset
					;           +-------- 1 = time constant follow
					;         +---------- 0 = start immediate
					;       +------------ 0 = no trigger
					;     +-------------- 1 = prescale 256
					;   +---------------- 0 = select timer mode
					; +------------------ 0 = disable interrupts
	OUT	(CTCCHAN0),A
	LD	A,(CTC0TC)			; time constant set to 32. 4Mhz / 256 / 32 = 488.28Hz
	OUT	(CTCCHAN0),AN:				; CSI 5 m
	DESEQ	5,'m'
	JR	DOSND1

AREVSOF:				; CSI 27 m
	DESEQ	27,'m'
	JR	DOSND1

AREVSON:				; CSI 7 m
	DESEQ	7,'m'
	JR	DOSND1


AUNDROF:				; CSI 24 m
	DESEQ	24,'m'
	JR	DOSND1

AUNDRON:				; CSI 4 m
	DESEQ	4,'m'
	JR	DOSND1

AHLITOF:				; CSI 22 m
	DESEQ	22,'m'
	JR	DOSND1

AHLITON:				; CSI 1 m
	DESEQ	1,'m'
	JR	DOSND1

AREDON:					; CSI 31 m
	DESEQ	31,'m'
	JR	DOSND1

AGRNON:					; CSI 32 m
	DESEQ	32,'m'
	JR	DOSND1

ABLUON:					; CSI 34 m
	DESEQ	34,'m'
	JR	DOSND1

AWHTON:					; CSI 37 m
	DESEQ	37,'m remote is really dependent from ITS font usage
	; 1) we consider only chars from $C0 to $FF
	; 2) no equivalents from $81 to $BF

EQCP437:
	DEFB	179,196,197,195,180,194,193,192,217,218,191,186,205,206,204,185
	DEFB	203,202,200,188,201,187,198,181,210,208,214,183,211,189,213,184
	DEFB	212,190,199,182,209,207,215,216,025,026,006,003,004,005,156,157
	DEFB	178,176,224,225,046,235,231,046,239,046,046,237,228,046,234,227


	ENDIF

;------- CTC Section ---------

; NOTE: system interrupts are not enabled here. Loow
					;         +---------- 0 = n/a in counter mode
					;       +------------ 1 = rise edge clock
					;     +-------------- 0 = n/a in counter mode
					;   +---------------- 1 = select counter mode
					; +------------------ 1 = enable interrupts
	OUT	(CTCCHAN2),A
	LD	A,1			; time constant set to 1. At first interrupt request
					; form the UART will route it to the CPU
	OUT	(CTCCHAN2),A

	; Channel 1 - lo speed system timer
	LD	A,11010111B		; 7 6 5 4 3 2 1 0
					;               +---- 1 = command fla

	RET				; all done

;;
;;
;;
CTCUNLCK:
	RETI

;;
;; Resets CTC
;;
RESCTC:
	CALL	CTCUNLCK
	LD	A,00000011B		; 7 6 5 4 3 2 1 0
					;               +---- 1 = command flag
					;             +------ 1 = channel reset
					; +------------------ 0 = n/a
	OUT	(CTCCHAN0),A
	OUT	(CTCCHAN1),A
	OUT	(CTCCHAN2),A
	OUT	(CTCCHAN3),A
	RET
; -----------

SUART:	DEFB	0

; -----------
                                                                                                                                             >2* НHНюК  OНџэтInitalising UART...
$Ok.
$Failure
$   >А2ЫНQЙ>И2ЫНQЙЕЄ:ЫЖOнA:ЫЖOнxюЄВОU:ЫЖOнA:ЫЖOнxюUВОЂ:ЫЖOнA:ЫюА :+ G:* G:ЫЖ OнA :ЫЖOнA:ЫЖOнA:ЫЖOнA:ЫЖOнAБЇЙБ>яЙyЕх>АЖOнxЛoКХсG>АЖ OнAБЙyЕх>ИЖOнxЛoКпсG>ИЖ OнAБЙЕ>ИЖOнxЛG(х>ИЖ OнxБЙЕЭеХеЭ!K Э~ Лo >АЖOнxЛG(х>АЖ OнxЭ! Нµэ(ыуНбэыy!L Л^(юaъaю{тaЛЇбСЭбБЙ:K Лo Е>АЖOнxЛGБ ЇЙЭеЭ! НµэЭб ЇЙ>яЙЕ>ИЖOнxЛGБ ЇЙ>яЙНН>рУи>ЧУл>Ул>ЧУк>Ук>ЧУй:( Уй>'Уи:) УиЙнMНЛ>УиУйУкУлЙ oPW( H         НН|Нс>я2> ! У‹>]У‹Ы‰ЛїЛЏУ‰ЙЫ‰ЛG ъyУЃЙ                                                                                                      Н^ЙлЛ^(Н§еЇ*H РлН:+лнRеБНYлГ^:O G>Pђ OН:+лилЛЦЙлЛ–ЙлЛюЙ>я2> ЙН:Їял*H лЇнR/јИГ^лЛ¶ЙлЛжЙлЛ¦Й!> ЛЖЙ!> ЛОЙ!> ЛЦЙ!> ЛЮЙ!> ЛоЙ!> ЛцЙ!> ЛюЙ!> Л†Й!> ЛЋЙ!> Л–Й!> ЛћЙ!> Л®Й!> Л¶Й!> ЛѕЙН:+P Н^ГzлЛѕЙлЛцЙP :> х>я2> > НПx± цс2> ЙNчя/ @sГ„Ћ§ДрКёј7@АNмш"ю(|N.
4злRадит:>ПУѓЇУѓУ‡=У‡                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "H )>ЏУ‚У†УЉНГ­!Ь xУЊ~УЌ#xю ф!  "H НK*H Н^Ї2O Й>УЊЫЌg>УЊЫЌo#b>УЊ|УЌ>УЊ}УЌRНП>УЊ|УЌ>УЊ}УЌ>УЊ|УЌ>УЊ}УЌ1!  "; Ї2= >п2> !  "H НЎеНІб#|ю х xЖУЊЇУЌц>УЊЙЫЊЛ(ъ!; ~УЂ#~У„#~У€:> УЋЇУЌЙхЫЊЛ(ъсУЂ:> УЋЇУЌЙхЕХе!qеy!L Л~л 5ю 0‡& oq	~#foйлЛv(
ю@8ю`0Ц@НПН:Н^:O <юP(R2O Йю 0‡& o±	~#foй!K ЛF юpРЦ 2- ЛЖЙю9РЦЛ†!L ЛѕG!°яP э:- 2O _л*H Г^бСБсЙЇ2O НґШ!L ЛV0шН:+(Г^еНV*H P  енRб8Лњ"H НKб8ЛњГ^н[H ЇнR|юШ}юПЙ!  Ї2O /2> "H Н^НKе> НП#|ю хбГ^.@.J.`.j
. .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ее:J o>
УЊ}УЌбГ­ЙлЛЮЙлЛћЙУЏЙ!L ~Лf Н7> НПНН7Й!L ~хЛжНDсwЙН:+н[H ЇнRј ЅИ+Н^е:O =юя >O2O !L ЛfбА> Г[!O ^ЇwWН:+нRН^ЙлЛ^(Н§еЇ*H РлН:+лнRеБНYлГ^:O G>Pђ OН:+лилЛЦЙлЛ–ЙлЛюЙ>я2> ЙН:Їял*H лЇнR/јИГ^лЛ¶ЙлЛжЙлЛ¦Й!> ЛЖЙ!> ЛОЙ!> ЛЦЙ!> ЛЮЙ!> ЛоЙ!> ЛцЙ!> ЛюЙ!> Л†Й!> ЛЋЙ!> Л–Й!> ЛћЙ!> Л®Й!> Л¶Й!> ЛѕЙН:+P Н^ГzлЛѕЙлЛцЙP :> х>я2> > НПx± цс2> ЙNчя/ @sГ„Ћ§ДрКёј7@АNмш"ю(|N.
4злRадит:>ПУѓЇУѓУ‡=У‡